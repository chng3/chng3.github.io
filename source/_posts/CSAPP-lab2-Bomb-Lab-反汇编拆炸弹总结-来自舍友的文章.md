---
title: CSAPP lab2 (Bomb Lab) 反汇编拆炸弹总结 - 来自舍友的文章
date: 2022-07-30 10:30:30
updated: 
tags:
categories:
hide: true
comment:
---



实验程序下载地址（官网）：http://csapp.cs.cmu.edu/2e/labs.html

每一关要通过反汇编分析出正确的字符串才能过关，否则弹出bomb！！程序停止运行

一共有6个炸弹和一个隐藏炸弹。



我们学校为了防止同学们互相抄作业，每个人得到的炸弹都不一样，其实就是每一关都有3种不同的情况（除了第一关和隐藏炸弹那一关），于是我把每一关每一种情况都做了一遍。结合每一关的指令特征码写了一个自动拆炸弹的程序，能拆我们学校发下来的炸弹，其它学校的炸弹不一定能拆。



百度云盘下载地址：

链接：https://pan.baidu.com/s/1j-FS0X6NlOwTqPv8j6a7sg 

提取码：mrf2



# 准备工作



**便于我们分析，首先要反汇编程序：**

```
objdump -d bomb > bomb.asm
```

得到一个bomb.asm文件就是我们的程序汇编代码



**使用Linux下的反汇编调试器分析代码：**

```
gdb bomb
```

未接触过gdb还需要额外学习gdb的用法



**查看程序ELF结构：**

```
readelf -a bomb
```





# phase_1

输入一个字符串，比较输入的字符串和保存的字符串是否相等。



思路：

`callq  16fc <strings_not_equal>` 就是比较两个字符串是否相等的函数，

两个字符串通过参数传递到函数中，

其中%rdi就是自己输入的字符串，%rsi就是正确的字符串

进入函数，单步执行完`lea    0x16a1(%rip),%rsi`  语句后，

输入%rsi的值就是答案（在gdb中使用`x/s %rsi`输出）

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1637993820059-04fa4b30-23ec-49cc-83f0-0b0b23d7b4f7.png)



------

# phase_2

输入6个数，判断6个数之间的规律



### 情况一：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1637995926316-2478a818-ca1b-4353-960b-373040627926.png)

第一个参数必须为1，且下一个参数是上一个参数的两倍。

答案：1 2 4 8 16 32



### 情况二：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1637999823800-76ef6a3c-8dbd-46ad-a1a2-d64b721c7e2f.png)

第一个参数不能为负数，且 上一个参数的值 + 上一个参数的位置（从1开始） = 下一个参数的值

答案：0 1 3 6 10 15  或 1 2 4 7 11 16 或 2 3 5 8 12 17 等等....



### 情况三：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638000293402-9184a3d4-60b7-4566-965d-ad7f42089c07.png)

第一个参数必须为0，第二个参数必须为1，接下来的参数规律为 

参数的值 = 上一个参数的值 + 上上一个参数的值

即斐波那契数列: n = (n-1) + (n-2)

答案：0 1 1 2 3 5

------

# phase_3

输入两个整数，根据第一个整数的值跳转到指定的地址，执行一系列的算术计算得到第二个参数的值。



### 情况一：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638005343767-ed5287d8-42f9-4d01-91ab-d26a42b1a362.png)

要求输入3个参数，sscanf函数要求的格式为%d %c %d，

这格式在汇编语句`lea    0x1657(%rip),%rsi`中说明了。执行到该语句时输出%rsi就能看到：

在gdb中输出rsi的语句：`x/s $rsi`

经过参数1算出来的地址，跳转到该地址执行指令，再判断第二、第三参数的值



### 情况二：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638025795686-53b8b1f8-5768-4879-bb87-d53ca8d764d3.png)

要求输入两个整数，经过参数1算出来一个地址，

跳转到该地址执行一系列加减指令，得到第二个参数的值





### 情况三：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638033265815-3284499c-d01a-4f95-8da6-fba2ee940251.png)



要求输入两个整数，经过参数1算出来一个地址，

跳转到该地址执行mov 某个值, eax指令，eax就是第二个参数的值



------

# phase_4

考察递归函数，要求输入两个整数，其中第一个参数进入一个递归函数进行计算，得到的结果作为第二个参数的值



### 情况一：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179323867-46a10cc3-763b-4a61-8cc0-99f87eaf2359.png)

要求输入两个整数，第一个参数必须小于等于14，然后传第一个参数进入func4()进行计算，func4是一个递归函数，

计算出来的结果必须等于第二个参数的值。

比如这个举例中的计算出来的结果要求必须等于7，也就是要求第二个参数必须是7



phase_4还有可能是下面这种情况：第一个参数进入func4递归函数计算的结果等于第二个参数，要求第二个参数必须是0

汇编代码有一点点出入

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638203125462-f57a0205-6c3d-45c9-aa96-39a66d335992.png)



下面分析一下func4的函数：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179797742-63ca9457-94d6-40c5-ae12-cb407246f654.png)

因为是跟踪递归函数，分析起来特别绕，就还原成c语言代码的样子来看这个递归函数：

```c
int func4_1(int a, int b, int c){
    int sub = c - b;
    int tmp = (sub >> 31) & 1;      // 取c-b后的最高位符号位的值  c-b>=0时是0， c-b<0时是1
    tmp += sub;     // 加一次c-b的结果
    tmp >>= 1;		// tmp / 2

    tmp += b;

    if (tmp <= a){
        if (tmp == a) return 0;
        // tmp < a
        return func4_1(a, tmp + 1, c) * 2 + 1;
    }else{
        return func4_1(a, b, tmp - 1) * 2;
    }

}
```

但是还原成c语言代码后，仍然无法找到这个递归函数的规律，所以没头绪根据第二个参数的值来逆推第一个参数的值

于是就想到了暴力的方法：

因为第一个参数最多只能是 0 ~ 14，就尝试将这15个值依次传给func4函数，直到func4函数计算的返回值对上了第二个参数就行...那个就是答案

暴力破解代码：（res1、res2就是参数1和参数2）

```c
for (int i = 0; i <= 14; ++i) {
    if (func4_1(i, 0, 14) == res2){
        res1 = i;
        break;
    }
}
```



### 情况二：

与情况一十分类似，phase_4函数与情况一的一样，但是情况二func4的汇编与情况一func4有点出入：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638240086148-c97c58c4-fbfe-42a2-9ae7-889959406475.png)

还原成c语言代码后是这样子：

```c
int func4_2(int a, int b, int c){
    int sub = c - b;
    int tmp = (sub >> 31) & 1;      // 取c-b后的最高位符号位的值  c-b>=0时是0， c-b<0时是1
    tmp += sub;     // 加一次c-b的结果
    tmp >>= 1;		// tmp / 2

    tmp += b;

    if (tmp <= a){
        if (tmp == a) return tmp;
        // tmp < a
        return func4_2(a, tmp + 1, c) + tmp;
    }else{
        return func4_2(a, b, tmp - 1) + tmp;
    }
}
```

###### 解题思路跟情况一一样



### 情况三：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638530459022-d9bb7092-02f7-4757-a039-075515471207.png)

要求输入两个整数，其中第一个参数的值存在到(%rsp + 4)，第二个参数的值存放到(%rsp)

第二个参数的值 必须大于2等于2 且 小于等于4

然后传 **第二个参数** 进入func4()递归函数进行计算，

计算出来的结果必须等于 **第一个参数** 的值。



func4函数汇编代码:

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638201039649-3bb51edb-49bd-4461-8d02-fdc6bb07f037.png)



由func4函数汇编代码尝试逆向还原为c语言代码的样子：

```c
int func4(int a, int b){
    if (a == 0) return 0;
    if (a == 1) return b;
    return b + func4(a - 1, b) + func4(a - 2, b);
}
```





------



# Phase_5

考察数组操作。

### 情况一：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638260239080-33c957c1-67c3-4549-8ebf-48554ed6bcba.png)

要求输入6个字符，取输入的6个字符的ascii码，每一个字符 & 0xf，得到的值作为下标idx，在一个字符数组中获取该下标idx所在的字符，6个字符一共获取6次，拼凑成一个长度为6的字符串，该字符串要和答案字符串相等，即可通过。



字符数组其实就是上面汇编代码中指出：

```
    14d0:	48 8d 0d 69 14 00 00 	lea    0x1469(%rip),%rcx        # 2940 <array.3416>
```

执行到该行代码时，输出一下该字符数组的内容:

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261126691-a164de85-22b6-4600-a8cd-1ebb22676b96.png)

我们能取得长度一共16个字符，其中红色框中划起来的就是这个字符数组的内容，

为什么只能取16个字符？

因为 我们输入的字符 & 0xf 的数组下标能表示范围是  0 - 15



最终拼接出来的字符串要和答案字符串比较，答案字符串存放在：

```
    14fa:	48 8d 35 16 14 00 00 	lea    0x1416(%rip),%rsi        # 2917 <_IO_stdin_used+0x1b7>
```

输出该字符串的内容：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261852489-bba418f7-1eaa-466d-8fba-a6c4c9d58065.png)

注意：例子中的 0x0000555555556917 地址为程序加载到内存后，上面指令计算出来的%rsi地址。每次运行时的地址都会不同。





整个phase_5的流程相当于下面的c语言代码：

```c
char[] in = "abcdef";    # 假设输入的是这6个字符
char[] str = "maduiersnfotvbyl";	# 假设字符数组是这样
char[7] result;

for(int idx=0; idx < 6; idx++){
	result[i] = str[in[idx] % 15];
}

// result字符串跟答案字符串相同就通过
```

------

### 情况二：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263253652-47fb215a-e86e-4d52-9175-edae596c7b62.png)

要求输入6个字符，取输入的6个字符的ascii码，每一个字符 & 0xf 得到的值作为**下标idx**，在一个整数数组中获取这个**下标idx**所在的值，将它们累加起来，一共累加6次，累加得到的整数结果与某个常数值判断相等，即可通过。



其中整数数组的部分内容长这样：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263031586-8d27b2e8-cb48-4540-b1cb-c9a42f24f95e.png)

phase_5的主要流程相当于下面的c语言代码：

```c
char[] in = "abcdef";    # 假设输入的是这6个字符
int[] array = {2, 10, 6, 1, 12, 16, 9, 3, 4, 7, 14, 5, 11, 8, 15, 13};	# 整数数组
int result = 0;

for(int idx=0; idx < 6; idx++){
	result += array[in[idx] & 0xF];
}

// result字符串跟某个常数值相同就通过
```



------

### 情况三：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638272059649-c2d07443-7d49-478f-b73c-e766d5bced82.png)

要求输入两个整数值，参数1的值不能为15， 参数1 & 0xf 得到的值作为一个下标idx，用这个下标idx从一个整数数组中获取值，

在条件循环中 获取 整数数组[idx] 的值，将这个值累加起来，

直到 整数数组[idx] == 15时跳出循环。跳出循环后，要求循环的执行次数为15次、而且累加数等于第二个参数就可以通过。



其中整数数组的部分内容长这样：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638320131960-388acabe-e4a1-43ad-8832-cbb84008ecda.png)



phase_5的主要流程相当于下面的c语言代码：

```c
int a, b;   // 假如a,b为输入的两个整数值 参数1，参数2
int nums[] = {10,2,14,7,8,12,15,11,0,4,1,13,3,9,6,5}
int sum = 0, cnt = 0;
int tmp = a & 0xf;

if(tmp == 15) bomb();

do{
    cnt++;
    tmp = nums[tmp];
	sum += tmp;
}while(tmp != 15);

if(cnt != 15) bomb();
if(sum != b) bomb();

// 到这里就通过
```



------



# Phase_6



这一题是链表元素排序题，输入6个整数，要求都必须小于等于6，根据输入的数进行链表元素排序。

分三种情况，

一种是要求链表元素从大到小排序

一种是要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。

一种是要求链表元素从小到大排序





这题汇编代码量有亿点点长，但实际上三种情况的大部分汇编代码都相符，只需要弄懂其中一种情况的代码，其它两种就迎刃而解了。所以这里只展开说情况一，情况二、三简单描述。

解答这种大量汇编代码的题需要自己画一遍指令跳转图，关键地方写注释，分清楚每个部分的作用。



### 情况一

输入6个整数，要求链表按照这6个整数排序后，链表元素从大到小排序

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638426652892-e8086171-d1ce-4aa3-af53-dd9ffe3ab29a.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638434110608-53d2e8d0-dcb0-48ba-8ef7-a98f7f20e024.png)



在上面汇编代码中，核心的逻辑是将6个链表根据输入的值排序，然后判断排序的顺序是不是由大到小。

解题技巧是：只需要输出整个链表的各个值，依次写出排序顺序即可。



比如上面的例子，链表的地址在如下汇编代码中给出：

```
153e:	48 8d 15 cb 2c 20 00 	lea    0x202ccb(%rip),%rdx     # 204210 <node1>     ！！！第一个链表节点的位置
```



在gdb下, 程序加载到内存中，所以看到的链表地址是这样：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638428995222-02f14e0e-1670-40b0-b56d-8238de8006f2.png)

在这个例子中，链表的地址是`0x555555758210`



在gdb中输出这个链表，看看链表的结构如何，使用命令：

```
x/x 0x0000555555758210
```

输入这个命令后继续按回车，就会查看这个链表的往下几个字节：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638429359817-d5cda132-6058-4cf1-b714-b59acff31273.png)



根据上图的值，推断这个链表的c语言定义体如下：

```c
struct node{
    uint32_t value; // 链表元素值
    uint32_t num;  // 链表编号
    struct node *next;  // 链表下一个节点指针
};
```

先拿出每个元素的值

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432119589-02b2ecee-5f68-4309-b074-4161ec39ebaa.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432203079-27b42637-7aa3-4fa4-a81a-e3ca512810d0.png)



注意上图没有node6节点，它的地址在node5的next指针中可以看到，输出该地址的值就可以看到。

在gdb中输入指令：

```
x/x 0x0000555555758110
```

注意，next指针地址占8个字节，且在小端模式的机器中运行，

所以next指针地址应该看做`0x0000555555758110`，而不是`0x5575811000005555`

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432412756-44bea54a-cc61-4e69-bc45-08ddc46f96e1.png)



将6个节点的值汇总起来，并找出它们的大小关系

|                | node1 | node2 | node3 | node4 | node5 | node6 |
| -------------- | ----- | ----- | ----- | ----- | ----- | ----- |
| 十六进制       | 0x102 | 0x3e1 | 0x1ad | 0x2b0 | 0xb2  | 0x2de |
| 十进制         | 258   | 993   | 429   | 688   | 178   | 734   |
| 从大到小排第几 | 5     | 1     | 4     | 3     | 6     | 2     |

链表由大到小依次的顺序是:

node2-> node6 -> node4 -> node3 -> node1 -> node5



所以这题的答案是：

**2 6 4 3 1 5**



------



### 情况二：

输入6个整数，要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。



情况二和情况一相比只有几点不同的地方，这两者的部分汇编代码比较如下图：（红色字体为两者不同的地方）

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638437654331-c5d0102b-e8c2-4c23-82b0-982fb7d5b4bb.png)



因为情况一和情况二思路差不多，以情况一的链表作为例子，首先得到每个元素的值：

|                | node1 | node2 | node3 | node4 | node5 | node6 |
| -------------- | ----- | ----- | ----- | ----- | ----- | ----- |
| 十六进制       | 0x102 | 0x3e1 | 0x1ad | 0x2b0 | 0xb2  | 0x2de |
| 十进制         | 258   | 993   | 429   | 688   | 178   | 734   |
| 从大到小排第几 | 5     | 1     | 4     | 3     | 6     | 2     |

链表由大到小依次的顺序是:

node2-> node6 -> node4 -> node3 -> node1 -> node5



得到这6个排序的顺序值是：

**2 6 4 3 1 5**



排序规则是 7 - 某个数 = 顺序值

2 = 7 - **5**

6 = 7 - **1**

4 = 7 - **3**

3 = 7 - **4**

1 = 7 - **6**

5 = 7 - **2**



所以得到这题答案是：

**5 1 3 4 6 2**



------



### 情况三

输入6个整数，要求链表按照这6个整数排序后，链表元素从小到大排序



情况三与情况一，两者只有比较大小的指令不同

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638442032597-7c9ad575-3093-4a0d-aa1f-f3c16faf21df.png)



以情况一的链表作为例子，得到每个元素的值，列出从小到大的顺序：

|                | node1 | node2 | node3 | node4 | node5 | node6 |
| -------------- | ----- | ----- | ----- | ----- | ----- | ----- |
| 十六进制       | 0x102 | 0x3e1 | 0x1ad | 0x2b0 | 0xb2  | 0x2de |
| 十进制         | 258   | 993   | 429   | 688   | 178   | 734   |
| 从小到大排第几 | 2     | 6     | 3     | 4     | 1     | 5     |

链表由小到大依次的顺序是:

node5-> node1 -> node3 -> node4 -> node6 -> node2



所以这题答案是：

**5 1 3 4 6 2**





------



# 隐藏炸弹

在做完第6关的炸弹后，发现phase_6的汇编代码后面还有一个函数叫**secret_phase**

翻译一下就是隐藏的炸弹，这就是lab2中大名鼎鼎的隐藏炸弹函数了，

似乎要某种方式才能触发它，所以根据这个函数名找找哪个函数调用了它。



在反汇编代码中查找该函数名，发现整个程序中只有在**phase_defused**函数中调用了它，再查找一下谁调用了phase_defused函数

发现每通过一关都会调用一次phase_defused函数：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542390671-24d63361-2587-477b-8694-bc7bf1c0ae0a.png)





于是分析一下phase_defused函数的作用：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638541193669-0c887ebf-c44c-4b3d-bb8e-551f00dbd6b8.png)

每调用read_line函数，num_input_strings变量+1，num_input_strings变量可以理解为已经通过了第几关。

上图中说明这个函数大概意思是：在通过第6关后，会判断我们曾在第4关输入的内容，输入格式是 %d %d %s，

也就是说第四关除了输入两个整数以外，还要输入一个字符串，这个字符串就是进入隐藏函数的密钥。



使用gdb进入**phase_defused函数**输出一下这个密钥：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542129506-1760b0b3-9c5d-4d3e-bc54-f6049acbed0f.png)



这个密钥是：**DrEvil**

**（尽管每个人的前6关炸弹会有不同情况，但进入隐藏炸弹的密钥似乎大家都一样）**



所以如果想进入隐藏炸弹函数，就在原来的第四关通关答案中加入**DrEvil**字符串。

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542570949-9db49ab7-54ec-4c6c-9c55-958e1be8b312.png)



分析完如何进入隐藏炸弹后，开始分析隐藏炸弹的汇编代码：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638543600054-fb855f45-6a4b-4656-a70c-8c9eaacac98a.png)



隐藏炸弹的函数大概内容时：读入一行内容将它转换成10进制长整数，然后将这值传给fun7递归函数作为第二个实参，

判断返回结果，如果返回结果等于一个常数，隐藏炸弹就通关。上图的例子中，这个常数就是7.



注意到还有一个地址传给fun7作为第一个实参，输出一下这个地址，看一下里面的内容：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638550016555-aaa753c2-d5f6-4da1-8510-3164f5883a42.png)



可以大胆猜测到传入的地址就是一个双链表的头部地址，而fun7是一个递归函数，将它们还原为c语言代码更容易分析些：

```c
// 双链表
typedef struct{
    long long val;
    struct DNode* prev;		// 上一个链表指针
    struct DNode* next;		// 下一个链表指针
}DNode;


int fun7(DNode* p, long long num){
    /*
        由于整个函数都是对eax操作，而不是rax，
        所以mov $0xffffffff,%eax  可以看作int型的-1
    */
    if (!p) return -1;
    int val = p->val;
    if (val > num){
        return fun7(p->prev, num) * 2;
    }else if(val < num){
        return fun7(p->next, num) * 2 + 1;
    }else{  // val == b
        return 0;
    }
}
```

找出整个双链表的内容，还原一下它的样子

查看$rdi（即双链表头部地址）周围区域的内容：`x/128x $rdi`

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638595763216-6505b22e-ea3a-43b5-95f8-ef2b557effca.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596904727-5afeacef-841e-4f1a-b934-67563e8199e1.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596967846-29567282-cf20-4389-997a-9c644aeaa3b8.png)

继续查看n31、n32、n33、n34的链表指针指向的地址：

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599381317-c6f27893-a925-4a65-aa39-1dee57347fe4.png)



![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599654703-df912485-e876-4531-b257-b993bbda950b.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599692323-c8ca4231-7ed8-47c9-8127-a13aaa4b99f9.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599790277-62fb556f-6726-4dfd-a5c4-e21edb831838.png)



从这个双链表中画一个图找指针关联关系，发现是一颗二叉树，

并且结合fun7的递归函数规律，推导出一个结论：

当secret_phase函数传入fun7第二个实参等于二叉树第四层某颗树的值时，返回一个值。（如下图红色字体所示）

![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611077113-22bdf4f0-6284-4bdb-89ba-87956e4ff999.png)

而我们这个例子中要求fun7返回值要等于7，那么传入fun7第二个实参应该为 **0x3e9，即十进制的1001**

**所以这个例子中隐藏炸弹的通关字符串为：** **1001**



![img](https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611173603-cc05f6ce-50b5-4c36-b306-76990ecad850.png)



通关！！完美撒花~~~
