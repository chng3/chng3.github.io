<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6 之模版字面量</title>
      <link href="/2023/04/12/ES6%E4%B9%8B%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
      <url>/2023/04/12/ES6%E4%B9%8B%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/06/03/%E5%B1%82%E6%AC%A1%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/06/03/%E5%B1%82%E6%AC%A1%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<hr><hr><h2 id="组件库结构说明"><a href="#组件库结构说明" class="headerlink" title="组件库结构说明"></a>组件库结构说明</h2><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">library root                        <span class="hljs-regexp">//</span>组件库所在目录<br>├── document.html                   <span class="hljs-regexp">//</span>本说明文档<br>├── lib.js                          <span class="hljs-regexp">//</span>lib.js = jquery.js + common.js + JC.js<br>├── jquery.js                       <span class="hljs-regexp">//</span>jquery <span class="hljs-number">1.9</span>.<span class="hljs-number">1</span><br>├── common.js                       <span class="hljs-regexp">//</span>一些通用函数，组件中用到的函数如果出现在多个地方，可以考虑转移到这里<br>├── JC.js                          <span class="hljs-regexp">//</span>JC 资源控制器<br>├── _demo                           <span class="hljs-regexp">//</span>JC 资源控制器 使用例子<br>├── docs_api                        <span class="hljs-regexp">//</span>JC 组件库 API 文档<br>├── comps                           <span class="hljs-regexp">//</span>comps 目录存放由JC Project开发人员开发的jquery组件<br>│   ├── Calendar                    <span class="hljs-regexp">//</span>日历组件<br>│   ├── Form                        <span class="hljs-regexp">//</span>表单常用功能组件<br>│   ├── LunarCalendar               <span class="hljs-regexp">//</span>农历日历组件<br>│   ├── Panel                       <span class="hljs-regexp">//</span>弹框组件( JC.Panel, JC.alert, JC.confirm, JC.Dialog, JC.Dialog.alert, JC.Dialog.config );<br>│   ├── Tab                         <span class="hljs-regexp">//</span>Tab组件<br>│   ├── ExampleClass                <span class="hljs-regexp">//</span>测试组件, 新建组件时，直接拷贝这个目录变更一个名字<br>│   ├── Tips                        <span class="hljs-regexp">//</span>Tips组件<br>│   ├── Tree                        <span class="hljs-regexp">//</span>树菜单组件<br>│   └── Valid                       <span class="hljs-regexp">//</span>表单验证组件<br>├── plugins                         <span class="hljs-regexp">//</span>这个目录存放一些常用的第三方脚本<br>│   ├── base64.js<br>│   ├── jquery.form.js<br>│   ├── json2.js<br>│   ├── md5.js<br>│   ├── rate<br>│   └── swfobject.js<br>├── widgets                         <span class="hljs-regexp">//</span>这个目录存放一些HTML小部件<br>│   └── IframeUpload<br>└── tools                           <span class="hljs-regexp">//</span>这个目录存放一些有用的工具<br>    ├── generate_api_docs.sh  <span class="hljs-regexp">//</span>生成API文档shell<br>    ├── node_remove_View_Model.js   <span class="hljs-regexp">//</span>nodejs API 文档过滤脚本<br>    └── php                         <span class="hljs-regexp">//</span>PHP 工具，列目录用<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 绘画板</title>
      <link href="/2022/04/18/Canvas-%E7%BB%98%E7%94%BB%E6%9D%BF/"/>
      <url>/2022/04/18/Canvas-%E7%BB%98%E7%94%BB%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么在<code>add colors and sizes </code>这个提交之后，不用修改<code>onTouch</code>与<code>onMouse</code>的逻辑实现，画板颜色切换和画笔大小切换是直接就可以工作的？要想明白这个问题就得去第一次实现画笔移动工作的提交中也就是<code>init Canvas</code>，js 文件中找到判断移动设备语句 if(document.body.onTouch??)开始看。</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>onTouch 和 onMouse 函数里面只是专门负责绘制线条和橡皮擦这两个主要功能，绘制线条的颜色取决于绑定在每个画板颜色选择器回调中的设置</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bindColorsHandlers</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 选中红色画笔时</span><br>    redEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 覆盖改变绘制图形的填充颜色</span><br>        context.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>        <span class="hljs-comment">// 覆盖改变绘制线条的颜色</span><br>        context.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>        <span class="hljs-comment">// 循环删除每一个颜色画板样式</span><br>        colorsLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的红色画板添加样式</span><br>        redEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>画笔大小逻辑同上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定点击切换画笔大小的处理函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bindSizesHandlers</span>(<span class="hljs-params"></span>) &#123;<br>    thinEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        lineWidth = <span class="hljs-number">5</span><br>        <span class="hljs-comment">// 循环删除每一个画笔样式</span><br>        sizesLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的画笔添加样式</span><br>        thinEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br>    thickEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        lineWidth = <span class="hljs-number">10</span><br>        <span class="hljs-comment">// 循环删除每一个画笔样式</span><br>        sizesLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的画笔添加样式</span><br>        thickEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为什么在<code>add colors and sizes </code>这个提交之后，不用修改<code>onTouch</code>与<code>onMouse</code>的逻辑实现，画板颜色切换和画笔大小切换是直接就可以工作的？主要还是得益于代码编写时采取了模块化处理，例如将每个可以复用的点封装成一个函数，并为这个函数取个简单且易懂的名字，<strong>这样需要使用时就直接调用函数就可以</strong>。发现这可能就是<strong>函数式编程</strong>思想的特性之一。</p><p>模块化这个方法可以提高编写代码和维护代码的效率。</p><h1 id="关于函数式编程"><a href="#关于函数式编程" class="headerlink" title="关于函数式编程"></a>关于函数式编程</h1><p>请参见：<br>[深入理解函数式编程]: <a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初次接触 Figma</title>
      <link href="/2022/04/16/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6-Figma/"/>
      <url>/2022/04/16/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6-Figma/</url>
      
        <content type="html"><![CDATA[<p>参考文：</p><p><a href="https://mp.weixin.qq.com/s/6LUX-gyoaINUQvHvLBSgvg">https://mp.weixin.qq.com/s/6LUX-gyoaINUQvHvLBSgvg</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端攻城师</title>
      <link href="/2022/04/10/Front-End%20developer%20tech%20interview/"/>
      <url>/2022/04/10/Front-End%20developer%20tech%20interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Front-End-developer-tech-interview"><a href="#Front-End-developer-tech-interview" class="headerlink" title="Front-End developer tech interview"></a>Front-End developer tech interview</h1><h2 id="GET和POST两种基本请求方法的区别"><a href="#GET和POST两种基本请求方法的区别" class="headerlink" title="GET和POST两种基本请求方法的区别"></a>GET和POST两种基本请求方法的区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转 GitHub</title>
      <link href="/2021/10/18/%E7%8E%A9%E8%BD%AC-GitHub/"/>
      <url>/2021/10/18/%E7%8E%A9%E8%BD%AC-GitHub/</url>
      
        <content type="html"><![CDATA[<p>特殊的查找资源小技巧</p><p>常用前缀后缀</p><ul><li>找百科大全 <code>awesome xxx</code></li><li>找例子 <code>xxx sample</code></li><li>找空项目架子 <code>xxx starter/xxx boilerplate</code></li><li>找教程 <code>xxx tutorial</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/08/(%E7%AC%AC%E4%BA%8C%E7%AF%87)%E4%B8%BA%E4%BB%80%E4%B9%88Byte%E6%98%AF8%E4%BD%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8D%B4%E5%8F%AA%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%88%B0127%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF255%EF%BC%9F/"/>
      <url>/2021/10/08/(%E7%AC%AC%E4%BA%8C%E7%AF%87)%E4%B8%BA%E4%BB%80%E4%B9%88Byte%E6%98%AF8%E4%BD%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8D%B4%E5%8F%AA%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%88%B0127%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF255%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么8位有符号类型的数值范围是-128-127"><a href="#为什么8位有符号类型的数值范围是-128-127" class="headerlink" title="为什么8位有符号类型的数值范围是-128~127"></a>为什么8位有符号类型的数值范围是-128~127</h1><p>2018.04.01 23:23:07</p><p>我们知道，对于有符号类型，计算机在处理的时候会把最高位当做符号位，0表示正数，1表示负数。举例来说（以下举例均针对8位有符号数）：</p><p><em>0000 0001</em>即为<em>1</em>，<em>1000 0001</em>即为*-1<em>，那么很容易得到8位有符号数值的表示范围应该是</em>1111 1111* ~ <em>0111 1111</em>，也就是*-127*~<em>127</em>，问题来了，*-128*是怎么来的呢？</p><p>在说明这个问题之前，先来补充点额外的知识：</p><hr><p>在计算机的存储和计算中，统一的是采用补码进行处理和运算的，在弄清楚采用补码的好处之前，我们需要明确如下三个概念：</p><blockquote><p><em>原码：是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。</em></p></blockquote><blockquote><p><em>反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</em></p></blockquote><blockquote><p><em>补码：正数的补码与其原码相同；负数的补码等于其反码+1。</em></p></blockquote><p>很明显，文章开头的举例即是原码，它很符合我们的直观感觉，但是在计算的时候麻烦就来了，如果直接运算，例如<em>1+（-1）&#x3D;0</em>，运算的时候<em>0000 0001 + 1000 0001 &#x3D; 1000 0010（-2）</em>，很显然是错误的，因此符号位和数值位必须分开处理！这会增加计算机的硬件开销。我们换成补码试试，1的原码<em>0000 0001</em>，反码<em>0000 0001</em>，补码<em>0000 0001</em>（正数三者一致）；-1的原码1000 0001，反码1111 1110，补码1111 1111（1111 1110 + 0000 0001）；因此1+（-1）用补码来运算就是0000 0001 + 1111 11111 &#x3D; 0000 0000（最高位溢出舍弃）,结果是正确的。</p><blockquote><p><em>由此可见，可以将减法运算转化成加法运算，计算机只需要实现加法电路即可，并且原码到补码的转换和补码到原码的转换过程是完全一致的，为什么？可以简单证明如下：</em></p><p><em>假设32位机器，X为负数(最高位是符号位，对于负数，即为1)，则有X(绝对值)+X(反)&#x3D;0xFFFFFFFFF，因此X(绝对值)+X(反)+1&#x3D;0xFFFFFFFFF+1&#x3D;0；所以得到0-X(绝对值)&#x3D;X(反)+1，根据之前的定义X(反)+1即为X的补码，于是有X(补)&#x3D;X(反)+1&#x3D;0-X(绝对值)；</em></p><p><em>1）那么对于A、B&gt;0，令K&#x3D;-B，显然K是负数，那么有A-B&#x3D;A+(0-K(绝对值))&#x3D;A+K(补)，减法运算就转化成了加法运算。</em></p><p><em>2）X(绝对值)&#x3D;0-X(补);两边同时乘以-1 得到-X(绝对值)&#x3D;-0-(-X(补))&#x3D;0-(X(补(绝对值)))&#x3D;X(补)(反)＋1；-X(绝对值)即为原码X；因此上式说明了原码X等于X的补码取反后加一，也就是说X补码的补码就是原码。不论是原码求补码还是补码求原码方式完全一致。</em></p></blockquote><hr><p>回到最开始的问题，8位有符号数值的最小值为什么是-128而不是-127呢，我们列出来部分原码、反码和补码的对照表看看：</p><p><img src="https://upload-images.jianshu.io/upload_images/11416464-8c925d582b8d7b76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1155" alt="img"></p><p>图片发自简书App</p><p>从上表中我们可以看出，0在原码和反码中有两种表示方式，而对应的补码只有一种表示方式，-128在原码和反码中无法表示，在补码中却可以表示（用-127的补码<em>1000 0001</em>减1得到<em>1000 0000</em>）。而计算机中数值以补码形式存储和运算，当然-128可以表示出来，因此8位有符号数值的范围是-128～127，同理其他位数（16、32、64）也可以以此类推。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/08/%E4%B8%BA%E4%BB%80%E4%B9%88Byte%E6%98%AF8%E4%BD%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8D%B4%E5%8F%AA%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%88%B0127%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF255%EF%BC%9F/"/>
      <url>/2021/10/08/%E4%B8%BA%E4%BB%80%E4%B9%88Byte%E6%98%AF8%E4%BD%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8D%B4%E5%8F%AA%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%88%B0127%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF255%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么Byte是8位，但是却只能表示到127，而不是255？"><a href="#为什么Byte是8位，但是却只能表示到127，而不是255？" class="headerlink" title="为什么Byte是8位，但是却只能表示到127，而不是255？"></a>为什么Byte是8位，但是却只能表示到127，而不是255？</h1><h3 id="第一个问题：我们都知道一个二进制8位能表示的最大值是-1111-1111-x3D-x3D-255，但为什么最大表示到127？"><a href="#第一个问题：我们都知道一个二进制8位能表示的最大值是-1111-1111-x3D-x3D-255，但为什么最大表示到127？" class="headerlink" title="第一个问题：我们都知道一个二进制8位能表示的最大值是 1111 1111 &#x3D;&#x3D; 255，但为什么最大表示到127？"></a>第一个问题：我们都知道一个二进制8位能表示的最大值是 1111 1111 &#x3D;&#x3D; 255，但为什么最大表示到127？</h3><p>因为对于计算机来说，一个二进制的数字它的最高位是符号位，0表示正数，1表示负数。<br>所以 1111 1111 表示的 -127， 而 0111 1111 表示的是127，范围区间应该是[-127,127]之间。那么第二个问题来了</p><h3 id="第二个问题：我们都知道一个Byte能表达的数字范围是-128-127-，那么这个-128是怎么来的呢？"><a href="#第二个问题：我们都知道一个Byte能表达的数字范围是-128-127-，那么这个-128是怎么来的呢？" class="headerlink" title="第二个问题：我们都知道一个Byte能表达的数字范围是[-128,127]，那么这个-128是怎么来的呢？"></a>第二个问题：我们都知道一个Byte能表达的数字范围是[-128,127]，那么这个-128是怎么来的呢？</h3><p>这里面就涉及到计算机的原码、反码、和补码的相关知识了。</p><h5 id="正数："><a href="#正数：" class="headerlink" title="正数："></a>正数：</h5><p>原码 &#x3D;&#x3D; 反码 &#x3D;&#x3D; 补码<br>即：原：0000 0001 —– 反： 0000 0001 —— 补：0000 0001</p><h5 id="负数："><a href="#负数：" class="headerlink" title="负数："></a>负数：</h5><p>反码 &#x3D;&#x3D; 原码的非符号位取反<br>补码 &#x3D;&#x3D; 反码+1</p><p>即 原： 1000 0001 —— 反： 1111 1110 —— 补： 1111 1111</p><p>原码、反码、补码都可以表示同一个数字</p><h5 id="计算机内部是用补码来存储一个数的"><a href="#计算机内部是用补码来存储一个数的" class="headerlink" title="计算机内部是用补码来存储一个数的"></a>计算机内部是用补码来存储一个数的</h5><p>为什么要用补码来存呢？<br>既然规定了最高位是符号位，那么对于一个人来说正常的加减一个数（比如： 0010 1101 + 0111 1100， 0001 1011 - 1011 0011）可以把这个二进制转成带符号的十进制自然进行加减。<br>而对于计算机来说，同样需要识别符号位来判断是要加还是要减，也就这样势必会加大计算机的复杂性。因此希望符号位也可以参与到运算中，也就是 100 - 50 &#x3D;&#x3D; 100 + (-50)。把减法也可以转化成加法。</p><h5 id="这里举一个最简单的例子："><a href="#这里举一个最简单的例子：" class="headerlink" title="这里举一个最简单的例子："></a>这里举一个最简单的例子：</h5><p>1-1 &#x3D;&#x3D; 1+(-1) &#x3D;&#x3D; 0<br>那如果是两个原码相加是什么样的<br>0000 0001<br>+<br>1000 0001<br>&#x3D;<br>1000 0010 &#x3D;&#x3D; -2 结果肯定是不正确的</p><p>那如果两个反码相加<br>0000 0001<br>+<br>1111 1110<br>&#x3D;<br>1111 1111 转成原码 就是 1000 0000 &#x3D;&#x3D; -0 负0<br>结果没有问题，但从数学的角度来说，一个整数包括负整数，0，正整数，而这里出现了负0，-0和0其实都表示0，但是这里从编码来说却出现了两个值， 1000 0000 和 0000 0000</p><p>最后看下两个补码相加<br>0000 0001<br>+<br>1111 1111<br>&#x3D;<br>0000 0000 （超过8位的值被截掉） 转成原码 还是 0000 0000 &#x3D;0，<br>可以看出，结果不仅正确，还同时解决了正负0的问题。<br>而对于补码的加运算来说，是不可能出现1000 0000的情况，因为两数相加想出现1000 0000的情况，就必然是两个正数相加（如 0000 0001 + 0111 1111 &#x3D; 1000 0000），而两个正数相加是肯定不会出现负数的，所以1000 0000这个数肯定不会相加出现。</p><h5 id="因此计算机规定，补码：1000-0000-就表示-128"><a href="#因此计算机规定，补码：1000-0000-就表示-128" class="headerlink" title="因此计算机规定，补码：1000 0000 就表示 -128"></a>因此计算机规定，补码：1000 0000 就表示 -128</h5><p>所以8位二进制数可表达的范围是[-2^7, 2^7-1]&#x3D;[-128,127]<br>所以总结一下，补码不仅能正确的运算，同时还可以多表示一个最低位，所以计算机用补码来存储数字。</p><p>同理，16位，32位等等的其他二进制位的表示范围也就是[-2^15, 2^15-1], [-2^31, 2^31-1]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 和 SVG 区别</title>
      <link href="/2021/04/20/Canvas-%E5%92%8C-SVG-%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/04/20/Canvas-%E5%92%8C-SVG-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>以下内容取之菜鸟教程</p><h2 id="SVG-与-Canvas两者间的区别"><a href="#SVG-与-Canvas两者间的区别" class="headerlink" title="SVG 与 Canvas两者间的区别"></a>SVG 与 Canvas两者间的区别</h2><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><h2 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h2><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><table><thead><tr><th align="left">Canvas</th><th align="left">SVG</th></tr></thead><tbody><tr><td align="left">依赖分辨率<br />不支持事件处理器<br />弱的文本渲染能力<br />能够以 .png 或 .jpg 格式保存结果图像最适合图像<br />密集型的游戏，其中的许多对象会被频繁重绘</td><td align="left">不依赖分辨率<br />支持事件处理器<br />最适合带有大型渲染区域的应用程序（比如谷歌地图）<br />复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br />不适合游戏应用</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MDN 本土化之学习和获得帮助</title>
      <link href="/2021/04/20/MDN%20%E6%9C%AC%E5%9C%9F%E5%8C%96%E4%B9%8B%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%8E%B7%E5%BE%97%E5%B8%AE%E5%8A%A9/"/>
      <url>/2021/04/20/MDN%20%E6%9C%AC%E5%9C%9F%E5%8C%96%E4%B9%8B%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%8E%B7%E5%BE%97%E5%B8%AE%E5%8A%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是来自 MDN 文档 “学习 web 开发”路线图中关于”如何学习“ 章节的文章，也是本人为本土化翻译工作做的微小贡献，原文链接<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Learning_and_getting_help">学习和获得帮助</a></p></blockquote><p>你花一些时间学习一套新技能是很好的，但有时一些别人实践过的方法可以让你的学习更加有效。有时，您也会陷入困境并感到沮丧，即使是专业的 Web 开发人员也会经常这样，因此，了解最有效的方法，尝试获得帮助，以便您能够继续工作，是值得付出的。本文在这两个方面提供了一些提示和提示，可帮助您从学习 Web 开发中获得更多内容，并进一步阅读，以便您能够找到有关每个子主题的详细信息（如果您愿意）。</p><h2 id="有效学习">有效学习</h2><p>让我们直接思考一下有效的学习。</p><h3 id="不同的学习方法">不同的学习方法</h3><p>有趣的是，你的大脑学习东西有两种主要方式——专注<strong>和</strong><strong>分散学习</strong>：</p><ul> <li>重点学习是您传统上可能与学术科目联系在一起的东西。你专注于一个低级的话题，并解决它带来的具体问题。你专注于一个狭窄的区域。</li> <li>分散学习更多的是与围绕更广领域的高层次思维有关。你让你的头脑游荡更广，似乎在不同事物之间随机联系。这更多的是你在洗澡时或喝咖啡休息时的想法。</li></ul><p>从神经科学家对大脑活动所做的研究中，我们发现，你不能同时参与两种学习或思考的方式。那么，你应该选择哪一个呢？你可能认为集中学习更适合学习，但在现实中，<strong>两者</strong>都很重要。</p><p>专注思维对于将精力集中在特定主题上，深入解决问题，以及提高你对所需技术的掌握——加强大脑中存储信息的神经通路——都很棒。然而，当你试图理解新学科或解决以前没有遇到的新问题时，它并不善于理解"大局"，并解锁新的神经通路。</p><p>为此，你需要漫不由多的思考。这与焦点正好相反——你让你的大脑在更广阔的环境中游荡，四处寻找你之前没有的联系，接触新事物（或新事物的新组合），然后你可以关注这些事物，加强它们，并开始真正理解它们的意思。</p><p>这就是为什么在进入具体细节之前，先阅读一些介绍性材料，以便对一个领域有一个高度的了解，这通常是好的。</p><p>这也是为什么你有时真的可以陷入一个问题，但随后找出答案，当你去喝咖啡休息（或散步）。您可以：</p><ol> <li>知道如何使用工具 A 解决问题 A。</li> <li>知道如何用工具 B 解决问题 B。</li> <li>不知道如何解决问题 C 。</li></ol><p>假设您一直专注于问题 C，然后感到沮丧，因为您无法思考如何解决它。但是，在散步获得新鲜空气后，你可能会发现，当你的头脑徘徊，你突然使工具 A 和工具 B 之间的连接，并意识到你可以使用它们一起解决问题 C！它并不总是这么简单，但它也令人惊讶的是多少次，这确实发生了。这也凸显了在电脑前学习时定期休息的重要性。</p><h3 id="不同的学习材料">不同的学习材料</h3><p>也值得看看可用的不同类型的学习材料，看看哪些材料对您来说最有效。</p><h4 id="文本文章">文本文章</h4><p>你会发现很多书面文章在网上教你有关网页设计。例如，像本课程的多数课程一样。有些文章将是教程，教你某种技术或重要概念（如"学习如何创建视频播放器"或"学习CSS框模型"），有些文章将是参考材料，允许您查找您可能忘记的细节（如"CSS属性的语法是什么"？<code>background</code></p><p>MDN Web 文档对这两种类型都非常好 - 您当前位于的区域非常适合学习技术和概念，我们还有几个巨大的参考部分，允许您查找任何您不记得的语法。</p><p>网上还有其他几个伟大的资源，我们将在下面提及其中一些资源。</p><div class="blockIndicator note"><p><strong>注意</strong>：上面的文本应该给你一个重要的事实 - 你不应该记住一切！专业的 Web 开发人员使用 MDN Web 文档等工具查找他们一直忘记的内容。正如您会发现，学习 Web 开发更多的是关于问题解决和学习模式，而不是学习大量语法。</p></div><h4 id="Videos">视频资料</h4><p>还有一些网站上有视频学习内容。很明显 YouTube 是一个不错的网站，它有很多频道，比如 <a href="https://www.youtube.com/channel/UC7TizprGknbDalbHplROtag">Mozilla Layout Land</a>、<a href="https://www.youtube.com/MozillaDeveloper">MozillaDeveloper</a> 和 <a href="https://www.youtube.com/user/ChromeDevelopers/">Google ChromeDevelopers</a> 提供许多有用的视频。许多人更喜欢文本文章来进行更深入的学习和参考资料，喜欢视频来快速理解概念和新功能，但你更喜欢从中学习什么实际上取决于你自己。这里没有对错的说法。</p><h4 id="Interactive_code_playgrounds">交互式的代码演练场</h4><p>你可能是那种喜欢简单指令的人，更喜欢直接开始操纵代码。这也是一种合理的方法，一些学习网站倾向于采用这种方法。例如像 <a href="https://www.codecademy.com/">Codecademy</a> 这类网站中, 教程主要由交互式代码编辑器组成，您必须直接编写代码并查看是否达到了预期的结果。</p><p>许多 MDN Web 文档参考页面中也提供了交互式的示例，您可以在其中更改代码，并查看实时结果的变化。在你的计算机上或者在像 <a href="https://jsbin.com/?html,css,js,output">JSBin</a>、<a href="https://codepen.io/">Codepen</a> 或 <a href="https://glitch.com/">Glitch</a> 这样的在线代码编辑器中创建自己的代码示例也是可以的。事实上，当你在学习时，你会被要求去做这些事情本身就是属于课堂的一部分！</p><div class="blockIndicator note"><p><strong>Note</strong>：在线代码编辑器对于共享您编写的代码也非常有用，例如，如果您正在与不在同一位置的其他人协作学习，或者正在向他人发送代码以寻求帮助。您可以与他们共享代码示例的网址，以便他们可以查看。</p></div><div class="blockIndicator note"><p><strong>Note</strong>：与其他学习方法相比，你可能更喜欢一种学习方法，但实际上，你最终可能得到的是一种混合方法。你可能还会想出另外其他的方法，而不是我们上面提到的三种。</p></div><h3 id="Making_a_plan">制定一个计划</h3><p>制定一个计划来帮助你通过学习实现你想要实现的目标是个好主意。</p><h4 id="A_goal_statement">定一个目标</h4><p>这听起来很傻，但为什么不从一句话开始，说出你想要实现的目标呢？以下内容有不同的见识，但都是现实可行的：</p><ul> <li>我想在两年后成为一名专业的 Web 开发者。</li> <li>我想学习足够的知识，为我当地的业余网球俱乐部建立一个网站。</li> <li>我想学习 HTML 和 CSS，这样我就可以扩展我的工作角色，接管更新我们公司网站上的内容。</li></ul><p>下面是一些不切实际的想法：</p><ul> <li>我想在三个月内从一个完全的初学者变成一名高级 Web 开发人员。</li> <li>我想创办自己的公司，建立一个社交网络，在两年内超越 Facebook。</li></ul><h4 id="What_do_you_need_to_get_there">你需要什么才能到达那里？</h4><p>一旦你制定了目标，研究一下实现目标需要什么是个好想法。例如：</p><p>我需要的工具：</p><ul> <li>一台计算机</li> <li>接入互联网</li> <li>一些笔和纸</li></ul><p>我需要的知识：</p><ul> <li>如何使用 HTML、CSS、JavaScript 以及相关的工具和最佳实践来构建网站和 web 应用程序（我们绝对可以在这方面为您提供帮助！）。</li> <li>如何得到域名和主机，然后使用它们将网站发布到互联网上。</li> <li>如何经营一家小企业。</li> <li>如何为我的生意做广告，吸引客户。</li></ul><h4 id="How_much_time_and_money_will_it_take">这需要花费多少时间和金钱？</h4><p>预估得到这些东西的时间和成本。如果你需要工作来挣钱购买所需的材料，那么时间成本就必须考虑在内。一旦你有了一个时间估计，你就可以开始围绕你的生活制定一个计划。</p><h4 id="How_many_hours_per_week_do_I_need_to_dedicate">我每周需要投入多少小时？</h4><p>一旦你知道你需要做什么，以及你认为需要多长时间，你就可以开始写一个计划来实现你的目标。它可以简单到：</p><p>“我需要花 500 个小时来学习我需要知道的东西，我有一年的时间来学习。如果我假设有两周的假期，我打算每周为此学习 10 个小时(在晚上和周末有空的时候)，所以我会这样安排时间。”</p><p>当然，你能在这上面花多少时间取决于你的情况。如果你在学校，那么你有比其他有工作和孩子要养活的人地情况更多的空闲时间。如果不是，实现目标仍然是可能的，但你必须现实清楚地知道实现目标最快需要多长。</p><p>如果你正在大学或学院学习网络开发课程，那么大部分计划都是为你做的——你是幸运的！</p><p>当你制定了一个每周的日程安排之后，你应该在一个简单的电子表格中，甚至在笔记本上记录下你每周要做的事情！</p><p>此外，制定一些次级目标可能是个好主意，这样你就可以更容易地了解自己处在什么阶段。例如：</p><ul> <li>暑期学习 HTML 和 CSS 基础知识</li> <li>在 12 月学习完 JavaScript 基础知识</li> <li>在明年的 4 月份前搭建好一个示例网站</li> <li>等等。</li></ul><p>经常想一想你取得了多大的进步，在需要的时候及时调整你的计划。</p><h3 id="Staying_motivated">保持动力</h3><p>很难保持动力，尤其是当你试图学习编程或网络开发等复杂技能时。以下是一些保持动力并持续工作的建议：</p><ul> <li><strong>尽量让你的工作环境更有效率</strong>。找一张舒适的办公桌椅，确保你有足够的光线看清楚你在做什么，并尽量提供有助于你集中注意力的东西（如柔和的音乐、香水，任何你需要的东西）。不要试图在一个分心的房间里工作——比如开着电视，朋友们在看足球！另外，把手机放在房间外——大多数人都会被手机分心，所以你应该把它放在其他地方。 </li> <li><strong>定期休息</strong>。 不间断地工作几个小时对你的动力不好，尤其是当你发现工作很难或遇到问题时。这只会导致沮丧。通常最好休息一下，四处走动一会儿，然后在回去工作之前喝一杯咖啡或者饮料放松。正如我们之前所说，你在这段时间里所做的分散式学习通常可以帮助你找到解决你所面临问题的方法。长时间不休息也会对身体有害；盯着显示器看太久会伤害你的眼睛，久坐不动会对你的背部或腿部有害。我们建议每小时到90分钟这个区间内后休息15分钟。</li> <li><strong>吃饭、锻炼和睡觉</strong>。健康饮食，经常锻炼，确保充足的睡眠。这听起来很明显，但当你真正开始编码时，很容易忘记。将这些基本要素纳入你的时间表，确保你除此之外没有安排更多的学习时间。</li> <li><strong>奖励你自己</strong>。可以肯定的一点: <em>拼命工作而不娱乐会使你沉闷</em>。你应该尝试在每一次的学习之后安排一些有趣的事情，前提是你必须在完成学习任务之后。例如，如果你真的喜欢玩游戏，那么说“除非我完成了 5 个小时的学习，否则今晚不要玩游戏”是很有激励作用的。现在你只需要意志力。希望一些顺利。</li> <li><strong>共同学习和演示</strong>。这不是每个人的选择，但如果可能的话，试着和其他人一起学习。再说一次，如果你正在上一门关于网络开发的大学课程，这会更容易，但也许你可以说服一个朋友和你一起学习，或者找一个当地的聚会或技能分享小组？有人与你讨论想法并寻求帮助真的很有用，也很激励人，你还应该花时间向你的朋友展示你做了什么小样作品。那些感激的喊声会激励你前进。</li></ul><h3 id="Effective_problem_solving">高效解决问题</h3><p>没有一种有效的方法可以解决与 web 设计和开发相关的所有问题（学习所有东西），但在大多数情况下，有一些通用的建议可以很好地为您服务。</p><h4 id="Break_things_down_into_chunks">把东西分解成各个小块</h4><p>首先，当你试图实现某个特定的东西时，你的头脑似乎真的很难理解，你应该试着把它分解成多个较小的问题或块。</p><p>例如，如果你正在考虑“构建一个简单的两栏网站”的任务，你可以将其分解如下：</p><ul> <li>组织 HTML 结构</li> <li>制定基本的网站排版</li> <li>确定基本的网站颜色主题</li> <li>实现高级布局——页眉、水平导航菜单、带有主栏和侧栏的主要内容区域以及页脚</li> <li>实现一个水平的导航菜单</li> <li>等等。</li></ul><p>然后你可以进一步分解它。例如，“实现水平导航菜单”可以写成：</p><ul> <li>列出水平排列的菜单项。</li> <li>删除不必要的默认设置，如列表间距和项目符号。</li> <li>适当设置菜单项的悬停/焦点/激活状态。</li> <li>使菜单项沿直线等距排列。</li> <li>给菜单项留出足够的垂直间距。</li> <li>确保文本在每个菜单项内居中。</li> <li>等等。</li></ul><p>这些问题中的每一个似乎都不像你开始遇到的一个大问题那么难解决。现在你只需要逐步想出方案并解决所有问题！</p><h4 id="Learn_and_recognize_the_patterns">学习并认知模式</h4><p>正如我们之前所说，web 设计/编程主要是关于问题解决和模式。一旦你写下了你需要做什么来解决一个特定的问题，你就可以开始弄清楚用什么技术特性来解决它了。例如，专业的 web 开发人员已经创建了很多水平导航菜单，所以他们会立即开始考虑这样的解决方案：</p><p>创建一个水平导航栏菜单经常利用到列表，比如: </p><div class="code-wrapper"><pre class="brush: html notranslate">&lt;ul&gt;  &lt;li&gt;First menu item&lt;/li&gt;  &lt;li&gt;Second menu item&lt;/li&gt;  &lt;li&gt;Third menu item&lt;/li&gt;  &lt;li&gt;etc.&lt;/li&gt;&lt;/ul&gt;</pre></div><p>要使所有内容水平放置在一条线上，最简单的现代方法是使用 flexbox：</p><div class="code-wrapper"><pre class="brush: css notranslate">ul {  display: flex;}</pre></div><p>接着删除不必要的间距和要点， 我们可以这样做：</p><div class="code-wrapper"><pre class="brush: css notranslate">ul {  list-style-type: none;  padding: 0;}</pre></div><p>等等。</p><p>如果你是一个完全的网络开发初学者，你将不得不做一些研究和网络搜索和查找解决方案来解决这些问题。如果你是一名专业的 web 开发人员，你可能还记得上次解决类似问题的时候，只需要查找一些你后面遗忘的语法。</p><p>当你找到这些问题的解决方案时，写下你所做的事情，并在某个文件目录中保留一些少量的代码示例，这样你就可以回顾以前的工作了。</p><p>另外， 网络上有 <a href="/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">开发者工具</a>，它使您可以查看用在 web 上构建任何网站的代码。如果你手头没有解决方案，一个好的研究方法是在网络某处地方找到具有类似功能的网站，并找出它们是如何做到的。</p><div class="blockIndicator note"><p><strong>Note</strong>：请注意，上面我们讨论了我们首先要解决的问题，然后是用来解决这个问题的技术。这几乎总是最好的方法--不要从一个你看起来很酷但陌生的新技术开始，然后试着把它塞进用例中。</p></div><div class="blockIndicator note"><p><strong>Note</strong>： 最简单的解决方案往往是最好的。</p></div><h3 id="Getting_practice">做练习</h3><p>你练习解决问题越多，你的大脑在该区域的神经通路就越强大，也就越容易回忆起特定问题的细节和逻辑。</p><p>继续修补代码，并进行更多练习。如果你没有问题要解决，可以在网上查一些测试，多上一些课程，或者问问你的朋友和家人（或当地的学校或教堂），他们是否希望你为他们做些什么。</p><h2 dir="ltr" id="Getting_help">寻求帮助</h2><p dir="ltr">网络开发需要你学习一套复杂的技能——有时你肯定会陷入困境，需要帮助。正如我们之前所说，即使是专业开发人员在某些时刻也需要让他人来帮助解决问题。</p><p dir="ltr">获得帮助的方法有很多种，下面是一些非常有效的方法。</p><h3 dir="ltr" id="Effective_web_searches">高效的网络搜索</h3><p dir="ltr">需要学习的一项重要技能是高效网络搜索的技巧——你需要在你最喜欢的搜索引擎中使用哪些搜索词来找到你需要的文章？</p><p dir="ltr">搜索什么通常是相当直接的。例如：</p><ul dir="ltr"> <li>如果你想了解更多关于响应式网页设计的信息，你可以搜索”响应式网页设计”。</li> <li>如果你想了解更多关于某项特定技术功能的信息，像 HTML 元素，CSS 属性，或者 JavaScript 方法，你应该直接搜索功能的名称。<code>&lt;video&gt;</code><code>background-color</code><code>opacity</code><code>Date.setTime()</code></li> <li>如果您正在寻找一些更具体的信息，您可以添加其他关键字作为补充，例如 "&lt;video&gt; element autoplay attribute"， 或者 "Date.setTime parameters"。</li></ul><p dir="ltr">如果你想搜索一些没有那么明显的专业术语的东西，你需要考虑最有可能搜索到想要的东西是什么。</p><ul dir="ltr"> <li>在好几个 promises 执行之后运行代码</li> <li>在浏览器中播放网络摄像头中的视频流</li> <li>在元素的背景中创建线性渐变</li></ul><h4 id="Error_messages">报错信息</h4><p>如果你的某段代码有问题，并且出现了一条特定的错误消息，那么把错误消息将其用作搜索词复制到你的搜索引擎中。如果在之前其他人也有同样的问题，在 MDN 或 Stack Overflow 之类的地方可能会有一些关于它的文章或博客帖子。</p><div class="blockIndicator note"><p><strong>Note</strong>： <a href="https：//stackoverflow.com/">Stack Overflow</a> 是一个非常有用的网站——它基本上是一个关于各种技术和相关技术的精心挑选有质量的问题和答案的巨大数据库。你可能会找到一个回答你问题的答案。如果没有，你可以问一个问题，看看是否有人能帮助你。</p></div><h4 id="Browser_testing">浏览器调试</h4><p dir="ltr">看看你的问题是否在所有浏览器中都出现，或者它是否只发生在一个或少数浏览器中，这通常是一个好主意。例如，如果它只影响一个浏览器，则可以使用该浏览器缩小搜索范围。示例搜索可能看起来像：</p><ul dir="ltr"> <li>&lt;video&gt; 在 iOS 浏览器中播放不起作用。</li> <li>Firefox 浏览器似乎不支持 Beetlejuice API。</li></ul><h3 dir="ltr" id="Using_MDN">使用 MDN</h3><p dir="ltr">您现在所在的网站上有大量信息可供您使用，既有查找代码语法的参考资料，也有学习技巧的指南/教程。</p><p dir="ltr">在 MDN 的这一部分中，我们提供了关于 web 开发基础知识的大部分问题的答案。如果你陷入困境，最好重新阅读相关文章，看看你是否遗漏了什么。</p><p dir="ltr">如果你不确定该读哪篇文章，那么尝试在 MDN 中搜索一些相关的关键字（如上所述），或者尝试一般的网络搜索。要在 MDN 上搜索，你可以使用网站内置的搜索功能，或者使用你最喜欢的搜索引擎，在搜索词前面加上 “MDN”。例如，“mdn responsive web design“ 或者 ”mdn background-color“。</p><h3 dir="ltr" id="Other_online_resources">其他在线资源</h3><p>我们在之前已经提到了 Stack Overflow， 但在这里还有其他在线资源可以提供帮助。</p><p>找到一个社区是件好事，如果你试图帮助别人回答他们的问题，也可以自己在上面提出问题，你会得到很多尊重。其他好论坛包括：</p><ul dir="ltr"> <li><a href="https://discourse.mozilla.org/c/mdn">MDN Discourse</a></li> <li><a href="https://www.sitepoint.com/community/">Sitepoint Forums</a></li> <li><a href="https://www.webdeveloper.com/">webdeveloper.com Forums</a></li></ul><p dir="ltr">然而，在 Twitter 或 Facebook 等社交网站上寻找有用的群组也是有意义的。寻找讨论你感兴趣的网络开发主题的小组，并加入其中。在 twitter 上关注那些你知道有影响力、聪明或平易近人的人，他们似乎分享了很多有用的建议。</p><h3 dir="ltr" id="Physical_meetups">线下聚会</h3><p dir="ltr">最后，你应该尝试参加一些线下聚会，认识其他志同道合的人，尤其是那些对初学者友好的人。 <a href="https：//www.meetup.com/find/tech/">meetup.com</a> 是一个很好的地方，可以找到当地的身体聚会，你也可以尝试搜索你当地的媒体/网站上的内容。</p><p dir="ltr">你也可以尝试参加正式的网络会议。虽然这些费用可能很高，但你可以尝试在那里做志愿者，许多会议都提供优惠票，例如学生票或多样性票。</p><h2 dir="ltr" id="See_also">参见</h2><ul dir="ltr"> <li><a href="https://www.coursera.org/learn/learning-how-to-learn">Coursera: Learning to learn</a></li> <li><a href="https://www.freecodecamp.org/">Freecodecamp</a></li> <li><a href="https://www.codecademy.com/">Codecademy</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>macOS 下反汇编 otool 工具</title>
      <link href="/2021/04/18/macOS%20%E4%B8%8B%E5%8F%8D%E6%B1%87%E7%BC%96%20otool%20%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/04/18/macOS%20%E4%B8%8B%E5%8F%8D%E6%B1%87%E7%BC%96%20otool%20%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>csapp 课上 linux 使用的反汇编命令行工具在 macOS 上没有，搜寻了一下发现：</p><p>macOS 下 使用otool 工具</p><p>otool -tv file.c</p><p>这个指令可以反汇编 file.c 文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Js 之混淆与反混淆</title>
      <link href="/2021/03/08/Js-%E4%B9%8B%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
      <url>/2021/03/08/Js-%E4%B9%8B%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>JavaScript混淆是指将原始的JavaScript代码转换为难以读懂和理解的形式，以保护JavaScript代码的知识产权和保密性。常见的混淆技术包括变量名替换、代码压缩、代码加密、字符串混淆等。</p><p>变量名替换是一种常见的混淆技术，它将代码中的变量名替换为无意义的字符，例如将变量名<code>count</code>替换为<code>a</code>。这使得代码难以理解和维护。代码压缩是另一种常见的混淆技术，它通过删除代码中的空格、注释和其他不必要的字符来减小文件大小，使得代码难以读取和理解。</p><p>代码加密是一种将JavaScript代码转换为难以读懂的形式的混淆技术。它使用各种算法对代码进行加密，例如使用AES加密算法对代码进行加密，然后将加密后的代码作为字符串存储在JavaScript文件中。</p><p>字符串混淆是一种将JavaScript代码中的字符串转换为难以读懂的形式的混淆技术。它通常会将字符串拆分为多个小段，然后将每个小段转换为16进制或Unicode编码，以减少字符串的可读性。</p><p>反混淆是指将混淆后的JavaScript代码还原为原始的代码的过程。由于混淆技术通常是可逆的，因此可以使用反混淆技术还原代码。常见的反混淆技术包括手动还原、使用反混淆工具等。</p><p>手动还原是一种将混淆代码还原为原始代码的方法。它通常需要对混淆代码进行分析和破解，以还原出原始的代码。这种方法需要较高的技术水平和耐心。</p><p>反混淆工具是一种使用特定算法和技术的软件工具，可以自动将混淆后的JavaScript代码还原为原始的代码。常见的反混淆工具包括UglifyJS、JSNice、JStillery等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TS 之面向对象的相关特性</title>
      <link href="/2020/05/06/TS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"/>
      <url>/2020/05/06/TS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 cookie 的作用</title>
      <link href="/2020/05/05/%E6%B5%85%E8%B0%88-cookie-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2020/05/05/%E6%B5%85%E8%B0%88-cookie-%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-是什么？"><a href="#cookie-是什么？" class="headerlink" title="cookie 是什么？"></a>cookie 是什么？</h1><h1 id="cookie-怎么用？"><a href="#cookie-怎么用？" class="headerlink" title="cookie 怎么用？"></a>cookie 怎么用？</h1><h1 id="cookie-和-网站登录状态的关系？"><a href="#cookie-和-网站登录状态的关系？" class="headerlink" title="cookie 和 网站登录状态的关系？"></a>cookie 和 网站登录状态的关系？</h1><h2 id="先记录一次探索经历"><a href="#先记录一次探索经历" class="headerlink" title="先记录一次探索经历"></a>先记录一次探索经历</h2><p>先从<strong>浏览器这个角度</strong>看 cookie 值变化 当第一次进入网站页面时，会获取一次 cookie ，并记录在开发者工具中，注意此时是未登录状态：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/8VXHUE.png" alt="8VXHUE"></p><p>当登录成功时，登录状态为真时，此时发现 cookie 没有变化，即使退出登录状态并且关掉当前窗口（浏览器并没有关闭）重新打开页面 cookie 值也没有变化。</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/Lztxqp.png" alt="Lztxqp"></p><p>当把浏览器关闭掉，重新打开网站时，可以发现此时 cookie 值已经变了！</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/ooNEx0.png" alt="ooNEx0"></p><p>从网站服务器的角度出发：&#x2F;&#x2F;TODO</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的步骤发现，从浏览器角度出发时，<strong>当第一次访问网站到完全退出前 cookie 值 和 登录状态没有关系，并且 cookie 值一直保持不变</strong>。<strong>当浏览器完全退出，重新访问网站时，cookie 值才会发生变化</strong>。这个现象刚好印证 <strong>cookies 的属性 session 的特点</strong>。</p><p>从网站服务器的角度出发总结：&#x2F;&#x2F;TODO</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TS 之类型声明</title>
      <link href="/2020/05/04/TS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/"/>
      <url>/2020/05/04/TS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>终端之为 Git 设置代理</title>
      <link href="/2020/05/02/%E7%BB%88%E7%AB%AF%E4%B9%8B%E4%B8%BA-Git-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/2020/05/02/%E7%BB%88%E7%AB%AF%E4%B9%8B%E4%B8%BA-Git-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;&#x2F;todo: 编写</p><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><ol><li><a href="https://segmentfault.com/q/1010000000118837">proxychains 相关</a></li><li><a href="https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1">macos 给 git(github) 设置代理（http&#x2F;ssh）</a></li><li><a href="https://www.zhihu.com/question/27159393/answer/141047266">git clone 一个 github 上的仓库，太慢，经常连接失败，但是 github 官网流畅访问，为什么？ - 汪小九的回答 - 知乎</a></li><li><a href="https://stackoverflow.com/questions/5860888/git-through-proxy">stackoverflow</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 之SVG</title>
      <link href="/2020/04/20/HTML5-%E4%B9%8BSVG/"/>
      <url>/2020/04/20/HTML5-%E4%B9%8BSVG/</url>
      
        <content type="html"><![CDATA[<h1 id="SVG是什么？"><a href="#SVG是什么？" class="headerlink" title="SVG是什么？"></a>SVG是什么？</h1><ul><li>SVG 指的是可伸缩矢量的图形（Scalable Vector Graphics）</li></ul><h1 id="SVG可以用来做什么？"><a href="#SVG可以用来做什么？" class="headerlink" title="SVG可以用来做什么？"></a>SVG可以用来做什么？</h1><ul><li>可以绘制多种路径、框、圆、文本、和图形图像（所有的用于网络的基于矢量的图形）</li></ul><h1 id="SVG有多好？"><a href="#SVG有多好？" class="headerlink" title="SVG有多好？"></a>SVG有多好？</h1><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li></ul><h1 id="如何使用SVG？"><a href="#如何使用SVG？" class="headerlink" title="如何使用SVG？"></a>如何使用SVG？</h1><p>在 HTML5 中，HTML <strong><svg></strong> 元素是 SVG 图形的容器，能够将 SVG 元素直接嵌入 HTML 页面中（支持内联）</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p>在坐标（100，50）处画一个半径为40，填充颜色为红色，描绘轮廓为黑色、宽度为2的一个圆</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;black&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/37VO2k.png" alt="37VO2k"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6 之解构赋值</title>
      <link href="/2020/04/11/ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2020/04/11/ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6 之箭头函数</title>
      <link href="/2020/04/09/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2020/04/09/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学好 JavaScript 的好处</title>
      <link href="/2020/04/06/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
      <url>/2020/04/06/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<p>todo</p><p>参考文章：<a href="https://blog.csdn.net/qq_38861711/article/details/95729429">https://blog.csdn.net/qq_38861711/article/details/95729429</a></p><p>对于前端工作者而言，JavaScript 作为三大前端套件中的一位成员不是没有原因的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之 Promise</title>
      <link href="/2020/04/04/JS%E4%B9%8BPromise/"/>
      <url>/2020/04/04/JS%E4%B9%8BPromise/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-之-Promise"><a href="#JS-之-Promise" class="headerlink" title="JS 之 Promise"></a>JS 之 Promise</h1><p>学习 Promise 是非常重要的，因为它是一种异步编程的重要方式，可以帮助我们更好地处理异步操作，避免回调地狱（Callback Hell）的问题。</p><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>假设我们要实现一个异步的加法函数 <code>addAsync</code>，它接收两个数字作为参数，并异步地计算它们的和，最终返回一个 Promise 对象，用于表示异步操作的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addAsync</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Invalid arguments&#x27;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(a + b);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>new Promise()</code> 创建了一个新的 Promise 对象，并传入一个回调函数，这个回调函数接收两个参数 <code>resolve</code> 和 <code>reject</code>，分别用于表示异步操作成功和失败的情况。</p><p>在回调函数中，我们使用 <code>setTimeout()</code> 来模拟异步计算的过程。如果两个参数都是数字，那么我们就调用 <code>resolve</code> 方法，并将它们的和作为参数传入；如果有一个或两个参数不是数字，那么我们就调用 <code>reject</code> 方法，并传入一个错误对象作为参数。</p><p>接下来，我们可以使用 <code>then()</code> 方法来处理异步操作的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addAsync</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// 输出错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先调用 <code>addAsync()</code> 函数，并传入两个数字参数 2 和 3，得到一个 Promise 对象。然后，我们使用 <code>then()</code> 方法来处理异步操作成功的情况，它接收一个回调函数作为参数，这个回调函数会在异步操作成功后被调用，并传入异步操作的结果。在这个回调函数中，我们将结果输出到控制台。</p><p>如果异步操作失败，那么我们可以使用 <code>catch()</code> 方法来处理失败的情况，它接收一个回调函数作为参数，这个回调函数会在异步操作失败后被调用，并传入一个错误对象作为参数。在这个回调函数中，我们将错误信息输出到控制台。</p><p>总之，这个例子展示了如何使用 Promise 来实现异步操作，并处理异步操作的结果和错误。使用 Promise 可以帮助我们更好地处理异步操作，避免回调地狱的问题，提高代码的可读性和可维护性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之 词法作用域</title>
      <link href="/2020/04/03/JS%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/04/03/JS%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-之-词法作用域"><a href="#JS-之-词法作用域" class="headerlink" title="JS 之 词法作用域"></a>JS 之 词法作用域</h1><p>词法作用域是 JavaScript 中的一个概念，它指的是变量作用域的静态性。在词法作用域中，变量的作用域由它在代码中声明的位置所决定，与代码执行的上下文无关。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><p>在这个例子中，函数 <code>foo</code> 中的 <code>x</code> 引用的是外部的变量 <code>x</code>，因为在词法作用域中，函数 <code>foo</code> 的作用域链包含了它定义时所处的作用域，即全局作用域。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之闭包</title>
      <link href="/2020/04/02/JS%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
      <url>/2020/04/02/JS%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之区分相似的数组方法</title>
      <link href="/2020/04/02/JS%E4%B9%8B%E5%8C%BA%E5%88%86%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/02/JS%E4%B9%8B%E5%8C%BA%E5%88%86%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自V2EX某篇帖子中的回复</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单纯地遍历</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span><br><br><span class="hljs-comment">// 检测数组中是否有元素符合条件</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">some</span><br><br><span class="hljs-comment">// 检测数组中是否所有元素符合条件</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">every</span><br><br><span class="hljs-comment">// 用来将一个列表转换成另一个等长的列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span><br><br><span class="hljs-comment">// 用来将一个列表转换成一个值</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span><br><br><span class="hljs-comment">// 从列表中找出符合条件的一个元素</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span><br><br><span class="hljs-comment">// 从列表中找出符合条件的若干元素</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">filter</span><br><br><span class="hljs-comment">// 拍平列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flat</span><br><br><span class="hljs-comment">// map 和 flat 的结合，适合用来将一个列表转换成另一个不等长的列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flatMap</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My HTML &amp; CSS Notebook</title>
      <link href="/2020/04/01/My-CSS%20&amp;%20HTML-Notebook/"/>
      <url>/2020/04/01/My-CSS%20&amp;%20HTML-Notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="行内元素与块级元素区别"><a href="#行内元素与块级元素区别" class="headerlink" title="行内元素与块级元素区别"></a>行内元素与块级元素区别</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%AF%B9%E6%AF%94">MDN</a></p><ul><li><p>内容</p><p>一般情况下，行内元素只能包含数据和其他行内元素。</p><p>而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li><li><p>格式</p><p>默认情况下，<strong>行内元素不会以新行开始，而块级元素会新起一行。</strong></p></li></ul><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p>特点：</p><ol><li>当块内元素转化为行内块元素时，如果没有给特点的宽度或者高度，则宽和高默认是元素内容的大小。</li></ol><p>应用：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上边三个div盒子默认按照标准流布局排放，即从上到下的方式，此时<strong>如果我想要让它们在一行显示，像行内元素一样，就可以在样式中设置display属性，如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123; <br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: gray;<br>  <span class="hljs-comment">/*将块元素转化成行内块元素实现一行排放盒子，使用display属性*/</span><br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，<strong>这三个div盒子就不是原来的块内元素，属性行内的块元素</strong></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级（specificity）"><a href="#选择器优先级（specificity）" class="headerlink" title="选择器优先级（specificity）"></a>选择器优先级（specificity）</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F">MDN 链接</a><br>CSS 选择器权重表：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/gRdDjc.png" alt="gRdDjc"></p><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>页面布局要学习三大核心，<strong>盒子模型</strong>，<strong>浮动</strong>和<strong>定位</strong>。学习好盒子模型能非常好的帮助我们布局页面</p><p>看透网页布局的本质</p><p>网页布局过程：</p><p>1。先准备好相关的网页元素，网页元素基本都是盒子Box。</p><p>2。利用CSS设置好盒子样式，然后摆放到相应位置。</p><p>3。往盒子里面装内容。</p><p>网页布局的核心本质：就是利用CSS摆盒子。</p><ul><li>两条应用准则（重要）：</li></ul><ol><li><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</strong></li><li><strong>网页布局第二准则：先设置盒子大小，之后设置盒子的位置</strong></li></ol><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/DA7bFP.png" alt="DA7bFP"></p><h4 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border#syntax">三大属性 - border-width, border-color, border-sytle</a></p><p>边框复合（简写）写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/* 没有顺序 */</span><br></code></pre></td></tr></table></figure><p>边框分开写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/*只设定上边框，其余同理 */</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse">额外属性 ：border-collapse - 处理表格边框是否合并属性</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-comment">/* 合并（collapsed ）模式下，表示相邻边框合并在一起(共享边框) */</span><br></code></pre></td></tr></table></figure><p><strong>边框会影响盒子的实际大小；</strong></p><h4 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h4><p>当盒子指定了宽度和高度时，<strong>内边距会影响盒子的实际大小；如：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为240px，高度为240px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打开开发者面板工具，检查盒子大小会发现盒子的宽度为240px，高度为240px。</p><p>如果保证盒子为200px，跟效果图大小保特一致，<strong>则让width&#x2F;height减去多出来的内边距大小即可</strong>，将上面的写法改成下面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为200px，高度为200px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: aqua;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: pink;<br>      <span class="hljs-comment">/* 这里p元素继承div标签的宽和高，单独对p元素设置内边距不会撑大外面包裹的div盒子 */</span><br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><p>外边距合并问题？TODO</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="1-2-标准流（普通流-x2F-文档流）"><a href="#1-2-标准流（普通流-x2F-文档流）" class="headerlink" title="1.2 标准流（普通流&#x2F;文档流）"></a>1.2 标准流（普通流&#x2F;文档流）</h4><p><strong>所谓的标准流：就是标签按照规定好默认方式排列</strong></p><ol><li>块级元素会独占一行，从上到下顺序排序。</li></ol><ul><li>常用元素：div、hr、p、h1-h6、ul、ol、dl、form、table</li></ul><ol start="2"><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li></ol><ul><li>常用元素：span、a、i、em等</li></ul><p>以上都是标准流布局，我们前面学习的就是标准流，<strong>标准流就是最基本的布局方式。</strong></p><h4 id="1-3-为什么需要浮动"><a href="#1-3-为什么需要浮动" class="headerlink" title="1.3 为什么需要浮动"></a>1.3 为什么需要浮动</h4><ol><li><p>虽然块级元素能通过设置display转化成行内块级元素，达到多个块级元素（盒子div）水平排列成一行显示（排放）的目的，<strong>但是每个元素（盒子）之间的距离（缝隙）很难控制</strong></p></li><li><p><strong>在一个大盒子中存放着两个盒子，无法通过标准流的方式使得两个盒子左右对齐。</strong></p></li></ol><p>总结：有很多的布局效果，标准流没有办法完成，此时就河以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示。</p><p><strong>网页布局第一准则</strong>：<strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</strong></p><h4 id="1-4-什么是浮动"><a href="#1-4-什么是浮动" class="headerlink" title="1.4 什么是浮动"></a>1.4 什么是浮动</h4><p><strong>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">float</span>: 属性值; &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h4 id="1-5-浮动的特性（重难点）"><a href="#1-5-浮动的特性（重难点）" class="headerlink" title="1.5 浮动的特性（重难点）"></a>1.5 浮动的特性（重难点）</h4><ol><li>设置了浮动(f1oat)的元素最重要特性：</li></ol><ul><li><p>脱离标准普通流的控制（浮）移动到指定位置（动），（俗称<strong>脱标</strong>)</p></li><li><p>浮动的盒子不再保留原先的位置</p></li></ul><ol start="2"><li><p>如果多个盒子都设置了浮动，则它们会按照属性值<strong>一行内显示并且顶端对济排列</strong>。注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p></li><li><p>浮动元素会具有行内块级元素的特征。</p><p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有<strong>行内块元素</strong>相似的特性。</p></li></ol><ul><li><p>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添浮动后，它的大小根据内容来决定</p></li><li><p>浮动的盒子中间是没有缝隙的，是紧挨着一起的</p></li><li><p>行内元素同理</p></li></ul><h4 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置，我们网页布局一般采取的策略是：</p><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准侧</strong></p><h4 id="1-7-浮动布局注意点"><a href="#1-7-浮动布局注意点" class="headerlink" title="1.7 浮动布局注意点"></a>1.7 浮动布局注意点</h4><ol><li>浮动和标准流的父盒子搭配。</li></ol><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</strong></p><ol start="2"><li>一个元素浮动了，理论上其余的兄弟元素也要浮动。</li></ol><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。</p><p><strong>浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流</strong></p><h4 id="1-8-为什么需要清除浮动"><a href="#1-8-为什么需要清除浮动" class="headerlink" title="1.8 为什么需要清除浮动"></a>1.8 为什么需要清除浮动</h4><p>我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点都是有高度的。</p><p>但是，所有的父盒子都必须要有高度吗？</p><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。</p><p><strong>我的理解是在实际的网页布局中，父盒子中被设置浮动的子盒子的数量和高度是不确定的，为了避免子盒子溢出父盒子，所以父盒子的高度不会写死（不会设置），但当父盒子没有设置高度时，里面浮动的子盒子会脱标，不会自动撑开父盒子的高度，会导致网页布局结构混乱，这时就需要清除浮动</strong></p><h4 id="1-9-清除浮动的本质"><a href="#1-9-清除浮动的本质" class="headerlink" title="1.9 清除浮动的本质"></a>1.9 清除浮动的本质</h4><ul><li><p>清除浮动的本质是清除浮动元素造成的影响</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</p></li></ul><h4 id="2-清除浮动方法"><a href="#2-清除浮动方法" class="headerlink" title="2 清除浮动方法"></a>2 清除浮动方法</h4><p><strong>清除浮动的策略是：闭合浮动</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">clear</span>: both; &#125;<br></code></pre></td></tr></table></figure><h5 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h5><p>颜外标签法也称为隔墙法，是W3C推荐的做法。</p><p>额外标签法会在浮动元素末尾添加一个空的标签。例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">clear</span>：both&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>或者其他标签 (如<br/>等)。</p><p>优点：通俗易懂，书写方便</p><p>·缺点：添加许多无意义的标签，结构化较差</p><p>注意：要求这个新的空标签必须是块级元素。</p><p><strong>实际工作可能会遇到，但是不常用</strong></p><h5 id="父级添加overflow属性"><a href="#父级添加overflow属性" class="headerlink" title="父级添加overflow属性"></a>父级添加overflow属性</h5><p>可以给父级添加overflow属性，将其属性值设置为<strong>hidden</strong>、auto或scroll。</p><p>子不教父之过，注意是给父元素添加代码</p><ul><li><p>优点：代码简洁</p></li><li><p>缺点：无法显示溢出的部分</p></li></ul><h5 id="父级添加after伪元素（推荐）"><a href="#父级添加after伪元素（推荐）" class="headerlink" title="父级添加after伪元素（推荐）"></a>父级添加after伪元素（推荐）</h5><p>:after 方式是额外标签法的升级版。</p><p>找到父级元素，然后添加一个类名为 clearFix，随后添加对应css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：没有增加标签，结构更简单</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：百度、淘宝网、网易等</p></li></ul><h5 id="父级添加双伪元素（推荐）"><a href="#父级添加双伪元素（推荐）" class="headerlink" title="父级添加双伪元素（推荐）"></a>父级添加双伪元素（推荐）</h5><p>也是给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 清除浮动 */</span><br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">::before</span>,<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：代码更简洁</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：小米、腾讯等</p></li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="为什么需要定位"><a href="#为什么需要定位" class="headerlink" title="为什么需要定位"></a>为什么需要定位</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/8R1L9q.png" alt="8R1L9q"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/K4p6U3.png" alt="K4p6U3"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/U9itev.png" alt="U9itev"></p><h4 id="定位组成"><a href="#定位组成" class="headerlink" title="定位组成"></a>定位组成</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/cuPpYa.png" alt="cuPpYa"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/bL9n0j.png" alt="bL9n0j"></p><h5 id="静态定位（了解）"><a href="#静态定位（了解）" class="headerlink" title="静态定位（了解）"></a>静态定位（了解）</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/tcZSju.png" alt="tcZSju"></p><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/0hDzkj.png" alt="0hDzkj"></p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/nCNkSc.png" alt="nCNkSc"></p><p>绝对定位的特点：（务必记住）</p><ol><li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位(Document文档)。</li><li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li><li>绝对定位不再占有原先的位置。（脱标）</li></ol><h6 id="1-6-子绝父相的由来"><a href="#1-6-子绝父相的由来" class="headerlink" title="1.6 子绝父相的由来"></a>1.6 子绝父相的由来</h6><p>弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。</p><p>这个“子绝父相”太重要了，是我们学习定位的口决，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。</p><p>① 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p><p>② 父盒子需要加定位限制子盒子在父盒子内显示。</p><p>③ 父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p><p>这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。</p><p>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</p><p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。</p><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><h6 id="1-7-固定定位-fixed（重要）"><a href="#1-7-固定定位-fixed（重要）" class="headerlink" title="1.7 固定定位 fixed（重要）"></a>1.7 固定定位 fixed（重要）</h6><p>固定定位是元素<strong>固定于浏览器的可视化的位置</strong>。主要使用场景：可以在浏览器页面滚动时元素的位置不会变</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: fixed;<br></code></pre></td></tr></table></figure><p>固定定位的特点：（务必记住）</p><ol><li>以浏览器的可视窗口为参照点移动元素</li></ol><ul><li>跟父元素没有任何关系</li><li>不随滚动条移动</li></ul><ol start="2"><li>固定定位不在占有原先的位置</li></ol><p>固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。</p><p><strong>固定定位小技巧：固定在版心右侧位置</strong></p><p>小算法：</p><ol><li>让固定定位的盒子left：50px，走到浏览器可视区（也可以看做版心）的一半位置。</li><li>让固定定位的盒子margin-left：版心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。</li></ol><h5 id="粘性定位（了解）"><a href="#粘性定位（了解）" class="headerlink" title="粘性定位（了解）"></a>粘性定位（了解）</h5><p><strong>粘性定位</strong>可以被人们认为是相对定位和固定定位的混合体。Sticky 粘性的</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">position</span>: sticky; <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;&#125;<br></code></pre></td></tr></table></figure><p>粘性定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素（固定定位的特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li>必须添加 top、left、right、bottom 其中一个才有效</li></ol><p>跟页面滚动搭配使用。<strong>兼容性较差，IE不支持。所以大多数都是通过 JS 来控制实现粘性定位。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一定要记住<strong>相对定位、绝对定位、固定定位</strong>各两个大的特点：</p><ol><li>是否占有位置（脱标否）2.以谁为基准点移动位置。</li><li>学习定位重点学会子相父绝。</li></ol><h4 id="定位的叠放次序-z-index"><a href="#定位的叠放次序-z-index" class="headerlink" title="定位的叠放次序 z-index"></a>定位的叠放次序 z-index</h4><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序（z轴）</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>数值可以是正整数、负整数或0，默认时auto，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有z-index属性</li></ul><h4 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h4><h5 id="1-绝对定位的盒子居中"><a href="#1-绝对定位的盒子居中" class="headerlink" title="1. 绝对定位的盒子居中"></a>1. 绝对定位的盒子居中</h5><p>加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过以下计算方式实现水平和垂直居中。</p><p>水平居中方法：</p><p>1⃣️ left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。</p><p>2⃣️ margin-left: -100px; 让盒子向左移动自身宽度的一半（注意负号代表往左）。</p><p>垂直居中方法：</p><p>1⃣️ top: 50%; 让盒子的顶部移动到父级元素的垂直位置。</p><p>2⃣️ margin-top: -100px; 让盒子向上移动自身高度的一半（注意负号代表往左）。</p><h5 id="2-定位的特殊性"><a href="#2-定位的特殊性" class="headerlink" title="2. 定位的特殊性"></a>2. 定位的特殊性</h5><p>绝对定位和固定定位也和浮动类似。</p><ol><li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度</li><li>块内元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li></ol><h5 id="3-脱标的盒子不会触发外边距塌陷"><a href="#3-脱标的盒子不会触发外边距塌陷" class="headerlink" title="3. 脱标的盒子不会触发外边距塌陷"></a>3. 脱标的盒子不会触发外边距塌陷</h5><p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p><h5 id="绝对定位（固定定位）会完全压住盒子"><a href="#绝对定位（固定定位）会完全压住盒子" class="headerlink" title="绝对定位（固定定位）会完全压住盒子"></a>绝对定位（固定定位）会完全压住盒子</h5><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p><p>但是绝对定位（固定定位）会压住下面标准流所有的内容。</p><p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。文字会围绕浮动元素</p><h3 id="网页布局总结"><a href="#网页布局总结" class="headerlink" title="网页布局总结"></a>网页布局总结</h3><p>通过盒子模型，清楚知道大部分html标签是一个盒子。</p><p>通过CSS浮动、定位可以让每个盒子排列成为网页。</p><p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p><ol><li>标准流</li></ol><p>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。</p><ol start="2"><li>浮动</li></ol><p>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。</p><ol start="3"><li>定位</li></ol><p>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法和题库练习笔记</title>
      <link href="/2020/03/10/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/10/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找（binary-search）"><a href="#二分查找（binary-search）" class="headerlink" title="二分查找（binary search）"></a>二分查找（binary search）</h2><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳</p></blockquote><blockquote><p>当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之90的学生在花费数小时后还是无法给出正确的解答，<strong>主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。</strong>1988年开展的一项研究显示，20本教科书里只有5本正确实现了二分搜索。不仅如此，本特利自己1986年出版的《编程珠玑》一书中的二分搜索算法<strong>存在整数溢出的问题</strong>，二十多年来无人发现。Java语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。 ——摘自维基百科</p></blockquote><p>视频讲解：<a href="https://youtu.be/CMweVF2iSyQ">二分查找法</a><br>时间复杂度：O(logn)<br>伪代码及方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/006DDiezgy1h08n6lcku4j325012y4a8.jpg" alt="006DDiezgy1h08n6lcku4j325012y4a8"><br>力扣相关题目：<a href="https://leetcode-cn.com/problems/binary-search/">力扣算法题目704</a></p><h2 id="回溯法（backtracking）"><a href="#回溯法（backtracking）" class="headerlink" title="回溯法（backtracking）"></a>回溯法（backtracking）</h2><p>待看做笔记： <a href="https://youtu.be/nrHTtjkYEyQ">使用C++讲解</a><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/01.39.29.png" alt="01.39.29"></p><h2 id="双指针（Two-pointer）"><a href="#双指针（Two-pointer）" class="headerlink" title="双指针（Two pointer）"></a>双指针（Two pointer）</h2><p>创建两个指针分别指向数组的首、末位置。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//test.c</span><br><span class="hljs-comment">//利用双指针判断字符的对称问题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//设置一个布尔值 symmetry默认为true</span><br><span class="hljs-type">bool</span> symmetry = <span class="hljs-literal">true</span>;<br><span class="hljs-type">char</span> str[]= <span class="hljs-string">&quot;BaeAB&quot;</span>; <span class="hljs-comment">//很明显,该字符串不是对称的</span><br><span class="hljs-comment">//遍历字符串数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str) / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-comment">//如果对称的两个位置上的数值不相等,则返回false</span><br><span class="hljs-keyword">if</span> (str[i] != str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c != %c\n&quot;</span>,str[i],str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]);<br>symmetry = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (symmetry) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串为对称的\n&quot;</span>,str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串不是对称的\n&quot;</span>,str);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>a != A<br>BaeAB:该字符串不是对称的<br></code></pre></td></tr></table></figure><p>在循环体for中, 当循环第一次时, <code>str[i]</code>和<code>str[strlen(str)-1-i]</code>分别指向<code>str</code>数组的首位和末位元素(这里是指结束符“\0”的前一位元素)。如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/J49VDc.png" alt="J49VDc"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树(Binary-Tree)</title>
      <link href="/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/"/>
      <url>/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2><p>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</p><h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><p>树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84">树结构</a>。通常分支被称作“左子树”或“右子树”。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>所有叶节点都在最底层的完全二叉树；</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>英语：(Binary Search Tree)：也称二叉搜索树、有序二叉树；</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinToGo - 可以随身携带的系统U盘</title>
      <link href="/2020/02/28/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/"/>
      <url>/2020/02/28/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="折腾原因"><a href="#折腾原因" class="headerlink" title="折腾原因"></a>折腾原因</h2><p>最近几年一直使用 macOS，调试一些页面需要在 Windows 系统上操作（实际上是为了在 Win 打游戏：：））对了，就是 Java 期末考试需要用的软件只在 win 平台。。。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>我的mbp已经算是比较老的14年中装载4代i5的设备，对照以下这个图是支持制作USB系统盘启动Windows的。<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/1649086686847.jpg" alt="1649086686847"></p><h2 id="挑选适合做系统的U盘"><a href="#挑选适合做系统的U盘" class="headerlink" title="挑选适合做系统的U盘"></a>挑选适合做系统的U盘</h2><p>从<a href="https://bbs.luobotou.org/">萝卜头网</a>上了解到WTG对U盘性能有着一定的要求，这个网站有推荐购买的U盘（对于我来说太贵），这里特别得亏有大佬在上面分享了一些可供选择的比较特殊的U盘。这里对比一下我现有的普通闪迪U盘和以手机硬盘为颗粒的UFS盘之间的4k读写速度，特别是4k写入小文件的速度，可以明显的看到差距。<br>普通U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/%E9%97%AA%E8%BF%AA%E6%99%AE%E9%80%9AU'%E7%9B%98.png" alt="闪迪普通U&#39;盘"></p><p>适合做WTG的U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/sm3833_ufs_U%E7%9B%98_4k%E5%86%99%E5%85%A5%E6%B5%8B%E8%AF%95.png" alt="sm3833_ufs_U盘_4k写入测试"></p><h2 id="使用工具制作启动U盘"><a href="#使用工具制作启动U盘" class="headerlink" title="使用工具制作启动U盘"></a>使用工具制作启动U盘</h2><h3 id="mac（inter芯片）启动方式"><a href="#mac（inter芯片）启动方式" class="headerlink" title="mac（inter芯片）启动方式"></a>mac（inter芯片）启动方式</h3><p>开机长按<code>option</code>键，然后选中<strong>EFI Boot</strong>这个磁盘，直接按<code>Enter</code>键</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/ogTdkD.png" alt="ogTdkD"></p><h3 id="Windows-启动方式"><a href="#Windows-启动方式" class="headerlink" title="Windows 启动方式"></a>Windows 启动方式</h3><p>开机按画面提示按<code>U盘启动选择快捷键</code>选择<strong>EFI Boot</strong>这个磁盘，然后按<code>Enter</code></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地项目上传到 GitHub 托管</title>
      <link href="/2020/02/26/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/"/>
      <url>/2020/02/26/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Github基础使用"><a href="#Github基础使用" class="headerlink" title="Github基础使用"></a>Github基础使用</h1><h2 id="将本地仓库关联到GitHub"><a href="#将本地仓库关联到GitHub" class="headerlink" title="将本地仓库关联到GitHub"></a>将本地仓库关联到GitHub</h2><h3 id="初始化本地仓库并提交仓库文件"><a href="#初始化本地仓库并提交仓库文件" class="headerlink" title="初始化本地仓库并提交仓库文件"></a>初始化本地仓库并提交仓库文件</h3><p>要先确保操作系统已经安装了<strong>Git</strong>，之后进入本地仓库的根目录，鼠标右键选择<code>Git Bash Here</code>，接着输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><p>出现以下回应且在根目录下生成了一个隐藏的文件夹<code>.git</code><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/hHrssB.png" alt="hHrssB"><br>此时，如图所示它是将<code>master</code>作为初始分支的名称，这里为了跟之后在 github 上默认创建的分支名一致，可以改名为<code>main</code>，输入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-m <span class="hljs-string">&quot;main&quot;</span><br></code></pre></td></tr></table></figure><p>此时仓库里的文件还没有被追踪，输入</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> . <span class="hljs-comment">//将仓库里的所有文件进行追踪</span><br></code></pre></td></tr></table></figure><p>提交一次快照，输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git commit -m <span class="hljs-string">&quot;Started Course&quot;</span><span class="hljs-regexp">//</span><span class="hljs-string">&quot; &quot;</span>里可以自定义快照的名字<br></code></pre></td></tr></table></figure><h3 id="在GitHub上创建一个项目"><a href="#在GitHub上创建一个项目" class="headerlink" title="在GitHub上创建一个项目"></a>在GitHub上创建一个项目</h3><p>GitHub主页右上角点击new repository<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9y9tnkcj20al06bab3.jpg"><br>输入信息，<strong>记住勾选Initialize this repository with a REAdME</strong></p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9yw1qg5j20o10hhgn0.jpg"></p><p>创建后，复制项目的地址</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9z9g1caj20sf0eujsx.jpg"></p><p>回到本地仓库，使用命令，<strong>并在命令后加上你的GitHub项目的地址</strong>，也就是刚才复制的内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git remote <span class="hljs-built_in">add</span> origin<br></code></pre></td></tr></table></figure><p>这一步是本地和远程服务器建立联系的一步。执行成功后不会显示任何结果：<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa001gerj20fn021q37.jpg"></p><p>到这里，你已经成功了一半了。</p><h3 id="向远程仓库提交代码"><a href="#向远程仓库提交代码" class="headerlink" title="向远程仓库提交代码"></a>向远程仓库提交代码</h3><p>第一次向远程提交代码时得先将远程的README.md 文件(如果有)同步过来，实行一下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git pull <span class="hljs-comment">--rebase origin master</span><br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa0n36itj20db02xq38.jpg"></p><p>查看本地仓库是否出现README.md文件，如有，则表示拉取则成功。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1awhwuj20gp032glw.jpg"></p><p>接着，将进行第一次向远程同步本地仓库的内容，输入：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1pgcvpj20dj0400t6.jpg"><br><strong>注意</strong>：过程中可能会出现一个登陆GitHub帐户的窗口，输入你的账户及密码就可以了。</p><p>最后回到GitHub主页查看是否同步即可。</p><h2 id="文件变动操作"><a href="#文件变动操作" class="headerlink" title="文件变动操作"></a>文件变动操作</h2><h3 id="本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？"><a href="#本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？" class="headerlink" title="本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？"></a>本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？</h3><p>比如我在本地有一个名为CodingAtSchool的仓库，仓库里有C语言作业文件夹和一个README文件如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa29yeq8j20i705hdgm.jpg"><br>我今天用操作鼠标做了大量对C语言目录下的改动，之后进到仓库根目录下，右键Git Bash Here，输入git status，查看仓库状态。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2m62lwj20ko0d0k3y.jpg"><br>oops，大量的红色数字什么鬼，这时千万别慌！如果本地仓库中含文件名为中文名称时，命令窗中提示的信息是无法显示中文的，它会把中文变成一串串数字。这时仔细观察一下，我所做的全部变动都是在C语言作业这个目录下完成的，具体变动是删除了大量文件和增加了一些文件。</p><p>第一步，分别执行以下两句命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> <span class="hljs-literal">-r</span> C语言作业/<br><span class="hljs-variable">$</span> git add C语言作业/<br></code></pre></td></tr></table></figure><p>再一次查看状态 git status，发现一切的修改都已经提交到暂存区了<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2vktcrj20kk0cwqfy.jpg"></p><p>第二步，提交修改</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;我的修改&#x27;</span><br></code></pre></td></tr></table></figure><p>第三步，推送到远程仓库</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集常用 Git 指令及用法</title>
      <link href="/2020/02/26/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
      <url>/2020/02/26/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code> 它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-meta"># 编辑Git配置文件</span><br>$ git config -e [--<span class="hljs-keyword">global</span>]<br><br><span class="hljs-meta"># 设置提交代码时的用户信息</span><br>$ git config [--<span class="hljs-keyword">global</span>] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--<span class="hljs-keyword">global</span>] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br><br><span class="hljs-meta"># 配置使用初始分支名 （本地默认为 master, GitHub 为 main）</span><br>$ git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">init</span>.defaultBranch &lt;名称&gt;<br></code></pre></td></tr></table></figure><h2 id="三、增加-x2F-删除文件"><a href="#三、增加-x2F-删除文件" class="headerlink" title="三、增加&#x2F;删除文件"></a>三、增加&#x2F;删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用场景：如果想要忽略已检入的文件，则必须在添加忽略该文件的规则之前取消跟踪它。以下操纵命令为从终端取消跟踪文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="六、撤销"><a href="#六、撤销" class="headerlink" title="六、撤销"></a>六、撤销</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br></code></pre></td></tr></table></figure><h1 id="补充扩展"><a href="#补充扩展" class="headerlink" title="补充扩展"></a>补充扩展</h1><h2 id="快速开启一个新项目"><a href="#快速开启一个新项目" class="headerlink" title="快速开启一个新项目"></a>快速开启一个新项目</h2><p>使用<code>degit</code>命令，这个命令跟<code>git clone</code>很相似，区别在于下载一个<code>repo</code>的时候是不带整个项目的<code>commit</code>信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-number">1</span> <span class="hljs-comment"># 安装 degit</span><br>npm <span class="hljs-keyword">install</span> -g degit<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-number">2</span> <span class="hljs-comment"># 下载一个项目但不带它的整个代码历史</span><br><span class="hljs-variable">$ </span>degit [url]<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 操纵速查表</title>
      <link href="/2020/02/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2020/02/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="普通模式下基本命令"><a href="#普通模式下基本命令" class="headerlink" title="普通模式下基本命令"></a>普通模式下基本命令</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除光标处字符</td></tr><tr><td><code>dd</code></td><td>删除一个词</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td><code>/search_text</code></td><td>检索文档，在文档后面的部分搜索 search_text</td></tr><tr><td><code>?search_text</code></td><td>检索文档，在文档前面的部分搜索 search_text</td></tr><tr><td><code>n</code></td><td>移动到后一个检索结果</td></tr><tr><td><code>N</code></td><td>移动到前一个检索结果</td></tr><tr><td></td><td></td></tr><tr><td><code>u</code></td><td>撤销最后的操作</td></tr><tr><td><code>Ctrl + r</code></td><td>重做最后撤销的操作</td></tr><tr><td></td><td></td></tr><tr><td><code>dd</code></td><td>删除当前行</td></tr><tr><td><code>d0</code></td><td>删除到行首</td></tr><tr><td><code>d$</code></td><td>删除到行末</td></tr><tr><td></td><td></td></tr><tr><td><code>h</code></td><td>光标向左移动一个字符</td></tr><tr><td><code>j</code> 或 <code>Ctrl + J</code></td><td>光标向下移动一行</td></tr><tr><td><code>k</code> 或 <code>Ctrl + P</code></td><td>光标向上移动一行</td></tr><tr><td><code>l</code></td><td>光标向右移动一个字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="进阶之复制和粘贴"><a href="#进阶之复制和粘贴" class="headerlink" title="进阶之复制和粘贴"></a>进阶之复制和粘贴</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制当前行至存储缓冲区</td></tr><tr><td><code>[&quot;x]yy</code></td><td>复制当前行至寄存器 x</td></tr><tr><td><code>p</code>（小写）</td><td>在当前行之后粘贴存储缓冲区中的内容</td></tr><tr><td><code>P</code>（大写）</td><td>在当前行之前粘贴存储缓冲区中的内容</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 下的常用终端（terminal）命令总结</title>
      <link href="/2020/02/24/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/24/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><strong>简介：</strong></p><p><code>ls</code> 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一。</p><p>在终端里输入<code>ls</code>就可以查看文件和文件夹，但隐藏的文件就无法查看，使用<code>ls -a</code>即可。</p><p>“.” 代表当前目录，“..” 代表上一级目录，以 “.” 开头的文件为隐藏文件，需要用 -a 参数才能显示。</p><p><strong>ls常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><p><strong>ls 匹配通配符：</strong></p><p>与 DOS 下的文件操作类似，在 Unix&#x2F;Linux 系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>文件代表文件名中所有字符</td></tr><tr><td>ls te*</td><td>查找以 <code>te</code> 开头的文件</td></tr><tr><td>ls *html</td><td>查找结尾为 <code>html</code> 的文件</td></tr><tr><td>？</td><td>代表文件名中任意一个字符</td></tr><tr><td>ls ?.c</td><td>只找第一个字符任意，后缀为 <code>.c</code> 的文件</td></tr><tr><td>ls a.?</td><td>只找只有 3 个字符，前 2 字符为 <code>a.</code> ，最后一个字符任意的文件</td></tr><tr><td>[]</td><td><code>&quot;[”</code> 和 <code>“]”</code> 将字符组括起来，表示可以匹配字符组中的任意一个。<code>“-”</code> 用于表示字符范围。</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr><tr><td>ls [a-f]*</td><td>找到从 a 到 f 范围内的的任意一个字符开头的文件</td></tr><tr><td>ls a-f</td><td>查找文件名为 a-f 的文件,当 <code>“-”</code> 处于方括号之外失去通配符的作用</td></tr><tr><td>\</td><td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。<code>“?”</code> 和 <code>“*”</code> 处于方括号内时不用使用转义字符就失去通配符的作用。</td></tr><tr><td>ls *a</td><td>查找文件名为 <code>*a</code> 的文件</td></tr></tbody></table><h2 id="创建文件夹-x2F-目录"><a href="#创建文件夹-x2F-目录" class="headerlink" title="创建文件夹&#x2F;目录"></a>创建文件夹&#x2F;目录</h2><p>命令：<code>mkdir</code><br>使用说明：输入命令随后空格再输入目录名即可。<br>案例：创建一个 test 文件夹&#x2F;目录则对应命令就是<code>mkdir test</code></p><h2 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h2><p><code>cd</code> 命令进入目录比如要进入 test 目录则就是<code>cd test</code></p><h2 id="返回上一级目录"><a href="#返回上一级目录" class="headerlink" title="返回上一级目录"></a>返回上一级目录</h2><p>命令：<code>cd..</code></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>命令: <code>touch</code><br>笔者感觉这个命令还是挺靠谱的。Mac如果不用第三方工具（sublime等）是无法可视化创建一个txt文件。而用这个命令即可创建。<br>示例（创建一个test为名的 txt 文件）：<code>touch test.txt</code></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>命令：<code>cp</code><br>案例（拷贝一个 test.txt 文件并重新命名为test2.txt）：<code>cp test.txt test2.txt</code></p><h2 id="重命名或者移动文件"><a href="#重命名或者移动文件" class="headerlink" title="重命名或者移动文件"></a>重命名或者移动文件</h2><p>命令:   <code>mv</code><br>比如  (将一个 mountain.c  的 C 语言程序文件名字改成 mt.c )： <code>mv mountain.c mt.c</code></p><p>或者将 mountain.c 文件剪切到 code 文件夹下：<code>mv mountain.c code/</code></p><h3 id="批量修改文件名"><a href="#批量修改文件名" class="headerlink" title="批量修改文件名"></a>批量修改文件名</h3><p>例子：目录下有多个后缀为<code> .cpp</code> 的文件，我想让它们全部保留文件名的情况下修改成<code> .c</code> 后缀，这时可以结合 mv 命令和 shell 编程写个 for 循环，遍历每个文件然后依次更改。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">for i in *.cpp;do mv &quot;$i&quot; &quot;$&#123;i%.cpp&#125;.c&quot;;done<br></code></pre></td></tr></table></figure><p>模版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 把 xxx 换成要修改的文件名的后缀，yyy 换成替换输出的后缀即可。<br>for i in *.xxx;do mv &quot;$i&quot; &quot;$&#123;i%.xxx&#125;.yyy&quot;;done<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令：<code>find</code><br>案例（查找当前目录下所有的 txt 文件）：<code>find *.txt</code></p><p><strong>常用用法：</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>find .&#x2F; -name test.sh</td><td>查找当前目录下所有名为test.sh的文件</td></tr><tr><td>find .&#x2F; -name ‘*.sh’</td><td>查找当前目录下所有后缀为.sh的文件</td></tr><tr><td>find .&#x2F; -name “[A-Z]*”</td><td>查找当前目录下所有以大写字母开头的文件</td></tr><tr><td>find &#x2F;tmp -size 2M</td><td>查找在&#x2F;tmp 目录下等于2M的文件</td></tr><tr><td>find &#x2F;tmp -size +2M</td><td>查找在&#x2F;tmp 目录下大于2M的文件</td></tr><tr><td>find &#x2F;tmp -size -2M</td><td>查找在&#x2F;tmp 目录下小于2M的文件</td></tr><tr><td>find .&#x2F; -size +4k -size -5M</td><td>查找当前目录下大于4k，小于5M的文件</td></tr><tr><td>find .&#x2F; -perm 0777</td><td>查找当前目录下权限为 777 的文件或目录</td></tr></tbody></table><h2 id="显示当前的目录"><a href="#显示当前的目录" class="headerlink" title="显示当前的目录"></a>显示当前的目录</h2><p>命令：<code>pwd</code></p><h2 id="打开成可视化的文件夹"><a href="#打开成可视化的文件夹" class="headerlink" title="打开成可视化的文件夹"></a>打开成可视化的文件夹</h2><p>命令：<code>open</code><br>说明：如果是 <code>open</code>,则是打开当前命令里的目录，如果要打开指定的文件夹或者文件则格式为open要打开的路径即可。</p><h2 id="删除目录（空目录）"><a href="#删除目录（空目录）" class="headerlink" title="删除目录（空目录）"></a>删除目录（空目录）</h2><p>命令：<code>rmdir</code><br>案例：<code>rmdir test</code>（rmdir命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除目录（非空或者空目录都可以删除）推荐使用"><a href="#删除目录（非空或者空目录都可以删除）推荐使用" class="headerlink" title="删除目录（非空或者空目录都可以删除）推荐使用"></a>删除目录（非空或者空目录都可以删除）推荐使用</h2><p>命令： <code>rm -rf</code><br>案例：rm -rf test（rm -rf 命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>命令：<code>rm</code><br>案例（删除一个 test.txt 文件）：<code>rm test.txt</code><br>或者（删除所有后缀为 <code>.ttf</code> 的文件）：<code>rm *.ttf</code><br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u>，为了防止文件误删，可以在 <code>rm</code> 后使用 <code>-i</code> 参数以逐个确认要删除的文件。</p><p><strong><code>rm</code> 常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>以进行交互式方式执行</td></tr><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><h2 id="Terminal-光标移动快捷键"><a href="#Terminal-光标移动快捷键" class="headerlink" title="Terminal 光标移动快捷键"></a>Terminal 光标移动快捷键</h2><ul><li>将光标移动到行首：<code>control + a</code></li><li>将光标移动到行尾：<code>control + e</code></li><li>清除屏幕：<code>control + l</code>, 相当于手动输入<code>clear</code>并回车</li><li>搜索以前使用命令：<code>control + r</code></li><li>清除当前行：<code>control + u</code></li><li>清除至当前行尾：<code>control + k</code></li><li>单词为单位移动：<code>option + 方向键</code></li><li>光标向前 (Forward) 移动一个字符位置：<code>Ctrl + f</code></li><li>光标往回(Backward)移动一个字符位置：<code>Ctrl + b</code></li><li>删除一个字符，相当于通常的 Delete 键（命令行若无所有字符，则相当于 exit；处理多行标准输入时也表示eof：<code>Ctrl + d</code></li><li>退格删除一个字符，相当于通常的 Backspace 键：<code>Ctrl + h</code></li></ul><h2 id="文件管理有关"><a href="#文件管理有关" class="headerlink" title="文件管理有关"></a>文件管理有关</h2><h4 id="1-归档管理：tar"><a href="#1-归档管理：tar" class="headerlink" title="1. 归档管理：tar"></a>1. 归档管理：<code>tar</code></h4><p><strong>简介：</strong></p><p>计算机中的数据经常需要备份，tar 是 Unix&#x2F;Linux 中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。其实说白了，就是打包。</p><p><strong><code>tar</code> 使用格式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[参数]</span> 打包文件名 文件<br></code></pre></td></tr></table></figure><p><strong><code>tar</code> 常用参数：</strong></p><p>tar 命令很特殊，其参数前面可以使用“-”，也可以不使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>-v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>-f</td><td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td></tr><tr><td>-t</td><td>列出档案中包含的文件</td></tr><tr><td>-x</td><td>解开档案文件</td></tr></tbody></table><p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p><h4 id="2-文件压缩解压：gzip"><a href="#2-文件压缩解压：gzip" class="headerlink" title="2. 文件压缩解压：gzip"></a>2. 文件压缩解压：<code>gzip</code></h4><p><strong>简介：</strong></p><p>tar 与 gzip 命令结合使用实现文件打包、压缩。 tar 只负责打包文件，但不压缩，用 gzip 压缩 tar 打包后的文件，其扩展名一般用xxxx.tar.gz。</p><p><strong><code>gzip</code> 使用格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gzip  <span class="hljs-selector-attr">[选项]</span>  被压缩文件<br></code></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>解压</td></tr><tr><td>-r</td><td>压缩所有子目录</td></tr></tbody></table><p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 …</p><p><code>-z ：指定压缩包的格式为：file.tar.gz</code></p><p>解压用法： tar zxvf 压缩包包名</p><p><code>-z:指定压缩包的格式为：file.tar.gz</code></p><p>解压到指定目录：-C （大写字母“C”）</p><h4 id="3-文件压缩解压：bzip2"><a href="#3-文件压缩解压：bzip2" class="headerlink" title="3. 文件压缩解压：bzip2"></a>3. 文件压缩解压：<code>bzip2</code></h4><p><strong>简介：</strong></p><p>tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。</p><p>tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。</p><p>在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar -jcvf 压缩包包名 文件…(tar jcvf bk.tar.bz2 *.c)</p><p>解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</p><h4 id="4-文件压缩解压：zip-、unzip"><a href="#4-文件压缩解压：zip-、unzip" class="headerlink" title="4. 文件压缩解压：zip 、unzip"></a>4. 文件压缩解压：<code>zip</code> 、<code>unzip</code></h4><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><p>压缩文件：zip [-r] 目标文件(没有扩展名) 源文件</p><p>解压文件：unzip -d 解压后目录文件 压缩文件</p><h4 id="5-输出重定向命令：-gt"><a href="#5-输出重定向命令：-gt" class="headerlink" title="5. 输出重定向命令：&gt;"></a>5. 输出重定向命令：<code>&gt;</code></h4><p><strong>简介：</strong></p><p>Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p><p>注意： <code>&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部。</code></p><h4 id="6-分屏显示：more"><a href="#6-分屏显示：more" class="headerlink" title="6. 分屏显示：more"></a>6. 分屏显示：<code>more</code></h4><p><strong>简介：</strong></p><p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用 <code>more</code> 命令，每次只显示一页，按下空格键可以显示下一页，按下 <code>q</code> 键退出显示，按下 <code>h</code> 键可以获取帮助。</p><h4 id="7-文本搜索：grep"><a href="#7-文本搜索：grep" class="headerlink" title="7. 文本搜索：grep"></a>7. 文本搜索：<code>grep</code></h4><p><strong>简介：</strong></p><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。如果找到匹配模式， grep 打印包含模式的所有行。</p><p>grep一般格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grep <span class="hljs-selector-attr">[-选项]</span> ‘搜索内容串’文件名<br></code></pre></td></tr></table></figure><p>在 grep 命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p><p><strong><code>grep</code> 常用参数：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>grep 搜索内容串可以是正则表达式。</p><p><strong>grep 常用正则表达式：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt</td></tr><tr><td>ke$</td><td>行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt</td></tr><tr><td>[Ss]igna[Ll]</td><td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt</td></tr><tr><td>.</td><td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt</td></tr></tbody></table><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p>👉 <a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac">Mac 上“终端”中的键盘快捷键 - Apple 支持 (中国)</a> </p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 终端配置</title>
      <link href="/2020/02/23/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/02/23/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>终端 shell 工具用的是 <code>zsh</code>，具体怎么安装 zsh 这里省略。</p><p>需要用到代理设置软件 clashX ，Vim编辑器基本操作命令，http传输协议原理，zsh </p><p>关于系统用户目录下的.bashrc .bash_profile 和 .zshrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd ~<br>// bash 也就是 mac 默认的 shell 工具，配置文件为 .bashrc 和 .bash_profile<br>vim .bash_profile<br>// zsh 的配置文件为 .zshrc<br>vim .zshrc<br></code></pre></td></tr></table></figure><p>使用<code>zsh</code>作为默认<code>shell</code>工具的时候，它启动时并不会加载<code>bash</code>的这两个配置文件<code>.bashrc</code>和<code>.bash_profile</code>，而只会加载自己的配置文件<code>.zshrc</code>，为了让我们的配置文件生效，需要再做如下配置，来达到环境变量设置的永久生效。<strong>在<code>~/.zshrc</code> 文件最后增加一行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>如果不做上述设置，你就会发现，只有当你每次<code>source ~/.bash_profile</code>后才会生效，下次重新打开<code>zsh</code>窗口，还是不生效。</p><h2 id="2022-12-13"><a href="#2022-12-13" class="headerlink" title="2022-12-13"></a>2022-12-13</h2><p>有个需求需要用到 python 的 pandas 库，使用 pip 命令安装时发现下载不了报错！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Your proxy appears to only use HTTP and not HTTPS, try changing your proxy URL to be HTTP. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#https-proxy-error-http-proxy&#x27;, SSLError(SSLError(1, &#x27;[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1129)&#x27;)))&#x27;: /simple/pandas/<br></code></pre></td></tr></table></figure><p>大致看了一下是访问网络端口配置问题，这时我才发现代理订阅链接服务流量用完了，前几天从clashX换到备用的ShadowsocksX-NG使用，由于这两个代理工具分别设置的 http 和 sock 端口号不一致，所以得到 .bash_profile 文件里重新修改一下端口号，改为 ShadowsocksX-NG 所提供的端口号。</p><p><strong>由于经常使用终端进行下载一些国外源的库，就得让终端也代上理。</strong>进行代理之前得在 clashX 找“复制终端代理命令“的按钮，然后粘贴到终端运行就可以完成。<strong>但是使用 export 命令是临时的，为了防止下次打开终端需要重新复制命令运行，这时可以把命令放到一个终端配置文件 .bash_profile  中，让其每一次启动终端时就自动配好代理。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:1087<br>// 具体你的 http 和 sock5 端口号是多少，取决于你使用的代理工具，去查看就可以<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
            <tag> Terminal </tag>
            
            <tag> oh-my-zsh </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/22/hello-world/"/>
      <url>/2020/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
