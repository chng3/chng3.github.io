<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6 之模版字面量</title>
      <link href="/2023/04/12/ES6%E4%B9%8B%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
      <url>/2023/04/12/ES6%E4%B9%8B%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 绘画板</title>
      <link href="/2022/04/18/Canvas-%E7%BB%98%E7%94%BB%E6%9D%BF/"/>
      <url>/2022/04/18/Canvas-%E7%BB%98%E7%94%BB%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么在<code>add colors and sizes </code>这个提交之后，不用修改<code>onTouch</code>与<code>onMouse</code>的逻辑实现，画板颜色切换和画笔大小切换是直接就可以工作的？要想明白这个问题就得去第一次实现画笔移动工作的提交中也就是<code>init Canvas</code>，js 文件中找到判断移动设备语句 if(document.body.onTouch??)开始看。</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>onTouch 和 onMouse 函数里面只是专门负责绘制线条和橡皮擦这两个主要功能，绘制线条的颜色取决于绑定在每个画板颜色选择器回调中的设置</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bindColorsHandlers</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 选中红色画笔时</span><br>    redEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 覆盖改变绘制图形的填充颜色</span><br>        context.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>        <span class="hljs-comment">// 覆盖改变绘制线条的颜色</span><br>        context.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>        <span class="hljs-comment">// 循环删除每一个颜色画板样式</span><br>        colorsLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的红色画板添加样式</span><br>        redEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>画笔大小逻辑同上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定点击切换画笔大小的处理函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bindSizesHandlers</span>(<span class="hljs-params"></span>) &#123;<br>    thinEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        lineWidth = <span class="hljs-number">5</span><br>        <span class="hljs-comment">// 循环删除每一个画笔样式</span><br>        sizesLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的画笔添加样式</span><br>        thinEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br>    thickEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        lineWidth = <span class="hljs-number">10</span><br>        <span class="hljs-comment">// 循环删除每一个画笔样式</span><br>        sizesLiEls.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">liEl</span> =&gt;</span> &#123;<br>            liEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>        &#125;)<br>        <span class="hljs-comment">// 为选中的画笔添加样式</span><br>        thickEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为什么在<code>add colors and sizes </code>这个提交之后，不用修改<code>onTouch</code>与<code>onMouse</code>的逻辑实现，画板颜色切换和画笔大小切换是直接就可以工作的？主要还是得益于代码编写时采取了模块化处理，例如将每个可以复用的点封装成一个函数，并为这个函数取个简单且易懂的名字，<strong>这样需要使用时就直接调用函数就可以</strong>。发现这可能就是<strong>函数式编程</strong>思想的特性之一。</p><p>模块化这个方法可以提高编写代码和维护代码的效率。</p><h1 id="关于函数式编程"><a href="#关于函数式编程" class="headerlink" title="关于函数式编程"></a>关于函数式编程</h1><p>请参见：<br>[深入理解函数式编程]: <a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初次接触 Figma</title>
      <link href="/2022/04/16/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6-Figma/"/>
      <url>/2022/04/16/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6-Figma/</url>
      
        <content type="html"><![CDATA[<p>参考文：</p><p><a href="https://mp.weixin.qq.com/s/6LUX-gyoaINUQvHvLBSgvg">https://mp.weixin.qq.com/s/6LUX-gyoaINUQvHvLBSgvg</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端攻城师</title>
      <link href="/2022/04/10/Front-End%20developer%20tech%20interview/"/>
      <url>/2022/04/10/Front-End%20developer%20tech%20interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Front-End-developer-tech-interview"><a href="#Front-End-developer-tech-interview" class="headerlink" title="Front-End developer tech interview"></a>Front-End developer tech interview</h1><h2 id="GET和POST两种基本请求方法的区别"><a href="#GET和POST两种基本请求方法的区别" class="headerlink" title="GET和POST两种基本请求方法的区别"></a>GET和POST两种基本请求方法的区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转 GitHub</title>
      <link href="/2021/10/18/%E7%8E%A9%E8%BD%AC-GitHub/"/>
      <url>/2021/10/18/%E7%8E%A9%E8%BD%AC-GitHub/</url>
      
        <content type="html"><![CDATA[<p>特殊的查找资源小技巧</p><p>常用前缀后缀</p><ul><li>找百科大全 <code>awesome xxx</code></li><li>找例子 <code>xxx sample</code></li><li>找空项目架子 <code>xxx starter/xxx boilerplate</code></li><li>找教程 <code>xxx tutorial</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 和 SVG 区别</title>
      <link href="/2021/04/20/Canvas-%E5%92%8C-SVG-%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/04/20/Canvas-%E5%92%8C-SVG-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>以下内容取之菜鸟教程</p><h2 id="SVG-与-Canvas两者间的区别"><a href="#SVG-与-Canvas两者间的区别" class="headerlink" title="SVG 与 Canvas两者间的区别"></a>SVG 与 Canvas两者间的区别</h2><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><h2 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h2><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><table><thead><tr><th align="left">Canvas</th><th align="left">SVG</th></tr></thead><tbody><tr><td align="left">依赖分辨率<br />不支持事件处理器<br />弱的文本渲染能力<br />能够以 .png 或 .jpg 格式保存结果图像最适合图像<br />密集型的游戏，其中的许多对象会被频繁重绘</td><td align="left">不依赖分辨率<br />支持事件处理器<br />最适合带有大型渲染区域的应用程序（比如谷歌地图）<br />复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br />不适合游戏应用</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Js 之混淆与反混淆</title>
      <link href="/2021/03/08/Js-%E4%B9%8B%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
      <url>/2021/03/08/Js-%E4%B9%8B%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>JavaScript混淆是指将原始的JavaScript代码转换为难以读懂和理解的形式，以保护JavaScript代码的知识产权和保密性。常见的混淆技术包括变量名替换、代码压缩、代码加密、字符串混淆等。</p><p>变量名替换是一种常见的混淆技术，它将代码中的变量名替换为无意义的字符，例如将变量名<code>count</code>替换为<code>a</code>。这使得代码难以理解和维护。代码压缩是另一种常见的混淆技术，它通过删除代码中的空格、注释和其他不必要的字符来减小文件大小，使得代码难以读取和理解。</p><p>代码加密是一种将JavaScript代码转换为难以读懂的形式的混淆技术。它使用各种算法对代码进行加密，例如使用AES加密算法对代码进行加密，然后将加密后的代码作为字符串存储在JavaScript文件中。</p><p>字符串混淆是一种将JavaScript代码中的字符串转换为难以读懂的形式的混淆技术。它通常会将字符串拆分为多个小段，然后将每个小段转换为16进制或Unicode编码，以减少字符串的可读性。</p><p>反混淆是指将混淆后的JavaScript代码还原为原始的代码的过程。由于混淆技术通常是可逆的，因此可以使用反混淆技术还原代码。常见的反混淆技术包括手动还原、使用反混淆工具等。</p><p>手动还原是一种将混淆代码还原为原始代码的方法。它通常需要对混淆代码进行分析和破解，以还原出原始的代码。这种方法需要较高的技术水平和耐心。</p><p>反混淆工具是一种使用特定算法和技术的软件工具，可以自动将混淆后的JavaScript代码还原为原始的代码。常见的反混淆工具包括UglifyJS、JSNice、JStillery等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TS 之面向对象的相关特性</title>
      <link href="/2020/05/06/TS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"/>
      <url>/2020/05/06/TS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TS 之类型声明</title>
      <link href="/2020/05/04/TS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/"/>
      <url>/2020/05/04/TS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 之SVG</title>
      <link href="/2020/04/20/HTML5-%E4%B9%8BSVG/"/>
      <url>/2020/04/20/HTML5-%E4%B9%8BSVG/</url>
      
        <content type="html"><![CDATA[<h1 id="SVG是什么？"><a href="#SVG是什么？" class="headerlink" title="SVG是什么？"></a>SVG是什么？</h1><ul><li>SVG 指的是可伸缩矢量的图形（Scalable Vector Graphics）</li></ul><h1 id="SVG可以用来做什么？"><a href="#SVG可以用来做什么？" class="headerlink" title="SVG可以用来做什么？"></a>SVG可以用来做什么？</h1><ul><li>可以绘制多种路径、框、圆、文本、和图形图像（所有的用于网络的基于矢量的图形）</li></ul><h1 id="SVG有多好？"><a href="#SVG有多好？" class="headerlink" title="SVG有多好？"></a>SVG有多好？</h1><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li></ul><h1 id="如何使用SVG？"><a href="#如何使用SVG？" class="headerlink" title="如何使用SVG？"></a>如何使用SVG？</h1><p>在 HTML5 中，HTML <strong><svg></strong> 元素是 SVG 图形的容器，能够将 SVG 元素直接嵌入 HTML 页面中（支持内联）</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p>在坐标（100，50）处画一个半径为40，填充颜色为红色，描绘轮廓为黑色、宽度为2的一个圆</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;black&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/37VO2k.png" alt="37VO2k"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6 之解构赋值</title>
      <link href="/2020/04/11/ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2020/04/11/ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6 之箭头函数</title>
      <link href="/2020/04/09/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2020/04/09/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学好 JavaScript 的好处</title>
      <link href="/2020/04/06/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
      <url>/2020/04/06/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<p>todo</p><p>参考文章：<a href="https://blog.csdn.net/qq_38861711/article/details/95729429">https://blog.csdn.net/qq_38861711/article/details/95729429</a></p><p>对于前端工作者而言，JavaScript 作为三大前端套件中的一位成员不是没有原因的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之 Promise</title>
      <link href="/2020/04/04/JS%E4%B9%8BPromise/"/>
      <url>/2020/04/04/JS%E4%B9%8BPromise/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-之-Promise"><a href="#JS-之-Promise" class="headerlink" title="JS 之 Promise"></a>JS 之 Promise</h1><p>学习 Promise 是非常重要的，因为它是一种异步编程的重要方式，可以帮助我们更好地处理异步操作，避免回调地狱（Callback Hell）的问题。</p><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>假设我们要实现一个异步的加法函数 <code>addAsync</code>，它接收两个数字作为参数，并异步地计算它们的和，最终返回一个 Promise 对象，用于表示异步操作的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addAsync</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Invalid arguments&#x27;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(a + b);<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>new Promise()</code> 创建了一个新的 Promise 对象，并传入一个回调函数，这个回调函数接收两个参数 <code>resolve</code> 和 <code>reject</code>，分别用于表示异步操作成功和失败的情况。</p><p>在回调函数中，我们使用 <code>setTimeout()</code> 来模拟异步计算的过程。如果两个参数都是数字，那么我们就调用 <code>resolve</code> 方法，并将它们的和作为参数传入；如果有一个或两个参数不是数字，那么我们就调用 <code>reject</code> 方法，并传入一个错误对象作为参数。</p><p>接下来，我们可以使用 <code>then()</code> 方法来处理异步操作的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addAsync</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 5</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// 输出错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先调用 <code>addAsync()</code> 函数，并传入两个数字参数 2 和 3，得到一个 Promise 对象。然后，我们使用 <code>then()</code> 方法来处理异步操作成功的情况，它接收一个回调函数作为参数，这个回调函数会在异步操作成功后被调用，并传入异步操作的结果。在这个回调函数中，我们将结果输出到控制台。</p><p>如果异步操作失败，那么我们可以使用 <code>catch()</code> 方法来处理失败的情况，它接收一个回调函数作为参数，这个回调函数会在异步操作失败后被调用，并传入一个错误对象作为参数。在这个回调函数中，我们将错误信息输出到控制台。</p><p>总之，这个例子展示了如何使用 Promise 来实现异步操作，并处理异步操作的结果和错误。使用 Promise 可以帮助我们更好地处理异步操作，避免回调地狱的问题，提高代码的可读性和可维护性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之 词法作用域</title>
      <link href="/2020/04/03/JS%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/04/03/JS%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-之-词法作用域"><a href="#JS-之-词法作用域" class="headerlink" title="JS 之 词法作用域"></a>JS 之 词法作用域</h1><p>词法作用域是 JavaScript 中的一个概念，它指的是变量作用域的静态性。在词法作用域中，变量的作用域由它在代码中声明的位置所决定，与代码执行的上下文无关。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><p>在这个例子中，函数 <code>foo</code> 中的 <code>x</code> 引用的是外部的变量 <code>x</code>，因为在词法作用域中，函数 <code>foo</code> 的作用域链包含了它定义时所处的作用域，即全局作用域。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之闭包</title>
      <link href="/2020/04/02/JS%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
      <url>/2020/04/02/JS%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 之区分相似的数组方法</title>
      <link href="/2020/04/02/JS%E4%B9%8B%E5%8C%BA%E5%88%86%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/02/JS%E4%B9%8B%E5%8C%BA%E5%88%86%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自V2EX某篇帖子中的回复</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单纯地遍历</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span><br><br><span class="hljs-comment">// 检测数组中是否有元素符合条件</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">some</span><br><br><span class="hljs-comment">// 检测数组中是否所有元素符合条件</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">every</span><br><br><span class="hljs-comment">// 用来将一个列表转换成另一个等长的列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span><br><br><span class="hljs-comment">// 用来将一个列表转换成一个值</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span><br><br><span class="hljs-comment">// 从列表中找出符合条件的一个元素</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span><br><br><span class="hljs-comment">// 从列表中找出符合条件的若干元素</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">filter</span><br><br><span class="hljs-comment">// 拍平列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flat</span><br><br><span class="hljs-comment">// map 和 flat 的结合，适合用来将一个列表转换成另一个不等长的列表</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flatMap</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My HTML &amp; CSS Notebook</title>
      <link href="/2020/04/01/My-CSS%20&amp;%20HTML-Notebook/"/>
      <url>/2020/04/01/My-CSS%20&amp;%20HTML-Notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="行内元素与块级元素区别"><a href="#行内元素与块级元素区别" class="headerlink" title="行内元素与块级元素区别"></a>行内元素与块级元素区别</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%AF%B9%E6%AF%94">MDN</a></p><ul><li><p>内容</p><p>一般情况下，行内元素只能包含数据和其他行内元素。</p><p>而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li><li><p>格式</p><p>默认情况下，<strong>行内元素不会以新行开始，而块级元素会新起一行。</strong></p></li></ul><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p>特点：</p><ol><li>当块内元素转化为行内块元素时，如果没有给特点的宽度或者高度，则宽和高默认是元素内容的大小。</li></ol><p>应用：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上边三个div盒子默认按照标准流布局排放，即从上到下的方式，此时<strong>如果我想要让它们在一行显示，像行内元素一样，就可以在样式中设置display属性，如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123; <br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: gray;<br>  <span class="hljs-comment">/*将块元素转化成行内块元素实现一行排放盒子，使用display属性*/</span><br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，<strong>这三个div盒子就不是原来的块内元素，属性行内的块元素</strong></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级（specificity）"><a href="#选择器优先级（specificity）" class="headerlink" title="选择器优先级（specificity）"></a>选择器优先级（specificity）</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F">MDN 链接</a><br>CSS 选择器权重表：</p><p>![css选择器权重表](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725165840063.png)</p><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>页面布局要学习三大核心，<strong>盒子模型</strong>，<strong>浮动</strong>和<strong>定位</strong>。学习好盒子模型能非常好的帮助我们布局页面</p><p>看透网页布局的本质</p><p>网页布局过程：</p><p>1。先准备好相关的网页元素，网页元素基本都是盒子Box。</p><p>2。利用CSS设置好盒子样式，然后摆放到相应位置。</p><p>3。往盒子里面装内容。</p><p>网页布局的核心本质：就是利用CSS摆盒子。</p><ul><li>两条应用准则（重要）：</li></ul><ol><li><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</strong></li><li><strong>网页布局第二准则：先设置盒子大小，之后设置盒子的位置</strong></li></ol><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>![image-20220725182216656](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182216656.png)</p><p>![image-20220725182257247](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182257247.png)</p><h4 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border#syntax">三大属性 - border-width, border-color, border-sytle</a></p><p>边框复合（简写）写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/* 没有顺序 */</span><br></code></pre></td></tr></table></figure><p>边框分开写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/*只设定上边框，其余同理 */</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse">额外属性 ：border-collapse - 处理表格边框是否合并属性</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-comment">/* 合并（collapsed ）模式下，表示相邻边框合并在一起(共享边框) */</span><br></code></pre></td></tr></table></figure><p><strong>边框会影响盒子的实际大小；</strong></p><h4 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h4><p>当盒子指定了宽度和高度时，<strong>内边距会影响盒子的实际大小；如：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为240px，高度为240px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打开开发者面板工具，检查盒子大小会发现盒子的宽度为240px，高度为240px。</p><p>如果保证盒子为200px，跟效果图大小保特一致，<strong>则让width&#x2F;height减去多出来的内边距大小即可</strong>，将上面的写法改成下面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为200px，高度为200px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: aqua;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: pink;<br>      <span class="hljs-comment">/* 这里p元素继承div标签的宽和高，单独对p元素设置内边距不会撑大外面包裹的div盒子 */</span><br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><p>外边距合并问题？TODO</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="1-2-标准流（普通流-x2F-文档流）"><a href="#1-2-标准流（普通流-x2F-文档流）" class="headerlink" title="1.2 标准流（普通流&#x2F;文档流）"></a>1.2 标准流（普通流&#x2F;文档流）</h4><p><strong>所谓的标准流：就是标签按照规定好默认方式排列</strong></p><ol><li>块级元素会独占一行，从上到下顺序排序。</li></ol><ul><li>常用元素：div、hr、p、h1-h6、ul、ol、dl、form、table</li></ul><ol start="2"><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li></ol><ul><li>常用元素：span、a、i、em等</li></ul><p>以上都是标准流布局，我们前面学习的就是标准流，<strong>标准流就是最基本的布局方式。</strong></p><h4 id="1-3-为什么需要浮动"><a href="#1-3-为什么需要浮动" class="headerlink" title="1.3 为什么需要浮动"></a>1.3 为什么需要浮动</h4><ol><li><p>虽然块级元素能通过设置display转化成行内块级元素，达到多个块级元素（盒子div）水平排列成一行显示（排放）的目的，<strong>但是每个元素（盒子）之间的距离（缝隙）很难控制</strong></p></li><li><p><strong>在一个大盒子中存放着两个盒子，无法通过标准流的方式使得两个盒子左右对齐。</strong></p></li></ol><p>总结：有很多的布局效果，标准流没有办法完成，此时就河以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示。</p><p><strong>网页布局第一准则</strong>：<strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</strong></p><h4 id="1-4-什么是浮动"><a href="#1-4-什么是浮动" class="headerlink" title="1.4 什么是浮动"></a>1.4 什么是浮动</h4><p><strong>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">float</span>: 属性值; &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h4 id="1-5-浮动的特性（重难点）"><a href="#1-5-浮动的特性（重难点）" class="headerlink" title="1.5 浮动的特性（重难点）"></a>1.5 浮动的特性（重难点）</h4><ol><li>设置了浮动(f1oat)的元素最重要特性：</li></ol><ul><li><p>脱离标准普通流的控制（浮）移动到指定位置（动），（俗称<strong>脱标</strong>)</p></li><li><p>浮动的盒子不再保留原先的位置</p></li></ul><ol start="2"><li><p>如果多个盒子都设置了浮动，则它们会按照属性值<strong>一行内显示并且顶端对济排列</strong>。注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p></li><li><p>浮动元素会具有行内块级元素的特征。</p><p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有<strong>行内块元素</strong>相似的特性。</p></li></ol><ul><li><p>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添浮动后，它的大小根据内容来决定</p></li><li><p>浮动的盒子中间是没有缝隙的，是紧挨着一起的</p></li><li><p>行内元素同理</p></li></ul><h4 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置，我们网页布局一般采取的策略是：</p><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准侧</strong></p><h4 id="1-7-浮动布局注意点"><a href="#1-7-浮动布局注意点" class="headerlink" title="1.7 浮动布局注意点"></a>1.7 浮动布局注意点</h4><ol><li>浮动和标准流的父盒子搭配。</li></ol><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</strong></p><ol start="2"><li>一个元素浮动了，理论上其余的兄弟元素也要浮动。</li></ol><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。</p><p><strong>浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流</strong></p><h4 id="1-8-为什么需要清除浮动"><a href="#1-8-为什么需要清除浮动" class="headerlink" title="1.8 为什么需要清除浮动"></a>1.8 为什么需要清除浮动</h4><p>我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点都是有高度的。</p><p>但是，所有的父盒子都必须要有高度吗？</p><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。</p><p><strong>我的理解是在实际的网页布局中，父盒子中被设置浮动的子盒子的数量和高度是不确定的，为了避免子盒子溢出父盒子，所以父盒子的高度不会写死（不会设置），但当父盒子没有设置高度时，里面浮动的子盒子会脱标，不会自动撑开父盒子的高度，会导致网页布局结构混乱，这时就需要清除浮动</strong></p><h4 id="1-9-清除浮动的本质"><a href="#1-9-清除浮动的本质" class="headerlink" title="1.9 清除浮动的本质"></a>1.9 清除浮动的本质</h4><ul><li><p>清除浮动的本质是清除浮动元素造成的影响</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</p></li></ul><h4 id="2-清除浮动方法"><a href="#2-清除浮动方法" class="headerlink" title="2 清除浮动方法"></a>2 清除浮动方法</h4><p><strong>清除浮动的策略是：闭合浮动</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">clear</span>: both; &#125;<br></code></pre></td></tr></table></figure><h5 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h5><p>颜外标签法也称为隔墙法，是W3C推荐的做法。</p><p>额外标签法会在浮动元素末尾添加一个空的标签。例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">clear</span>：both&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>或者其他标签 (如<br/>等)。</p><p>优点：通俗易懂，书写方便</p><p>·缺点：添加许多无意义的标签，结构化较差</p><p>注意：要求这个新的空标签必须是块级元素。</p><p><strong>实际工作可能会遇到，但是不常用</strong></p><h5 id="父级添加overflow属性"><a href="#父级添加overflow属性" class="headerlink" title="父级添加overflow属性"></a>父级添加overflow属性</h5><p>可以给父级添加overflow属性，将其属性值设置为<strong>hidden</strong>、auto或scroll。</p><p>子不教父之过，注意是给父元素添加代码</p><ul><li><p>优点：代码简洁</p></li><li><p>缺点：无法显示溢出的部分</p></li></ul><h5 id="父级添加after伪元素（推荐）"><a href="#父级添加after伪元素（推荐）" class="headerlink" title="父级添加after伪元素（推荐）"></a>父级添加after伪元素（推荐）</h5><p>:after 方式是额外标签法的升级版。</p><p>找到父级元素，然后添加一个类名为 clearFix，随后添加对应css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：没有增加标签，结构更简单</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：百度、淘宝网、网易等</p></li></ul><h5 id="父级添加双伪元素（推荐）"><a href="#父级添加双伪元素（推荐）" class="headerlink" title="父级添加双伪元素（推荐）"></a>父级添加双伪元素（推荐）</h5><p>也是给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 清除浮动 */</span><br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">::before</span>,<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：代码更简洁</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：小米、腾讯等</p></li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="为什么需要定位"><a href="#为什么需要定位" class="headerlink" title="为什么需要定位"></a>为什么需要定位</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/8R1L9q.png" alt="8R1L9q"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/K4p6U3.png" alt="K4p6U3"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/U9itev.png" alt="U9itev"></p><h4 id="定位组成"><a href="#定位组成" class="headerlink" title="定位组成"></a>定位组成</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/cuPpYa.png" alt="cuPpYa"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/bL9n0j.png" alt="bL9n0j"></p><h5 id="静态定位（了解）"><a href="#静态定位（了解）" class="headerlink" title="静态定位（了解）"></a>静态定位（了解）</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/tcZSju.png" alt="tcZSju"></p><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/0hDzkj.png" alt="0hDzkj"></p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/nCNkSc.png" alt="nCNkSc"></p><p>绝对定位的特点：（务必记住）</p><ol><li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位(Document文档)。</li><li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li><li>绝对定位不再占有原先的位置。（脱标）</li></ol><h6 id="1-6-子绝父相的由来"><a href="#1-6-子绝父相的由来" class="headerlink" title="1.6 子绝父相的由来"></a>1.6 子绝父相的由来</h6><p>弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。</p><p>这个“子绝父相”太重要了，是我们学习定位的口决，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。</p><p>① 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p><p>② 父盒子需要加定位限制子盒子在父盒子内显示。</p><p>③ 父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p><p>这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。</p><p>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</p><p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。</p><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><h6 id="1-7-固定定位-fixed（重要）"><a href="#1-7-固定定位-fixed（重要）" class="headerlink" title="1.7 固定定位 fixed（重要）"></a>1.7 固定定位 fixed（重要）</h6><p>固定定位是元素<strong>固定于浏览器的可视化的位置</strong>。主要使用场景：可以在浏览器页面滚动时元素的位置不会变</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: fixed;<br></code></pre></td></tr></table></figure><p>固定定位的特点：（务必记住）</p><ol><li>以浏览器的可视窗口为参照点移动元素</li></ol><ul><li>跟父元素没有任何关系</li><li>不随滚动条移动</li></ul><ol start="2"><li>固定定位不在占有原先的位置</li></ol><p>固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。</p><p><strong>固定定位小技巧：固定在版心右侧位置</strong></p><p>小算法：</p><ol><li>让固定定位的盒子left：50px，走到浏览器可视区（也可以看做版心）的一半位置。</li><li>让固定定位的盒子margin-left：版心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。</li></ol><h5 id="粘性定位（了解）"><a href="#粘性定位（了解）" class="headerlink" title="粘性定位（了解）"></a>粘性定位（了解）</h5><p><strong>粘性定位</strong>可以被人们认为是相对定位和固定定位的混合体。Sticky 粘性的</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">position</span>: sticky; <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;&#125;<br></code></pre></td></tr></table></figure><p>粘性定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素（固定定位的特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li>必须添加 top、left、right、bottom 其中一个才有效</li></ol><p>跟页面滚动搭配使用。<strong>兼容性较差，IE不支持。所以大多数都是通过 JS 来控制实现粘性定位。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一定要记住<strong>相对定位、绝对定位、固定定位</strong>各两个大的特点：</p><ol><li>是否占有位置（脱标否）2.以谁为基准点移动位置。</li><li>学习定位重点学会子相父绝。</li></ol><h4 id="定位的叠放次序-z-index"><a href="#定位的叠放次序-z-index" class="headerlink" title="定位的叠放次序 z-index"></a>定位的叠放次序 z-index</h4><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序（z轴）</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>数值可以是正整数、负整数或0，默认时auto，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有z-index属性</li></ul><h4 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h4><h5 id="1-绝对定位的盒子居中"><a href="#1-绝对定位的盒子居中" class="headerlink" title="1. 绝对定位的盒子居中"></a>1. 绝对定位的盒子居中</h5><p>加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过以下计算方式实现水平和垂直居中。</p><p>水平居中方法：</p><p>1⃣️ left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。</p><p>2⃣️ margin-left: -100px; 让盒子向左移动自身宽度的一半（注意负号代表往左）。</p><p>垂直居中方法：</p><p>1⃣️ top: 50%; 让盒子的顶部移动到父级元素的垂直位置。</p><p>2⃣️ margin-top: -100px; 让盒子向上移动自身高度的一半（注意负号代表往左）。</p><h5 id="2-定位的特殊性"><a href="#2-定位的特殊性" class="headerlink" title="2. 定位的特殊性"></a>2. 定位的特殊性</h5><p>绝对定位和固定定位也和浮动类似。</p><ol><li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度</li><li>块内元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li></ol><h5 id="3-脱标的盒子不会触发外边距塌陷"><a href="#3-脱标的盒子不会触发外边距塌陷" class="headerlink" title="3. 脱标的盒子不会触发外边距塌陷"></a>3. 脱标的盒子不会触发外边距塌陷</h5><p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p><h5 id="绝对定位（固定定位）会完全压住盒子"><a href="#绝对定位（固定定位）会完全压住盒子" class="headerlink" title="绝对定位（固定定位）会完全压住盒子"></a>绝对定位（固定定位）会完全压住盒子</h5><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p><p>但是绝对定位（固定定位）会压住下面标准流所有的内容。</p><p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。文字会围绕浮动元素</p><h3 id="网页布局总结"><a href="#网页布局总结" class="headerlink" title="网页布局总结"></a>网页布局总结</h3><p>通过盒子模型，清楚知道大部分html标签是一个盒子。</p><p>通过CSS浮动、定位可以让每个盒子排列成为网页。</p><p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p><ol><li>标准流</li></ol><p>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。</p><ol start="2"><li>浮动</li></ol><p>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。</p><ol start="3"><li>定位</li></ol><p>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法和题库练习笔记</title>
      <link href="/2020/03/10/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/10/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找（binary-search）"><a href="#二分查找（binary-search）" class="headerlink" title="二分查找（binary search）"></a>二分查找（binary search）</h2><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳</p></blockquote><blockquote><p>当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之90的学生在花费数小时后还是无法给出正确的解答，<strong>主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。</strong>1988年开展的一项研究显示，20本教科书里只有5本正确实现了二分搜索。不仅如此，本特利自己1986年出版的《编程珠玑》一书中的二分搜索算法<strong>存在整数溢出的问题</strong>，二十多年来无人发现。Java语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。 ——摘自维基百科</p></blockquote><p>视频讲解：<a href="https://youtu.be/CMweVF2iSyQ">二分查找法</a><br>时间复杂度：O(logn)<br>伪代码及方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/006DDiezgy1h08n6lcku4j325012y4a8.jpg" alt="006DDiezgy1h08n6lcku4j325012y4a8"><br>力扣相关题目：<a href="https://leetcode-cn.com/problems/binary-search/">力扣算法题目704</a></p><h2 id="回溯法（backtracking）"><a href="#回溯法（backtracking）" class="headerlink" title="回溯法（backtracking）"></a>回溯法（backtracking）</h2><p>待看做笔记： <a href="https://youtu.be/nrHTtjkYEyQ">使用C++讲解</a><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/01.39.29.png" alt="01.39.29"></p><h2 id="双指针（Two-pointer）"><a href="#双指针（Two-pointer）" class="headerlink" title="双指针（Two pointer）"></a>双指针（Two pointer）</h2><p>创建两个指针分别指向数组的首、末位置。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//test.c</span><br><span class="hljs-comment">//利用双指针判断字符的对称问题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//设置一个布尔值 symmetry默认为true</span><br><span class="hljs-type">bool</span> symmetry = <span class="hljs-literal">true</span>;<br><span class="hljs-type">char</span> str[]= <span class="hljs-string">&quot;BaeAB&quot;</span>; <span class="hljs-comment">//很明显,该字符串不是对称的</span><br><span class="hljs-comment">//遍历字符串数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str) / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-comment">//如果对称的两个位置上的数值不相等,则返回false</span><br><span class="hljs-keyword">if</span> (str[i] != str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c != %c\n&quot;</span>,str[i],str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]);<br>symmetry = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (symmetry) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串为对称的\n&quot;</span>,str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串不是对称的\n&quot;</span>,str);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>a != A<br>BaeAB:该字符串不是对称的<br></code></pre></td></tr></table></figure><p>在循环体for中, 当循环第一次时, <code>str[i]</code>和<code>str[strlen(str)-1-i]</code>分别指向<code>str</code>数组的首位和末位元素(这里是指结束符“\0”的前一位元素)。如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/J49VDc.png" alt="J49VDc"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树(Binary-Tree)</title>
      <link href="/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/"/>
      <url>/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2><p>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</p><h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><p>树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84">树结构</a>。通常分支被称作“左子树”或“右子树”。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>所有叶节点都在最底层的完全二叉树；</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>英语：(Binary Search Tree)：也称二叉搜索树、有序二叉树；</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinToGo - 可以随身携带的系统U盘</title>
      <link href="/2020/02/28/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/"/>
      <url>/2020/02/28/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="折腾原因"><a href="#折腾原因" class="headerlink" title="折腾原因"></a>折腾原因</h2><p>最近几年一直使用 macOS，调试一些页面需要在 Windows 系统上操作（实际上是为了在 Win 打游戏：：））对了，就是 Java 期末考试需要用的软件只在 win 平台。。。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>我的mbp已经算是比较老的14年中装载4代i5的设备，对照以下这个图是支持制作USB系统盘启动Windows的。<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/1649086686847.jpg" alt="1649086686847"></p><h2 id="挑选适合做系统的U盘"><a href="#挑选适合做系统的U盘" class="headerlink" title="挑选适合做系统的U盘"></a>挑选适合做系统的U盘</h2><p>从<a href="https://bbs.luobotou.org/">萝卜头网</a>上了解到WTG对U盘性能有着一定的要求，这个网站有推荐购买的U盘（对于我来说太贵），这里特别得亏有大佬在上面分享了一些可供选择的比较特殊的U盘。这里对比一下我现有的普通闪迪U盘和以手机硬盘为颗粒的UFS盘之间的4k读写速度，特别是4k写入小文件的速度，可以明显的看到差距。<br>普通U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/%E9%97%AA%E8%BF%AA%E6%99%AE%E9%80%9AU'%E7%9B%98.png" alt="闪迪普通U&#39;盘"></p><p>适合做WTG的U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/sm3833_ufs_U%E7%9B%98_4k%E5%86%99%E5%85%A5%E6%B5%8B%E8%AF%95.png" alt="sm3833_ufs_U盘_4k写入测试"></p><h2 id="使用工具制作启动U盘"><a href="#使用工具制作启动U盘" class="headerlink" title="使用工具制作启动U盘"></a>使用工具制作启动U盘</h2><h3 id="Mac（inter芯片）启动方式"><a href="#Mac（inter芯片）启动方式" class="headerlink" title="Mac（inter芯片）启动方式"></a>Mac（inter芯片）启动方式</h3><p>开机长按<code>option</code>键，然后选中<strong>EFI Boot</strong>这个磁盘，直接按<code>Enter</code>键</p><h3 id="Windows-启动方式"><a href="#Windows-启动方式" class="headerlink" title="Windows 启动方式"></a>Windows 启动方式</h3><p>开机按画面提示按<code>U盘启动选择快捷键</code>选择<strong>EFI Boot</strong>这个磁盘，然后按<code>Enter</code></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地项目上传到 GitHub 托管</title>
      <link href="/2020/02/26/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/"/>
      <url>/2020/02/26/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Github基础使用"><a href="#Github基础使用" class="headerlink" title="Github基础使用"></a>Github基础使用</h1><h2 id="将本地仓库关联到GitHub"><a href="#将本地仓库关联到GitHub" class="headerlink" title="将本地仓库关联到GitHub"></a>将本地仓库关联到GitHub</h2><h3 id="初始化本地仓库并提交仓库文件"><a href="#初始化本地仓库并提交仓库文件" class="headerlink" title="初始化本地仓库并提交仓库文件"></a>初始化本地仓库并提交仓库文件</h3><p>要先确保操作系统已经安装了<strong>Git</strong>，之后进入本地仓库的根目录，鼠标右键选择<code>Git Bash Here</code>，接着输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><p>出现以下回应且在根目录下生成了一个隐藏的文件夹<code>.git</code><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/hHrssB.png" alt="hHrssB"><br>此时，如图所示它是将<code>master</code>作为初始分支的名称，这里为了跟之后在 github 上默认创建的分支名一致，可以改名为<code>main</code>，输入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-m <span class="hljs-string">&quot;main&quot;</span><br></code></pre></td></tr></table></figure><p>此时仓库里的文件还没有被追踪，输入</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> . <span class="hljs-comment">//将仓库里的所有文件进行追踪</span><br></code></pre></td></tr></table></figure><p>提交一次快照，输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git commit -m <span class="hljs-string">&quot;Started Course&quot;</span><span class="hljs-regexp">//</span><span class="hljs-string">&quot; &quot;</span>里可以自定义快照的名字<br></code></pre></td></tr></table></figure><h3 id="在GitHub上创建一个项目"><a href="#在GitHub上创建一个项目" class="headerlink" title="在GitHub上创建一个项目"></a>在GitHub上创建一个项目</h3><p>GitHub主页右上角点击new repository<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9y9tnkcj20al06bab3.jpg"><br>输入信息，<strong>记住勾选Initialize this repository with a REAdME</strong></p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9yw1qg5j20o10hhgn0.jpg"></p><p>创建后，复制项目的地址</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9z9g1caj20sf0eujsx.jpg"></p><p>回到本地仓库，使用命令，<strong>并在命令后加上你的GitHub项目的地址</strong>，也就是刚才复制的内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git remote <span class="hljs-built_in">add</span> origin<br></code></pre></td></tr></table></figure><p>这一步是本地和远程服务器建立联系的一步。执行成功后不会显示任何结果：<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa001gerj20fn021q37.jpg"></p><p>到这里，你已经成功了一半了。</p><h3 id="向远程仓库提交代码"><a href="#向远程仓库提交代码" class="headerlink" title="向远程仓库提交代码"></a>向远程仓库提交代码</h3><p>第一次向远程提交代码时得先将远程的README.md 文件(如果有)同步过来，实行一下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git pull <span class="hljs-comment">--rebase origin master</span><br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa0n36itj20db02xq38.jpg"></p><p>查看本地仓库是否出现README.md文件，如有，则表示拉取则成功。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1awhwuj20gp032glw.jpg"></p><p>接着，将进行第一次向远程同步本地仓库的内容，输入：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1pgcvpj20dj0400t6.jpg"><br><strong>注意</strong>：过程中可能会出现一个登陆GitHub帐户的窗口，输入你的账户及密码就可以了。</p><p>最后回到GitHub主页查看是否同步即可。</p><h2 id="文件变动操作"><a href="#文件变动操作" class="headerlink" title="文件变动操作"></a>文件变动操作</h2><h3 id="本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？"><a href="#本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？" class="headerlink" title="本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？"></a>本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？</h3><p>比如我在本地有一个名为CodingAtSchool的仓库，仓库里有C语言作业文件夹和一个README文件如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa29yeq8j20i705hdgm.jpg"><br>我今天用操作鼠标做了大量对C语言目录下的改动，之后进到仓库根目录下，右键Git Bash Here，输入git status，查看仓库状态。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2m62lwj20ko0d0k3y.jpg"><br>oops，大量的红色数字什么鬼，这时千万别慌！如果本地仓库中含文件名为中文名称时，命令窗中提示的信息是无法显示中文的，它会把中文变成一串串数字。这时仔细观察一下，我所做的全部变动都是在C语言作业这个目录下完成的，具体变动是删除了大量文件和增加了一些文件。</p><p>第一步，分别执行以下两句命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> <span class="hljs-literal">-r</span> C语言作业/<br><span class="hljs-variable">$</span> git add C语言作业/<br></code></pre></td></tr></table></figure><p>再一次查看状态 git status，发现一切的修改都已经提交到暂存区了<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2vktcrj20kk0cwqfy.jpg"></p><p>第二步，提交修改</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;我的修改&#x27;</span><br></code></pre></td></tr></table></figure><p>第三步，推送到远程仓库</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇总常用 Git 指令及用法</title>
      <link href="/2020/02/26/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
      <url>/2020/02/26/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code> 它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-meta"># 编辑Git配置文件</span><br>$ git config -e [--<span class="hljs-keyword">global</span>]<br><br><span class="hljs-meta"># 设置提交代码时的用户信息</span><br>$ git config [--<span class="hljs-keyword">global</span>] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--<span class="hljs-keyword">global</span>] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br><br><span class="hljs-meta"># 配置使用初始分支名 （本地默认为 master, GitHub 为 main）</span><br>$ git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">init</span>.defaultBranch &lt;名称&gt;<br></code></pre></td></tr></table></figure><h2 id="三、增加-x2F-删除文件"><a href="#三、增加-x2F-删除文件" class="headerlink" title="三、增加&#x2F;删除文件"></a>三、增加&#x2F;删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用场景：如果想要忽略已检入的文件，则必须在添加忽略该文件的规则之前取消跟踪它。以下操纵命令为从终端取消跟踪文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="六、撤销"><a href="#六、撤销" class="headerlink" title="六、撤销"></a>六、撤销</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 操纵速查表</title>
      <link href="/2020/02/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2020/02/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="普通模式下基本命令"><a href="#普通模式下基本命令" class="headerlink" title="普通模式下基本命令"></a>普通模式下基本命令</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除光标处字符</td></tr><tr><td><code>dd</code></td><td>删除一个词</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td><code>/search_text</code></td><td>检索文档，在文档后面的部分搜索 search_text</td></tr><tr><td><code>?search_text</code></td><td>检索文档，在文档前面的部分搜索 search_text</td></tr><tr><td><code>n</code></td><td>移动到后一个检索结果</td></tr><tr><td><code>N</code></td><td>移动到前一个检索结果</td></tr><tr><td></td><td></td></tr><tr><td><code>u</code></td><td>撤销最后的操作</td></tr><tr><td><code>Ctrl + r</code></td><td>重做最后撤销的操作</td></tr><tr><td></td><td></td></tr><tr><td><code>dd</code></td><td>删除当前行</td></tr><tr><td><code>d0</code></td><td>删除到行首</td></tr><tr><td><code>d$</code></td><td>删除到行末</td></tr><tr><td></td><td></td></tr><tr><td><code>h</code></td><td>光标向左移动一个字符</td></tr><tr><td><code>j</code> 或 <code>Ctrl + J</code></td><td>光标向下移动一行</td></tr><tr><td><code>k</code> 或 <code>Ctrl + P</code></td><td>光标向上移动一行</td></tr><tr><td><code>l</code></td><td>光标向右移动一个字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="进阶之复制和粘贴"><a href="#进阶之复制和粘贴" class="headerlink" title="进阶之复制和粘贴"></a>进阶之复制和粘贴</h1><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制当前行至存储缓冲区</td></tr><tr><td><code>[&quot;x]yy</code></td><td>复制当前行至寄存器 x</td></tr><tr><td><code>p</code>（小写）</td><td>在当前行之后粘贴存储缓冲区中的内容</td></tr><tr><td><code>P</code>（大写）</td><td>在当前行之前粘贴存储缓冲区中的内容</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 下的常用终端（terminal）命令总结</title>
      <link href="/2020/02/24/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/24/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><strong>简介：</strong></p><p><code>ls</code> 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一。</p><p>在终端里输入<code>ls</code>就可以查看文件和文件夹，但隐藏的文件就无法查看，使用<code>ls -a</code>即可。</p><p>“.” 代表当前目录，“..” 代表上一级目录，以 “.” 开头的文件为隐藏文件，需要用 -a 参数才能显示。</p><p><strong>ls常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><p><strong>ls 匹配通配符：</strong></p><p>与 DOS 下的文件操作类似，在 Unix&#x2F;Linux 系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>文件代表文件名中所有字符</td></tr><tr><td>ls te*</td><td>查找以 <code>te</code> 开头的文件</td></tr><tr><td>ls *html</td><td>查找结尾为 <code>html</code> 的文件</td></tr><tr><td>？</td><td>代表文件名中任意一个字符</td></tr><tr><td>ls ?.c</td><td>只找第一个字符任意，后缀为 <code>.c</code> 的文件</td></tr><tr><td>ls a.?</td><td>只找只有 3 个字符，前 2 字符为 <code>a.</code> ，最后一个字符任意的文件</td></tr><tr><td>[]</td><td><code>&quot;[”</code> 和 <code>“]”</code> 将字符组括起来，表示可以匹配字符组中的任意一个。<code>“-”</code> 用于表示字符范围。</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr><tr><td>ls [a-f]*</td><td>找到从 a 到 f 范围内的的任意一个字符开头的文件</td></tr><tr><td>ls a-f</td><td>查找文件名为 a-f 的文件,当 <code>“-”</code> 处于方括号之外失去通配符的作用</td></tr><tr><td>\</td><td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。<code>“?”</code> 和 <code>“*”</code> 处于方括号内时不用使用转义字符就失去通配符的作用。</td></tr><tr><td>ls *a</td><td>查找文件名为 <code>*a</code> 的文件</td></tr></tbody></table><h2 id="创建文件夹-x2F-目录"><a href="#创建文件夹-x2F-目录" class="headerlink" title="创建文件夹&#x2F;目录"></a>创建文件夹&#x2F;目录</h2><p>命令：<code>mkdir</code><br>使用说明：输入命令随后空格再输入目录名即可。<br>案例：创建一个 test 文件夹&#x2F;目录则对应命令就是<code>mkdir test</code></p><h2 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h2><p><code>cd</code> 命令进入目录比如要进入 test 目录则就是<code>cd test</code></p><h2 id="返回上一级目录"><a href="#返回上一级目录" class="headerlink" title="返回上一级目录"></a>返回上一级目录</h2><p>命令：<code>cd..</code></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>命令: <code>touch</code><br>笔者感觉这个命令还是挺靠谱的。Mac如果不用第三方工具（sublime等）是无法可视化创建一个txt文件。而用这个命令即可创建。<br>示例（创建一个test为名的 txt 文件）：<code>touch test.txt</code></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>命令：<code>cp</code><br>案例（拷贝一个 test.txt 文件并重新命名为test2.txt）：<code>cp test.txt test2.txt</code></p><h2 id="重命名或者移动文件"><a href="#重命名或者移动文件" class="headerlink" title="重命名或者移动文件"></a>重命名或者移动文件</h2><p>命令:   <code>mv</code><br>比如  (将一个 mountain.c  的 C 语言程序文件名字改成 mt.c )： <code>mv mountain.c mt.c</code></p><p>或者将 mountain.c 文件剪切到 code 文件夹下：<code>mv mountain.c code/</code></p><h3 id="批量修改文件名"><a href="#批量修改文件名" class="headerlink" title="批量修改文件名"></a>批量修改文件名</h3><p>例子：目录下有多个后缀为<code> .cpp</code> 的文件，我想让它们全部保留文件名的情况下修改成<code> .c</code> 后缀，这时可以结合 mv 命令和 shell 编程写个 for 循环，遍历每个文件然后依次更改。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">for i in *.cpp;do mv &quot;$i&quot; &quot;$&#123;i%.cpp&#125;.c&quot;;done<br></code></pre></td></tr></table></figure><p>模版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 把 xxx 换成要修改的文件名的后缀，yyy 换成替换输出的后缀即可。<br>for i in *.xxx;do mv &quot;$i&quot; &quot;$&#123;i%.xxx&#125;.yyy&quot;;done<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令：<code>find</code><br>案例（查找当前目录下所有的 txt 文件）：<code>find *.txt</code></p><p><strong>常用用法：</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>find .&#x2F; -name test.sh</td><td>查找当前目录下所有名为test.sh的文件</td></tr><tr><td>find .&#x2F; -name ‘*.sh’</td><td>查找当前目录下所有后缀为.sh的文件</td></tr><tr><td>find .&#x2F; -name “[A-Z]*”</td><td>查找当前目录下所有以大写字母开头的文件</td></tr><tr><td>find &#x2F;tmp -size 2M</td><td>查找在&#x2F;tmp 目录下等于2M的文件</td></tr><tr><td>find &#x2F;tmp -size +2M</td><td>查找在&#x2F;tmp 目录下大于2M的文件</td></tr><tr><td>find &#x2F;tmp -size -2M</td><td>查找在&#x2F;tmp 目录下小于2M的文件</td></tr><tr><td>find .&#x2F; -size +4k -size -5M</td><td>查找当前目录下大于4k，小于5M的文件</td></tr><tr><td>find .&#x2F; -perm 0777</td><td>查找当前目录下权限为 777 的文件或目录</td></tr></tbody></table><h2 id="显示当前的目录"><a href="#显示当前的目录" class="headerlink" title="显示当前的目录"></a>显示当前的目录</h2><p>命令：<code>pwd</code></p><h2 id="打开成可视化的文件夹"><a href="#打开成可视化的文件夹" class="headerlink" title="打开成可视化的文件夹"></a>打开成可视化的文件夹</h2><p>命令：<code>open</code><br>说明：如果是 <code>open</code>,则是打开当前命令里的目录，如果要打开指定的文件夹或者文件则格式为open要打开的路径即可。</p><h2 id="删除目录（空目录）"><a href="#删除目录（空目录）" class="headerlink" title="删除目录（空目录）"></a>删除目录（空目录）</h2><p>命令：<code>rmdir</code><br>案例：<code>rmdir test</code>（rmdir命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除目录（非空或者空目录都可以删除）推荐使用"><a href="#删除目录（非空或者空目录都可以删除）推荐使用" class="headerlink" title="删除目录（非空或者空目录都可以删除）推荐使用"></a>删除目录（非空或者空目录都可以删除）推荐使用</h2><p>命令： <code>rm -rf</code><br>案例：rm -rf test（rm -rf 命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>命令：<code>rm</code><br>案例（删除一个 test.txt 文件）：<code>rm test.txt</code><br>或者（删除所有后缀为 <code>.ttf</code> 的文件）：<code>rm *.ttf</code><br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u>，为了防止文件误删，可以在 <code>rm</code> 后使用 <code>-i</code> 参数以逐个确认要删除的文件。</p><p><strong><code>rm</code> 常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>以进行交互式方式执行</td></tr><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><h2 id="Terminal-光标移动快捷键"><a href="#Terminal-光标移动快捷键" class="headerlink" title="Terminal 光标移动快捷键"></a>Terminal 光标移动快捷键</h2><ul><li>将光标移动到行首：<code>control + a</code></li><li>将光标移动到行尾：<code>control + e</code></li><li>清除屏幕：<code>control + l</code>, 相当于手动输入<code>clear</code>并回车</li><li>搜索以前使用命令：<code>control + r</code></li><li>清除当前行：<code>control + u</code></li><li>清除至当前行尾：<code>control + k</code></li><li>单词为单位移动：<code>option + 方向键</code></li><li>光标向前 (Forward) 移动一个字符位置：<code>Ctrl + f</code></li><li>光标往回(Backward)移动一个字符位置：<code>Ctrl + b</code></li><li>删除一个字符，相当于通常的 Delete 键（命令行若无所有字符，则相当于 exit；处理多行标准输入时也表示eof：<code>Ctrl + d</code></li><li>退格删除一个字符，相当于通常的 Backspace 键：<code>Ctrl + h</code></li></ul><h2 id="文件管理有关"><a href="#文件管理有关" class="headerlink" title="文件管理有关"></a>文件管理有关</h2><h4 id="1-归档管理：tar"><a href="#1-归档管理：tar" class="headerlink" title="1. 归档管理：tar"></a>1. 归档管理：<code>tar</code></h4><p><strong>简介：</strong></p><p>计算机中的数据经常需要备份，tar 是 Unix&#x2F;Linux 中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。其实说白了，就是打包。</p><p><strong><code>tar</code> 使用格式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[参数]</span> 打包文件名 文件<br></code></pre></td></tr></table></figure><p><strong><code>tar</code> 常用参数：</strong></p><p>tar 命令很特殊，其参数前面可以使用“-”，也可以不使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>-v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>-f</td><td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td></tr><tr><td>-t</td><td>列出档案中包含的文件</td></tr><tr><td>-x</td><td>解开档案文件</td></tr></tbody></table><p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p><h4 id="2-文件压缩解压：gzip"><a href="#2-文件压缩解压：gzip" class="headerlink" title="2. 文件压缩解压：gzip"></a>2. 文件压缩解压：<code>gzip</code></h4><p><strong>简介：</strong></p><p>tar 与 gzip 命令结合使用实现文件打包、压缩。 tar 只负责打包文件，但不压缩，用 gzip 压缩 tar 打包后的文件，其扩展名一般用xxxx.tar.gz。</p><p><strong><code>gzip</code> 使用格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gzip  <span class="hljs-selector-attr">[选项]</span>  被压缩文件<br></code></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>解压</td></tr><tr><td>-r</td><td>压缩所有子目录</td></tr></tbody></table><p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 …</p><p><code>-z ：指定压缩包的格式为：file.tar.gz</code></p><p>解压用法： tar zxvf 压缩包包名</p><p><code>-z:指定压缩包的格式为：file.tar.gz</code></p><p>解压到指定目录：-C （大写字母“C”）</p><h4 id="3-文件压缩解压：bzip2"><a href="#3-文件压缩解压：bzip2" class="headerlink" title="3. 文件压缩解压：bzip2"></a>3. 文件压缩解压：<code>bzip2</code></h4><p><strong>简介：</strong></p><p>tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。</p><p>tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。</p><p>在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar -jcvf 压缩包包名 文件…(tar jcvf bk.tar.bz2 *.c)</p><p>解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</p><h4 id="4-文件压缩解压：zip-、unzip"><a href="#4-文件压缩解压：zip-、unzip" class="headerlink" title="4. 文件压缩解压：zip 、unzip"></a>4. 文件压缩解压：<code>zip</code> 、<code>unzip</code></h4><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><p>压缩文件：zip [-r] 目标文件(没有扩展名) 源文件</p><p>解压文件：unzip -d 解压后目录文件 压缩文件</p><h4 id="5-输出重定向命令：-gt"><a href="#5-输出重定向命令：-gt" class="headerlink" title="5. 输出重定向命令：&gt;"></a>5. 输出重定向命令：<code>&gt;</code></h4><p><strong>简介：</strong></p><p>Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p><p>注意： <code>&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部。</code></p><h4 id="6-分屏显示：more"><a href="#6-分屏显示：more" class="headerlink" title="6. 分屏显示：more"></a>6. 分屏显示：<code>more</code></h4><p><strong>简介：</strong></p><p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用 <code>more</code> 命令，每次只显示一页，按下空格键可以显示下一页，按下 <code>q</code> 键退出显示，按下 <code>h</code> 键可以获取帮助。</p><h4 id="7-文本搜索：grep"><a href="#7-文本搜索：grep" class="headerlink" title="7. 文本搜索：grep"></a>7. 文本搜索：<code>grep</code></h4><p><strong>简介：</strong></p><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。如果找到匹配模式， grep 打印包含模式的所有行。</p><p>grep一般格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grep <span class="hljs-selector-attr">[-选项]</span> ‘搜索内容串’文件名<br></code></pre></td></tr></table></figure><p>在 grep 命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p><p><strong><code>grep</code> 常用参数：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>grep 搜索内容串可以是正则表达式。</p><p><strong>grep 常用正则表达式：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt</td></tr><tr><td>ke$</td><td>行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt</td></tr><tr><td>[Ss]igna[Ll]</td><td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt</td></tr><tr><td>.</td><td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt</td></tr></tbody></table><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p>👉 <a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac">Mac 上“终端”中的键盘快捷键 - Apple 支持 (中国)</a> </p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 终端配置</title>
      <link href="/2020/02/23/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/02/23/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>终端 shell 工具用的是 <code>zsh</code>，具体怎么安装 zsh 这里省略。</p><p>需要用到代理设置软件 clashX ，Vim编辑器基本操作命令，http传输协议原理，zsh </p><p>关于系统用户目录下的.bashrc .bash_profile 和 .zshrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd ~<br>// bash 也就是 mac 默认的 shell 工具，配置文件为 .bashrc 和 .bash_profile<br>vim .bash_profile<br>// zsh 的配置文件为 .zshrc<br>vim .zshrc<br></code></pre></td></tr></table></figure><p>使用<code>zsh</code>作为默认<code>shell</code>工具的时候，它启动时并不会加载<code>bash</code>的这两个配置文件<code>.bashrc</code>和<code>.bash_profile</code>，而只会加载自己的配置文件<code>.zshrc</code>，为了让我们的配置文件生效，需要再做如下配置，来达到环境变量设置的永久生效。<strong>在<code>~/.zshrc</code> 文件最后增加一行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>如果不做上述设置，你就会发现，只有当你每次<code>source ~/.bash_profile</code>后才会生效，下次重新打开<code>zsh</code>窗口，还是不生效。</p><h2 id="2022-12-13"><a href="#2022-12-13" class="headerlink" title="2022-12-13"></a>2022-12-13</h2><p>有个需求需要用到 python 的 pandas 库，使用 pip 命令安装时发现下载不了报错！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Your proxy appears to only use HTTP and not HTTPS, try changing your proxy URL to be HTTP. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#https-proxy-error-http-proxy&#x27;, SSLError(SSLError(1, &#x27;[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1129)&#x27;)))&#x27;: /simple/pandas/<br></code></pre></td></tr></table></figure><p>大致看了一下是访问网络端口配置问题，这时我才发现代理订阅链接服务流量用完了，前几天从clashX换到备用的ShadowsocksX-NG使用，由于这两个代理工具分别设置的 http 和 sock 端口号不一致，所以得到 .bash_profile 文件里重新修改一下端口号，改为 ShadowsocksX-NG 所提供的端口号。</p><p><strong>由于经常使用终端进行下载一些国外源的库，就得让终端也代上理。</strong>进行代理之前得在 clashX 找“复制终端代理命令“的按钮，然后粘贴到终端运行就可以完成。<strong>但是使用 export 命令是临时的，为了防止下次打开终端需要重新复制命令运行，这时可以把命令放到一个终端配置文件 .bash_profile  中，让其每一次启动终端时就自动配好代理。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:1087<br>// 具体你的 http 和 sock5 端口号是多少，取决于你使用的代理工具，去查看就可以<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发环境部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
            <tag> Terminal </tag>
            
            <tag> oh-my-zsh </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/22/hello-world/"/>
      <url>/2020/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
