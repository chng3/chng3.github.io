<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/31/%E6%B5%B7%E9%97%A8%E8%80%81%E5%8C%BA%E4%B9%B0%E4%B8%89%E5%BA%93/"/>
    <url>/2022/07/31/%E6%B5%B7%E9%97%A8%E8%80%81%E5%8C%BA%E4%B9%B0%E4%B8%89%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="随意歌曲-海门老区买三库"><a href="#随意歌曲-海门老区买三库" class="headerlink" title="随意歌曲 - 海门老区买三库"></a>随意歌曲 - 海门老区买三库</h1><p>A：</p><p>加日有一班姿娘约哒去海门老区买三库</p><p>因人准备叫只摩托车 司机达三人坐唔落</p><p> 觉尾叫刀只滴滴赛搞明德圆</p><p>B： </p><p>一个看了条牛呀库，老板达条物略90银</p><p>三人听落到啊哈哈开</p><p>猛猛理行开</p><p>该淘宝看落到呀条物架45银 阿姿娘呀达哈输跟卡淘宝顶买啰</p><p>C：</p><p>出来呀崔落间奶茶铺，三人kio杯奶茶 福影理福点钟 喔古丽喔到五、六点</p><p>海门老区买三库～ 海门老区买三库～</p><p>作词：老三 老四</p><p>演唱：老四</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Lab4 (Link Lab) 实验步骤 - 来自舍友的文章</title>
    <link href="/2022/07/30/CSAPP-Lab4-Link-Lab-%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/30/CSAPP-Lab4-Link-Lab-%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul><li>ASCII码对照表</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783994155-2049d1eb-c9ab-4c14-a800-736bdc16c089.png" alt="img"></p><ul><li>文件十六进制编辑器</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install hexedit<br></code></pre></td></tr></table></figure><ul><li>查看程序ELF</li></ul><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">readelf -a <span class="hljs-attribute">&lt;文件&gt;</span><br></code></pre></td></tr></table></figure><ul><li>查看程序汇编代码和重定向目标</li></ul><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">objdump -dx <span class="hljs-attribute">&lt;文件&gt;</span><br></code></pre></td></tr></table></figure><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>要求：修改二进制可重定位目标文件“phase1.o”的数据节内容，使其与main.o链接后能够运行输出（且仅输出）自己的学号</p><p>编译运行看看输出的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783551709-f8b90f59-10f3-4343-9ca8-e50e03545f56.png" alt="img"></p><p>看到这种一大串乱七八糟的字符串，第一反应是直接用十六进制编辑器看文件的ASCII码有没有这一串字符串</p><p>使用十六进制编辑器查看文件：<code>hexedit phase1.o</code></p><p>找到该字符串的位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783948863-90d9bf97-9409-4429-a8d0-553ca3ff28a4.png" alt="img"></p><p>直接从字符串开头修改为自己的学号，并用ASCII码的 ‘&#x2F;0’ 结束，‘&#x2F;0’的十六进制是 <code>00</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640784529713-c5e57ae5-4e30-4d87-872e-3d7cff3c0186.png" alt="img"></p><p>在hexedit编辑器中，使用CTRL + X 快捷键保存修改的结果</p><p>再编译程序：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640784607901-f5fce52e-08a9-4e66-84b0-1902ea090bb7.png" alt="img"></p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>要求：根据强符号与弱符号的原则，判断符号表中的符号以及其所对应的数据区域。利用符号解析规则，创建生成一个名为“phase2_patch.o”的二进制可重定位目标文件</p><p>先编译phase2.o，看看输出的效果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> phase2<span class="hljs-selector-class">.o</span> -no-pie<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640869225822-89d5b194-e31e-45d2-b9c6-7b590795c650.png" alt="img"></p><p>是一串乱七八糟的文本，也推断不出它们的ASCII码，不能像第一题一样直接在文件中改字符串，</p><p>所以反汇编它的代码，尝试找到它输出的文本位置</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640869772837-d272a721-d990-47d0-b62b-c71f21592489.png" alt="img"></p><p>在do_phase2函数中，找到关键的汇编代码，其中call puts就是输出字符串的函数，输出的字符串地址为：0x60108a</p><p>往上看代码，看到把 0x601060 的地址放进myFunc函数计算，怀疑 0x60108a 的字符串内容 也经过 myFunc函数计算过。</p><p>于是再分析myFunc函数的汇编代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640870093347-62ebc97a-796e-4eef-bb59-1af6bb43b8d0.png" alt="img"></p><p>分析myFunc函数的汇编代码，原理是在一个 大小为256的char数组中经过如下运算生成字符串，</p><p>在这个例子中，这个char数组的起始地址就是：0x601060</p><p>为了找到这个char数组在原phase2.o中的重定向位置，方便我们接下来在phase2.o文件中修改这个数组</p><p>使用 <code>objdump -dx phase2.o</code> 查看重定向信息</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640877108454-4569048c-568b-4828-ac97-4e89848e59dc.png" alt="img"></p><p>（左边的终端是查看phase2.o的重定向信息，右边的终端是查看a.out的重定向结果）</p><p>为了更清晰描述phase2的汇编代码，将它的大概逻辑转换成c语言伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> g_myCharArray[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    g_myCharArray[i] = g_myCharArray[i] + (i &amp; <span class="hljs-number">0x1F</span>);<br>&#125;<br><br><span class="hljs-meta"># idx 在重定位表中找到</span><br><span class="hljs-built_in">puts</span>(g_myCharArray + idx);<br></code></pre></td></tr></table></figure><p>用<code>readelf -a phase2.o</code>查看文件，发现<code>g_myCharArray</code>数组变量是弱符号，</p><p>并且它的类型为COM，即未初始化或初始化为0的全局变量。</p><p>弱符号可以被强符号覆盖，意思是只要在链接的时候出现同名的强符号变量就可以覆盖它，强符号变量就是有初始化值的变量。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640785499062-f99537e2-1731-4b32-8543-2dea59cc894a.png" alt="img"></p><p>要想输出自己的学号，先在重定位表中找到从数组的哪个位置输出：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878154861-0de3812a-5985-4d51-b076-a3cd35eefce2.png" alt="img"></p><p>找到偏移量是2a，十进制为42，所以程序是从数组g_myCharArray[42]输出，数组下标是42，我们学号也要经过一系列计算后写到这个位置上。</p><p>下面开始计算学号的存放到数组中的值。简而言之：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">存放到数组中的值 = 学号ASCII码 - （下标 <span class="hljs-meta">&amp; 0x1F）</span><br></code></pre></td></tr></table></figure><p>学号第一个位置的偏移量是2a，那么：</p><p>2a &amp; 0x1F &#x3D; 0xA (十六进制) &#x3D; 10 （十进制）</p><p>往后位置的数值就是递增的：10  11  12  13 ….</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640879817903-298d3b1a-cf13-4bb8-bcdc-02cee07a9b68.png" alt="img"></p><p>另外还需要写入字符 ‘&#x2F;0’的ASCII码作为字符串的结束符</p><p>‘&#x2F;0’字符写入的数组下标 &amp; 0x1F 的结果是 21</p><p>只要将这个值与一个整数相加，溢出char类型的最大表示范围，就可以得到0</p><p>举例：21 + 235 &#x3D; 256  &gt; 255(char类型最大表示范围)</p><p>所以，‘&#x2F;0’字符写入到数组对应的数值是235。</p><p>新建一个phase2_patch.c，写入一个同名的char g_myCharArray[256]，</p><p>从数组g_myCharArray[42]写入经过计算后的学号值。还要再写入经过计算后的‘&#x2F;0’结束符的值。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878100749-30744963-39b1-4429-9f4a-52799dc5ebb7.png" alt="img"></p><p>编译这个文件，然后输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878355553-03ec2022-1cdb-4f71-b58c-5688b2ae19a1.png" alt="img"></p><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>检查反汇编代码，定位模块中的各组成函数并推断其功能作用。 根据反汇编程序的执行逻辑，修改函数中的机器指令（用自己指令替换函数体中的nop指令）以实现期望的输出。</p><p>先编译程序：<code>gcc main.o phase3.o -no-pie</code></p><p>再分析编译后的程序的汇编代码：<code>objdump -d a.out</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786357367-4db926f4-5f79-4052-a710-7c63aa9425fb.png" alt="img"></p><p>除了do_phase3还有myFunc1、myFunc2函数，这题是让我们定位模块中的各组成函数并推断其功能作用。 根据反汇编程序的执行逻辑，修改函数中的机器指令。</p><p>分析程序得出结论：需要修改do_phase3的nop指令为如下结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0000000000400550</span> &lt;do_phase3&gt;:<br>  <span class="hljs-number">400550</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">400551</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-number">400554</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400555</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400556</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400557</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400558</span>:e8 e1 ff ff ff       callq  <span class="hljs-number">40053</span>e &lt;myFunc2&gt;<br>  <span class="hljs-number">40055</span>d:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-number">400560</span>:e8 be ff ff ff       callq  <span class="hljs-number">400523</span> &lt;myFunc1&gt;<br>  .....<br></code></pre></td></tr></table></figure><p>它们的汇编特征码如下：</p><p>55 48 89 e5   90 90 90 90   E8 E1 FF FF   FF 48 89 C7   E8 BE FF FF   FF</p><p>分析完a.out的行为，就要在phase3.o中修改对应的汇编代码，才可以生效。</p><p>使用<code>objdump -dx phase3.o</code>查看这个函数在phase3.o的.text位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881232940-6f23ea20-df4d-410f-87d1-dcae86c7aa30.png" alt="img"></p><p>使用<code>readelf -a phase3.o</code>找到.text在静态文件中的偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881400547-de5f7145-5884-41d4-a417-763c2c2b0710.png" alt="img"></p><p>所以计算do_phase3函数在phase3.o的静态文件偏移是：</p><p>0x40 + 0x2d &#x3D; 0x6D</p><p>使用<code>hexedit phase3.o</code>修改0x6D位置开始的数据：</p><p>55 48 89 e5   90 90 90 90   E8 E1 FF FF   FF 48 89 C7   E8 BE FF FF   FF</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881783650-995a09b2-446a-4628-bebe-e7e0a7418c7f.png" alt="img"></p><p>在a.out的汇编代码中，myFunc2中这个地址就是字符串数组的起始地址，在这个地址中输入自己的学号就可以通过此关</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786737987-10961ffb-7c2b-4654-a45b-d8eb61384416.png" alt="img"></p><p>需要从phase3.o中找到它的位置。</p><p>使用<code>objdump -dx phase3.o</code>查看这个函数下的重定位信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640880914937-c77dd996-0557-4f7e-8cbb-60ac42c6d9ea.png" alt="img"></p><p>使用<code>readelf -a phase3.o</code>也同样可以看到</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786872855-3df015ae-319c-40c3-a2c5-488338459c7a.png" alt="img"></p><p>重定向的偏移是.data + c</p><p>找.data的静态文件偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786934738-87c85d45-dd7c-47dc-b515-3087e1215ec3.png" alt="img"></p><p>所以在静态文件偏移 1a0 + c  &#x3D; 1AC 这个地址就是数组起始地址，在这个地址中修改为自己的学号</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640882364964-3316b538-8fff-4765-9bf1-2169f96c0712.png" alt="img"></p><p>输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640882441514-81cc76ee-a2ef-4b8d-b56c-8434511e5e9c.png" alt="img"></p><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><p>要求：修改二进制可重定位目标文件“phase4.o”中重定位节    和数据节中的内容，使其与main.o链接后能够运行输出（且仅输出）自己的学号，本阶段学生所拿到的.o文件中的“重定位位置”信息已经被抹除，学生需要根据实际情况确认冲重定位的发生位置，并根据重定位类型对位置信息进行恢复。</p><p>查看被抹除的重定位信息:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> phase4<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640787620308-10254a3c-f9c5-4227-9d9c-ab70e0a7fe41.png" alt="img"></p><p>发现3个位置被抹除。</p><p>反汇编查看.text段的重定向信息及汇编内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -dx phase4.o<br></code></pre></td></tr></table></figure><p>根据汇编指令特点，猜测代码思路，使得程序修复重定位地址后可以正常运行:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640787772002-8a8943f8-e6d7-41cd-86ea-5626cd03b98c.png" alt="img"></p><p>R_X86_64_PC32类型  为 相对地址偏移，重定位一个使用32位PC相对地址的引用</p><p>R_X86_64_32S类型  为 绝对地址偏移，重定位一个使用32位绝对地址的引用</p><p>应该改为如下的重定位位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641276697837-37caf36f-4d92-4f75-a753-5f78c904fc69.png" alt="img"></p><p>修复重定位信息：</p><p>使用<code>readelf -a phase4.o</code>查看”.rela.text”段</p><p><strong>“.rela.text”是重定位信息段，它在静态文件的偏移是 0x250</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641278110225-e67c7999-23ef-412c-a71e-75ece807cff7.png" alt="img"></p><p><strong>“.rela.text”每一条重定位数据都是一个结构体，</strong></p><p><strong>结构体定位文件可以在</strong><code>/usr/include/elf.h</code><strong>中看到</strong></p><p><strong>“.rela.text”结构体内容如下：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641278518628-a84ca7d4-e9eb-46d7-b302-5df2eeab6953.png" alt="img"></p><p>使用<code>hexedit phase3.o</code>修改<strong>静态文件的偏移 0x250</strong>位置的结构体数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641279135178-bc9edd39-65c2-47ed-9055-1fe2751b278a.png" alt="img"></p><p>分析.data段的学号写入位置：</p><p>首先分析do_phase函数的汇编代码，计算第一条重定向数据的相对偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641320345924-ac83bb96-aa5c-422d-a808-237f30b547b4.png" alt="img"></p><p>.text段在文件中的偏移是0x40，所以第一条重定向在文件中的偏移是0x46，</p><p>.data段在文件中的偏移是0x60</p><p>所以第一条重定向的相对偏移是：(.data + 0x10) - 0x46  &#x3D;  0x60 + 0x10 - 0x46 &#x3D;   0x2A</p><p>又因为下一条指令在静态文件的地址是0x4a</p><p>所以得到的绝对地址是：0x4a + 0x2A &#x3D; 0x74</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321035870-85df389e-0d47-4b89-a9a6-f5c0b9a8b3e4.png" alt="img"></p><p>静态文件 0x74 位置上的数值是<strong>0x3F</strong></p><p>根据do_phase的汇编代码流程，学号写入位置应该是：0x3F &amp; 0x7 + .data &#x3D; 0x3F &amp; 0x7 + 0x60 &#x3D; <strong>0x67</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321456359-d5cd2717-bde6-480d-a523-14cc089005bc.png" alt="img"></p><p>输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321537765-f53cc6e6-9603-4b75-bfde-c5a2460c096a.png" alt="img"></p><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><p>要求：修改二进制可重定位目标文件“phase5.o”中重定位节和数据节的内容，使其与main.o链接后能够正确输出（且仅输出）自己学号</p><p>反汇编先分析完整的程序逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> phase5<span class="hljs-selector-class">.o</span> -no-pie<br>objdump -d <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>发现myFunc是关键函数</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788319784-fbe2008e-cd4b-4d68-88d6-502b3335736a.png" alt="img"></p><p>再查看该内存的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788388281-577f94c6-758d-48f0-96a9-0888e29de038.png" alt="img"></p><p>整理程序逻辑：</p><p>程序判断g_guard变量是否为0，如果不为零输出0x0x601030地址中的“hhhhh”字符串，如果变量为0输出0x0x601040地址中的“000000000000”字符串，程序里的g_guard变量始终为1，所以总是输出了“hhhhh”字符串。</p><p>我们的解题思路是不修改g_guard变量值的情况下，把这两者的重定向绝对地址互换，然后修改0x0x601040地址中的“000000000000”字符串为自己的学号。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788962102-d507d615-9c1c-40d4-90dc-fa3ac205ec57.png" alt="img"></p><p>以上是分析可执行文件a.out的流程，实际上要修改phase5.o文件的重定位信息才可以生效。</p><p>两个变量的重定向顺序在phase5.o中找到，所以开始分析phase5.o</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -dx phase5.o<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640789268085-ae6430b3-f75d-438a-9061-f494af4d55ab.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> phase5<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640789347851-e55ef930-92f2-48bc-b875-a2682c631158.png" alt="img"></p><p>修改<code>.rela.text</code>段中 20 与 2c 互换，再修改<code>.data + 10</code>的内存数据为学号即可</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322096307-a0449a69-1e81-4611-8ac4-320433823d40.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322162423-435af911-4ebd-4846-ab1d-fdc734d43357.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322191877-1b699192-dc6e-44ec-9f36-4bc60b5f245f.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP lab2 (Bomb Lab) 反汇编拆炸弹总结 - 来自舍友的文章</title>
    <link href="/2022/07/30/CSAPP-lab2-Bomb-Lab-%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8B%86%E7%82%B8%E5%BC%B9%E6%80%BB%E7%BB%93-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/30/CSAPP-lab2-Bomb-Lab-%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8B%86%E7%82%B8%E5%BC%B9%E6%80%BB%E7%BB%93-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>实验程序下载地址（官网）：<a href="http://csapp.cs.cmu.edu/2e/labs.html">http://csapp.cs.cmu.edu/2e/labs.html</a></p><p>每一关要通过反汇编分析出正确的字符串才能过关，否则弹出bomb！！程序停止运行</p><p>一共有6个炸弹和一个隐藏炸弹。</p><p>我们学校为了防止同学们互相抄作业，每个人得到的炸弹都不一样，其实就是每一关都有3种不同的情况（除了第一关和隐藏炸弹那一关），于是我把每一关每一种情况都做了一遍。结合每一关的指令特征码写了一个自动拆炸弹的程序，能拆我们学校发下来的炸弹，其它学校的炸弹不一定能拆。</p><p>百度云盘下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/1j-FS0X6NlOwTqPv8j6a7sg">https://pan.baidu.com/s/1j-FS0X6NlOwTqPv8j6a7sg</a> </p><p>提取码：mrf2</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><strong>便于我们分析，首先要反汇编程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">objdump -d bomb &gt; bomb.<span class="hljs-keyword">asm</span><br></code></pre></td></tr></table></figure><p>得到一个bomb.asm文件就是我们的程序汇编代码</p><p><strong>使用Linux下的反汇编调试器分析代码：</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb bomb</span><br></code></pre></td></tr></table></figure><p>未接触过gdb还需要额外学习gdb的用法</p><p><strong>查看程序ELF结构：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> bomb<br></code></pre></td></tr></table></figure><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>输入一个字符串，比较输入的字符串和保存的字符串是否相等。</p><p>思路：</p><p><code>callq  16fc &lt;strings_not_equal&gt;</code> 就是比较两个字符串是否相等的函数，</p><p>两个字符串通过参数传递到函数中，</p><p>其中%rdi就是自己输入的字符串，%rsi就是正确的字符串</p><p>进入函数，单步执行完<code>lea    0x16a1(%rip),%rsi</code>  语句后，</p><p>输入%rsi的值就是答案（在gdb中使用<code>x/s %rsi</code>输出）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637993820059-04fa4b30-23ec-49cc-83f0-0b0b23d7b4f7.png" alt="img"></p><hr><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>输入6个数，判断6个数之间的规律</p><h3 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637995926316-2478a818-ca1b-4353-960b-373040627926.png" alt="img"></p><p>第一个参数必须为1，且下一个参数是上一个参数的两倍。</p><p>答案：1 2 4 8 16 32</p><h3 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637999823800-76ef6a3c-8dbd-46ad-a1a2-d64b721c7e2f.png" alt="img"></p><p>第一个参数不能为负数，且 上一个参数的值 + 上一个参数的位置（从1开始） &#x3D; 下一个参数的值</p><p>答案：0 1 3 6 10 15  或 1 2 4 7 11 16 或 2 3 5 8 12 17 等等….</p><h3 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638000293402-9184a3d4-60b7-4566-965d-ad7f42089c07.png" alt="img"></p><p>第一个参数必须为0，第二个参数必须为1，接下来的参数规律为 </p><p>参数的值 &#x3D; 上一个参数的值 + 上上一个参数的值</p><p>即斐波那契数列: n &#x3D; (n-1) + (n-2)</p><p>答案：0 1 1 2 3 5</p><hr><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>输入两个整数，根据第一个整数的值跳转到指定的地址，执行一系列的算术计算得到第二个参数的值。</p><h3 id="情况一：-1"><a href="#情况一：-1" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638005343767-ed5287d8-42f9-4d01-91ab-d26a42b1a362.png" alt="img"></p><p>要求输入3个参数，sscanf函数要求的格式为%d %c %d，</p><p>这格式在汇编语句<code>lea    0x1657(%rip),%rsi</code>中说明了。执行到该语句时输出%rsi就能看到：</p><p>在gdb中输出rsi的语句：<code>x/s $rsi</code></p><p>经过参数1算出来的地址，跳转到该地址执行指令，再判断第二、第三参数的值</p><h3 id="情况二：-1"><a href="#情况二：-1" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638025795686-53b8b1f8-5768-4879-bb87-d53ca8d764d3.png" alt="img"></p><p>要求输入两个整数，经过参数1算出来一个地址，</p><p>跳转到该地址执行一系列加减指令，得到第二个参数的值</p><h3 id="情况三：-1"><a href="#情况三：-1" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638033265815-3284499c-d01a-4f95-8da6-fba2ee940251.png" alt="img"></p><p>要求输入两个整数，经过参数1算出来一个地址，</p><p>跳转到该地址执行mov 某个值, eax指令，eax就是第二个参数的值</p><hr><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>考察递归函数，要求输入两个整数，其中第一个参数进入一个递归函数进行计算，得到的结果作为第二个参数的值</p><h3 id="情况一：-2"><a href="#情况一：-2" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179323867-46a10cc3-763b-4a61-8cc0-99f87eaf2359.png" alt="img"></p><p>要求输入两个整数，第一个参数必须小于等于14，然后传第一个参数进入func4()进行计算，func4是一个递归函数，</p><p>计算出来的结果必须等于第二个参数的值。</p><p>比如这个举例中的计算出来的结果要求必须等于7，也就是要求第二个参数必须是7</p><p>phase_4还有可能是下面这种情况：第一个参数进入func4递归函数计算的结果等于第二个参数，要求第二个参数必须是0</p><p>汇编代码有一点点出入</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638203125462-f57a0205-6c3d-45c9-aa96-39a66d335992.png" alt="img"></p><p>下面分析一下func4的函数：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179797742-63ca9457-94d6-40c5-ae12-cb407246f654.png" alt="img"></p><p>因为是跟踪递归函数，分析起来特别绕，就还原成c语言代码的样子来看这个递归函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4_1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-type">int</span> sub = c - b;<br>    <span class="hljs-type">int</span> tmp = (sub &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 取c-b后的最高位符号位的值  c-b&gt;=0时是0， c-b&lt;0时是1</span><br>    tmp += sub;     <span class="hljs-comment">// 加一次c-b的结果</span><br>    tmp &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// tmp / 2</span><br><br>    tmp += b;<br><br>    <span class="hljs-keyword">if</span> (tmp &lt;= a)&#123;<br>        <span class="hljs-keyword">if</span> (tmp == a) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// tmp &lt; a</span><br>        <span class="hljs-keyword">return</span> func4_1(a, tmp + <span class="hljs-number">1</span>, c) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> func4_1(a, b, tmp - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是还原成c语言代码后，仍然无法找到这个递归函数的规律，所以没头绪根据第二个参数的值来逆推第一个参数的值</p><p>于是就想到了暴力的方法：</p><p>因为第一个参数最多只能是 0 ~ 14，就尝试将这15个值依次传给func4函数，直到func4函数计算的返回值对上了第二个参数就行…那个就是答案</p><p>暴力破解代码：（res1、res2就是参数1和参数2）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">14</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (func4_1(i, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>) == res2)&#123;<br>        res1 = i;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="情况二：-2"><a href="#情况二：-2" class="headerlink" title="情况二："></a>情况二：</h3><p>与情况一十分类似，phase_4函数与情况一的一样，但是情况二func4的汇编与情况一func4有点出入：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638240086148-c97c58c4-fbfe-42a2-9ae7-889959406475.png" alt="img"></p><p>还原成c语言代码后是这样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4_2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-type">int</span> sub = c - b;<br>    <span class="hljs-type">int</span> tmp = (sub &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 取c-b后的最高位符号位的值  c-b&gt;=0时是0， c-b&lt;0时是1</span><br>    tmp += sub;     <span class="hljs-comment">// 加一次c-b的结果</span><br>    tmp &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// tmp / 2</span><br><br>    tmp += b;<br><br>    <span class="hljs-keyword">if</span> (tmp &lt;= a)&#123;<br>        <span class="hljs-keyword">if</span> (tmp == a) <span class="hljs-keyword">return</span> tmp;<br>        <span class="hljs-comment">// tmp &lt; a</span><br>        <span class="hljs-keyword">return</span> func4_2(a, tmp + <span class="hljs-number">1</span>, c) + tmp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> func4_2(a, b, tmp - <span class="hljs-number">1</span>) + tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解题思路跟情况一一样"><a href="#解题思路跟情况一一样" class="headerlink" title="解题思路跟情况一一样"></a>解题思路跟情况一一样</h6><h3 id="情况三：-2"><a href="#情况三：-2" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638530459022-d9bb7092-02f7-4757-a039-075515471207.png" alt="img"></p><p>要求输入两个整数，其中第一个参数的值存在到(%rsp + 4)，第二个参数的值存放到(%rsp)</p><p>第二个参数的值 必须大于2等于2 且 小于等于4</p><p>然后传 <strong>第二个参数</strong> 进入func4()递归函数进行计算，</p><p>计算出来的结果必须等于 <strong>第一个参数</strong> 的值。</p><p>func4函数汇编代码:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638201039649-3bb51edb-49bd-4461-8d02-fdc6bb07f037.png" alt="img"></p><p>由func4函数汇编代码尝试逆向还原为c语言代码的样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">return</span> b + func4(a - <span class="hljs-number">1</span>, b) + func4(a - <span class="hljs-number">2</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h1><p>考察数组操作。</p><h3 id="情况一：-3"><a href="#情况一：-3" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638260239080-33c957c1-67c3-4549-8ebf-48554ed6bcba.png" alt="img"></p><p>要求输入6个字符，取输入的6个字符的ascii码，每一个字符 &amp; 0xf，得到的值作为下标idx，在一个字符数组中获取该下标idx所在的字符，6个字符一共获取6次，拼凑成一个长度为6的字符串，该字符串要和答案字符串相等，即可通过。</p><p>字符数组其实就是上面汇编代码中指出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14d0</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">0</span>d <span class="hljs-number">69</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1469(%rip),%rcx        # <span class="hljs-number">2940</span> &lt;array.<span class="hljs-number">3416</span>&gt;<br></code></pre></td></tr></table></figure><p>执行到该行代码时，输出一下该字符数组的内容:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261126691-a164de85-22b6-4600-a8cd-1ebb22676b96.png" alt="img"></p><p>我们能取得长度一共16个字符，其中红色框中划起来的就是这个字符数组的内容，</p><p>为什么只能取16个字符？</p><p>因为 我们输入的字符 &amp; 0xf 的数组下标能表示范围是  0 - 15</p><p>最终拼接出来的字符串要和答案字符串比较，答案字符串存放在：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14fa</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">35</span> <span class="hljs-number">16</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1416(%rip),%rsi        # <span class="hljs-number">2917</span> &lt;_IO_stdin_used+<span class="hljs-number">0</span>x1b7&gt;<br></code></pre></td></tr></table></figure><p>输出该字符串的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261852489-bba418f7-1eaa-466d-8fba-a6c4c9d58065.png" alt="img"></p><p>注意：例子中的 0x0000555555556917 地址为程序加载到内存后，上面指令计算出来的%rsi地址。每次运行时的地址都会不同。</p><p>整个phase_5的流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>[] in = <span class="hljs-string">&quot;abcdef&quot;</span>;    # 假设输入的是这<span class="hljs-number">6</span>个字符<br><span class="hljs-type">char</span>[] str = <span class="hljs-string">&quot;maduiersnfotvbyl&quot;</span>;# 假设字符数组是这样<br><span class="hljs-type">char</span>[<span class="hljs-number">7</span>] result;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>; idx &lt; <span class="hljs-number">6</span>; idx++)&#123;<br>result[i] = str[in[idx] % <span class="hljs-number">15</span>];<br>&#125;<br><br><span class="hljs-comment">// result字符串跟答案字符串相同就通过</span><br></code></pre></td></tr></table></figure><hr><h3 id="情况二：-3"><a href="#情况二：-3" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263253652-47fb215a-e86e-4d52-9175-edae596c7b62.png" alt="img"></p><p>要求输入6个字符，取输入的6个字符的ascii码，每一个字符 &amp; 0xf 得到的值作为<strong>下标idx</strong>，在一个整数数组中获取这个<strong>下标idx</strong>所在的值，将它们累加起来，一共累加6次，累加得到的整数结果与某个常数值判断相等，即可通过。</p><p>其中整数数组的部分内容长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263031586-8d27b2e8-cb48-4540-b1cb-c9a42f24f95e.png" alt="img"></p><p>phase_5的主要流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>[] in = <span class="hljs-string">&quot;abcdef&quot;</span>;    # 假设输入的是这<span class="hljs-number">6</span>个字符<br><span class="hljs-type">int</span>[] <span class="hljs-built_in">array</span> = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">13</span>&#125;;# 整数数组<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>; idx &lt; <span class="hljs-number">6</span>; idx++)&#123;<br>result += <span class="hljs-built_in">array</span>[in[idx] &amp; <span class="hljs-number">0xF</span>];<br>&#125;<br><br><span class="hljs-comment">// result字符串跟某个常数值相同就通过</span><br></code></pre></td></tr></table></figure><hr><h3 id="情况三：-3"><a href="#情况三：-3" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638272059649-c2d07443-7d49-478f-b73c-e766d5bced82.png" alt="img"></p><p>要求输入两个整数值，参数1的值不能为15， 参数1 &amp; 0xf 得到的值作为一个下标idx，用这个下标idx从一个整数数组中获取值，</p><p>在条件循环中 获取 整数数组[idx] 的值，将这个值累加起来，</p><p>直到 整数数组[idx] &#x3D;&#x3D; 15时跳出循环。跳出循环后，要求循环的执行次数为15次、而且累加数等于第二个参数就可以通过。</p><p>其中整数数组的部分内容长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638320131960-388acabe-e4a1-43ad-8832-cbb84008ecda.png" alt="img"></p><p>phase_5的主要流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b;   <span class="hljs-comment">// 假如a,b为输入的两个整数值 参数1，参数2</span><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp = a &amp; <span class="hljs-number">0xf</span>;<br><br><span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">15</span>) bomb();<br><br><span class="hljs-keyword">do</span>&#123;<br>    cnt++;<br>    tmp = nums[tmp];<br>sum += tmp;<br>&#125;<span class="hljs-keyword">while</span>(tmp != <span class="hljs-number">15</span>);<br><br><span class="hljs-keyword">if</span>(cnt != <span class="hljs-number">15</span>) bomb();<br><span class="hljs-keyword">if</span>(sum != b) bomb();<br><br><span class="hljs-comment">// 到这里就通过</span><br></code></pre></td></tr></table></figure><hr><h1 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h1><p>这一题是链表元素排序题，输入6个整数，要求都必须小于等于6，根据输入的数进行链表元素排序。</p><p>分三种情况，</p><p>一种是要求链表元素从大到小排序</p><p>一种是要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。</p><p>一种是要求链表元素从小到大排序</p><p>这题汇编代码量有亿点点长，但实际上三种情况的大部分汇编代码都相符，只需要弄懂其中一种情况的代码，其它两种就迎刃而解了。所以这里只展开说情况一，情况二、三简单描述。</p><p>解答这种大量汇编代码的题需要自己画一遍指令跳转图，关键地方写注释，分清楚每个部分的作用。</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>输入6个整数，要求链表按照这6个整数排序后，链表元素从大到小排序</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638426652892-e8086171-d1ce-4aa3-af53-dd9ffe3ab29a.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638434110608-53d2e8d0-dcb0-48ba-8ef7-a98f7f20e024.png" alt="img"></p><p>在上面汇编代码中，核心的逻辑是将6个链表根据输入的值排序，然后判断排序的顺序是不是由大到小。</p><p>解题技巧是：只需要输出整个链表的各个值，依次写出排序顺序即可。</p><p>比如上面的例子，链表的地址在如下汇编代码中给出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">153e</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">15</span> cb <span class="hljs-number">2</span>c <span class="hljs-number">20</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x202ccb(%rip),%rdx     # <span class="hljs-number">204210</span> &lt;node1&gt;     ！！！第一个链表节点的位置<br></code></pre></td></tr></table></figure><p>在gdb下, 程序加载到内存中，所以看到的链表地址是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638428995222-02f14e0e-1670-40b0-b56d-8238de8006f2.png" alt="img"></p><p>在这个例子中，链表的地址是<code>0x555555758210</code></p><p>在gdb中输出这个链表，看看链表的结构如何，使用命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>/<span class="hljs-keyword">x</span> <span class="hljs-number">0x0000555555758210</span><br></code></pre></td></tr></table></figure><p>输入这个命令后继续按回车，就会查看这个链表的往下几个字节：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638429359817-d5cda132-6058-4cf1-b714-b59acff31273.png" alt="img"></p><p>根据上图的值，推断这个链表的c语言定义体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> value; <span class="hljs-comment">// 链表元素值</span><br>    <span class="hljs-type">uint32_t</span> num;  <span class="hljs-comment">// 链表编号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 链表下一个节点指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>先拿出每个元素的值</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432119589-02b2ecee-5f68-4309-b074-4161ec39ebaa.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432203079-27b42637-7aa3-4fa4-a81a-e3ca512810d0.png" alt="img"></p><p>注意上图没有node6节点，它的地址在node5的next指针中可以看到，输出该地址的值就可以看到。</p><p>在gdb中输入指令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>/<span class="hljs-keyword">x</span> <span class="hljs-number">0x0000555555758110</span><br></code></pre></td></tr></table></figure><p>注意，next指针地址占8个字节，且在小端模式的机器中运行，</p><p>所以next指针地址应该看做<code>0x0000555555758110</code>，而不是<code>0x5575811000005555</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432412756-44bea54a-cc61-4e69-bc45-08ddc46f96e1.png" alt="img"></p><p>将6个节点的值汇总起来，并找出它们的大小关系</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从大到小排第几</td><td>5</td><td>1</td><td>4</td><td>3</td><td>6</td><td>2</td></tr></tbody></table><p>链表由大到小依次的顺序是:</p><p>node2-&gt; node6 -&gt; node4 -&gt; node3 -&gt; node1 -&gt; node5</p><p>所以这题的答案是：</p><p><strong>2 6 4 3 1 5</strong></p><hr><h3 id="情况二：-4"><a href="#情况二：-4" class="headerlink" title="情况二："></a>情况二：</h3><p>输入6个整数，要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。</p><p>情况二和情况一相比只有几点不同的地方，这两者的部分汇编代码比较如下图：（红色字体为两者不同的地方）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638437654331-c5d0102b-e8c2-4c23-82b0-982fb7d5b4bb.png" alt="img"></p><p>因为情况一和情况二思路差不多，以情况一的链表作为例子，首先得到每个元素的值：</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从大到小排第几</td><td>5</td><td>1</td><td>4</td><td>3</td><td>6</td><td>2</td></tr></tbody></table><p>链表由大到小依次的顺序是:</p><p>node2-&gt; node6 -&gt; node4 -&gt; node3 -&gt; node1 -&gt; node5</p><p>得到这6个排序的顺序值是：</p><p><strong>2 6 4 3 1 5</strong></p><p>排序规则是 7 - 某个数 &#x3D; 顺序值</p><p>2 &#x3D; 7 - <strong>5</strong></p><p>6 &#x3D; 7 - <strong>1</strong></p><p>4 &#x3D; 7 - <strong>3</strong></p><p>3 &#x3D; 7 - <strong>4</strong></p><p>1 &#x3D; 7 - <strong>6</strong></p><p>5 &#x3D; 7 - <strong>2</strong></p><p>所以得到这题答案是：</p><p><strong>5 1 3 4 6 2</strong></p><hr><h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><p>输入6个整数，要求链表按照这6个整数排序后，链表元素从小到大排序</p><p>情况三与情况一，两者只有比较大小的指令不同</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638442032597-7c9ad575-3093-4a0d-aa1f-f3c16faf21df.png" alt="img"></p><p>以情况一的链表作为例子，得到每个元素的值，列出从小到大的顺序：</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从小到大排第几</td><td>2</td><td>6</td><td>3</td><td>4</td><td>1</td><td>5</td></tr></tbody></table><p>链表由小到大依次的顺序是:</p><p>node5-&gt; node1 -&gt; node3 -&gt; node4 -&gt; node6 -&gt; node2</p><p>所以这题答案是：</p><p><strong>5 1 3 4 6 2</strong></p><hr><h1 id="隐藏炸弹"><a href="#隐藏炸弹" class="headerlink" title="隐藏炸弹"></a>隐藏炸弹</h1><p>在做完第6关的炸弹后，发现phase_6的汇编代码后面还有一个函数叫<strong>secret_phase</strong></p><p>翻译一下就是隐藏的炸弹，这就是lab2中大名鼎鼎的隐藏炸弹函数了，</p><p>似乎要某种方式才能触发它，所以根据这个函数名找找哪个函数调用了它。</p><p>在反汇编代码中查找该函数名，发现整个程序中只有在<strong>phase_defused</strong>函数中调用了它，再查找一下谁调用了phase_defused函数</p><p>发现每通过一关都会调用一次phase_defused函数：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542390671-24d63361-2587-477b-8694-bc7bf1c0ae0a.png" alt="img"></p><p>于是分析一下phase_defused函数的作用：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638541193669-0c887ebf-c44c-4b3d-bb8e-551f00dbd6b8.png" alt="img"></p><p>每调用read_line函数，num_input_strings变量+1，num_input_strings变量可以理解为已经通过了第几关。</p><p>上图中说明这个函数大概意思是：在通过第6关后，会判断我们曾在第4关输入的内容，输入格式是 %d %d %s，</p><p>也就是说第四关除了输入两个整数以外，还要输入一个字符串，这个字符串就是进入隐藏函数的密钥。</p><p>使用gdb进入<strong>phase_defused函数</strong>输出一下这个密钥：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542129506-1760b0b3-9c5d-4d3e-bc54-f6049acbed0f.png" alt="img"></p><p>这个密钥是：<strong>DrEvil</strong></p><p><strong>（尽管每个人的前6关炸弹会有不同情况，但进入隐藏炸弹的密钥似乎大家都一样）</strong></p><p>所以如果想进入隐藏炸弹函数，就在原来的第四关通关答案中加入<strong>DrEvil</strong>字符串。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542570949-9db49ab7-54ec-4c6c-9c55-958e1be8b312.png" alt="img"></p><p>分析完如何进入隐藏炸弹后，开始分析隐藏炸弹的汇编代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638543600054-fb855f45-6a4b-4656-a70c-8c9eaacac98a.png" alt="img"></p><p>隐藏炸弹的函数大概内容时：读入一行内容将它转换成10进制长整数，然后将这值传给fun7递归函数作为第二个实参，</p><p>判断返回结果，如果返回结果等于一个常数，隐藏炸弹就通关。上图的例子中，这个常数就是7.</p><p>注意到还有一个地址传给fun7作为第一个实参，输出一下这个地址，看一下里面的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638550016555-aaa753c2-d5f6-4da1-8510-3164f5883a42.png" alt="img"></p><p>可以大胆猜测到传入的地址就是一个双链表的头部地址，而fun7是一个递归函数，将它们还原为c语言代码更容易分析些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>* <span class="hljs-title">prev</span>;</span><span class="hljs-comment">// 上一个链表指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>* <span class="hljs-title">next</span>;</span><span class="hljs-comment">// 下一个链表指针</span><br>&#125;DNode;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun7</span><span class="hljs-params">(DNode* p, <span class="hljs-type">long</span> <span class="hljs-type">long</span> num)</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        由于整个函数都是对eax操作，而不是rax，</span><br><span class="hljs-comment">        所以mov $0xffffffff,%eax  可以看作int型的-1</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> val = p-&gt;val;<br>    <span class="hljs-keyword">if</span> (val &gt; num)&#123;<br>        <span class="hljs-keyword">return</span> fun7(p-&gt;prev, num) * <span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; num)&#123;<br>        <span class="hljs-keyword">return</span> fun7(p-&gt;next, num) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// val == b</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>找出整个双链表的内容，还原一下它的样子</p><p>查看$rdi（即双链表头部地址）周围区域的内容：<code>x/128x $rdi</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638595763216-6505b22e-ea3a-43b5-95f8-ef2b557effca.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596904727-5afeacef-841e-4f1a-b934-67563e8199e1.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596967846-29567282-cf20-4389-997a-9c644aeaa3b8.png" alt="img"></p><p>继续查看n31、n32、n33、n34的链表指针指向的地址：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599381317-c6f27893-a925-4a65-aa39-1dee57347fe4.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599654703-df912485-e876-4531-b257-b993bbda950b.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599692323-c8ca4231-7ed8-47c9-8127-a13aaa4b99f9.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599790277-62fb556f-6726-4dfd-a5c4-e21edb831838.png" alt="img"></p><p>从这个双链表中画一个图找指针关联关系，发现是一颗二叉树，</p><p>并且结合fun7的递归函数规律，推导出一个结论：</p><p>当secret_phase函数传入fun7第二个实参等于二叉树第四层某颗树的值时，返回一个值。（如下图红色字体所示）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611077113-22bdf4f0-6284-4bdb-89ba-87956e4ff999.png" alt="img"></p><p>而我们这个例子中要求fun7返回值要等于7，那么传入fun7第二个实参应该为 <strong>0x3e9，即十进制的1001</strong></p><p><strong>所以这个例子中隐藏炸弹的通关字符串为：</strong> <strong>1001</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611173603-cc05f6ce-50b5-4c36-b306-76990ecad850.png" alt="img"></p><p>通关！！完美撒花~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My HTML &amp; CSS Notebook</title>
    <link href="/2022/07/08/My-CSS%20&amp;%20HTML-Notebook/"/>
    <url>/2022/07/08/My-CSS%20&amp;%20HTML-Notebook/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="行内元素与块级元素区别"><a href="#行内元素与块级元素区别" class="headerlink" title="行内元素与块级元素区别"></a>行内元素与块级元素区别</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%AF%B9%E6%AF%94">MDN</a></p><ul><li><p>内容</p><p>一般情况下，行内元素只能包含数据和其他行内元素。</p><p>而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li><li><p>格式</p><p>默认情况下，<strong>行内元素不会以新行开始，而块级元素会新起一行。</strong></p></li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级（specificity）"><a href="#选择器优先级（specificity）" class="headerlink" title="选择器优先级（specificity）"></a>选择器优先级（specificity）</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F">MDN 链接</a><br>CSS 选择器权重表：</p><p>![css选择器权重表](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725165840063.png)</p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p>页面布局要学习三大核心，<strong>盒子模型</strong>，<strong>浮动</strong>和<strong>定位</strong>。学习好盒子模型能非常好的帮助我们布局页面</p><p>看透网页布局的本质</p><p>网页布局过程：</p><p>1。先准备好相关的网页元素，网页元素基本都是盒子Box。</p><p>2。利用CSS设置好盒子样式，然后摆放到相应位置。</p><p>3。往盒子里面装内容。</p><p>网页布局的核心本质：就是利用CSS摆盒子。</p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>![image-20220725182216656](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182216656.png)</p><p>![image-20220725182257247](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182257247.png)</p><h4 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border#syntax">三大属性 - border-width, border-color, border-sytle</a></p><p>边框复合（简写）写法：</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/* 没有顺序 */</span><br></code></pre></td></tr></table></figure><p>边框分开写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/*只设定上边框，其余同理 */</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse">额外属性 ：border-collapse - 处理表格边框是否合并属性</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-comment">/* 合并（collapsed ）模式下，表示相邻边框合并在一起(共享边框) */</span><br></code></pre></td></tr></table></figure><p><strong>边框会影响盒子的实际大小；</strong></p><h4 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h4><p>当盒子指定了宽度和高度时，<strong>内边距会影响盒子的实际大小；如：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为240px，高度为240px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打开开发者面板工具，检查盒子大小会发现盒子的宽度为240px，高度为240px。</p><p>如果保证盒子为200px，跟效果图大小保特一致，则让width&#x2F;height减去多出来的内边距大小即可，将上面的写法改成下面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为200px，高度为200px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: aqua;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: pink;<br>      <span class="hljs-comment">/* 这里p元素继承div标签的宽和高，单独对p元素设置内边距不会撑大外面包裹的div盒子 */</span><br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学好JavaScript的好处</title>
    <link href="/2022/07/01/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/2022/07/01/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>todo</p><p>参考文章：<a href="https://blog.csdn.net/qq_38861711/article/details/95729429">https://blog.csdn.net/qq_38861711/article/details/95729429</a></p><p>对于前端工作者而言，JavaScript 作为三大前端套件中的一位成员不是没有原因的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac 终端配置</title>
    <link href="/2022/05/24/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/24/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>准备工作：需要用到代理设置软件 clashX ，Vim编辑器基本操作命令，http传输协议原理</p><p>关于系统用户目录下的 .bash_profile 和 .zshrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd ~<br>//<br>vim .bash_profile<br><br>vim .zshrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发环境部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>终端</tag>
      
      <tag>Terminal</tag>
      
      <tag>oh-my-zsh</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 操纵速查表</title>
    <link href="/2022/05/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <url>/2022/05/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="普通模式下基本命令"><a href="#普通模式下基本命令" class="headerlink" title="普通模式下基本命令"></a>普通模式下基本命令</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除光标处字符</td></tr><tr><td><code>dd</code></td><td>删除一个词</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td><code>/search_text</code></td><td>检索文档，在文档后面的部分搜索 search_text</td></tr><tr><td><code>?search_text</code></td><td>检索文档，在文档前面的部分搜索 search_text</td></tr><tr><td><code>n</code></td><td>移动到后一个检索结果</td></tr><tr><td><code>N</code></td><td>移动到前一个检索结果</td></tr><tr><td></td><td></td></tr><tr><td><code>u</code></td><td>撤销最后的操作</td></tr><tr><td><code>Ctrl + r</code></td><td>重做最后撤销的操作</td></tr><tr><td></td><td></td></tr><tr><td><code>dd</code></td><td>删除当前行</td></tr><tr><td><code>d0</code></td><td>删除到行首</td></tr><tr><td><code>d$</code></td><td>删除到行末</td></tr><tr><td></td><td></td></tr><tr><td><code>h</code></td><td>光标向左移动一个字符</td></tr><tr><td><code>j</code> 或 <code>Ctrl + J</code></td><td>光标向下移动一行</td></tr><tr><td><code>k</code> 或 <code>Ctrl + P</code></td><td>光标向上移动一行</td></tr><tr><td><code>l</code></td><td>光标向右移动一个字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="进阶之复制和粘贴"><a href="#进阶之复制和粘贴" class="headerlink" title="进阶之复制和粘贴"></a>进阶之复制和粘贴</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制当前行至存储缓冲区</td></tr><tr><td><code>[&quot;x]yy</code></td><td>复制当前行至寄存器 x</td></tr><tr><td><code>p</code>（小写）</td><td>在当前行之后粘贴存储缓冲区中的内容</td></tr><tr><td><code>P</code>（大写）</td><td>在当前行之前粘贴存储缓冲区中的内容</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
      <tag>vi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树(Binary-Tree)</title>
    <link href="/2022/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/"/>
    <url>/2022/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2><p>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</p><h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><p>树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84">树结构</a>。通常分支被称作“左子树”或“右子树”。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>所有叶节点都在最底层的完全二叉树；</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>英语：(Binary Search Tree)：也称二叉搜索树、有序二叉树；</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端攻城师</title>
    <link href="/2022/04/10/Front-End%20developer%20tech%20interview/"/>
    <url>/2022/04/10/Front-End%20developer%20tech%20interview/</url>
    
    <content type="html"><![CDATA[<h1 id="Front-End-developer-tech-interview"><a href="#Front-End-developer-tech-interview" class="headerlink" title="Front-End developer tech interview"></a>Front-End developer tech interview</h1><h2 id="GET和POST两种基本请求方法的区别"><a href="#GET和POST两种基本请求方法的区别" class="headerlink" title="GET和POST两种基本请求方法的区别"></a>GET和POST两种基本请求方法的区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WinToGo - 可以随身携带的系统U盘</title>
    <link href="/2022/04/08/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/"/>
    <url>/2022/04/08/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>我的mbp已经算是比较老的14年中装载4代i5的设备，对照以下这个图是支持制作USB系统盘启动Windows的。<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/1649086686847.jpg" alt="1649086686847"></p><h2 id="挑选适合做系统的U盘"><a href="#挑选适合做系统的U盘" class="headerlink" title="挑选适合做系统的U盘"></a>挑选适合做系统的U盘</h2><p>从<a href="https://bbs.luobotou.org/">萝卜头网</a>上了解到WTG对U盘性能有着一定的要求，这个网站有推荐购买的U盘（对于我来说太贵），这里特别得亏有大佬在上面分享了一些可供选择的比较特殊的U盘。这里对比一下我现有的普通闪迪U盘和以手机硬盘为颗粒的UFS盘之间的4k读写速度，特别是4k写入小文件的速度，可以明显的看到差距。<br>普通U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/%E9%97%AA%E8%BF%AA%E6%99%AE%E9%80%9AU'%E7%9B%98.png" alt="闪迪普通U&#39;盘"></p><p>适合做WTG的U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/sm3833_ufs_U%E7%9B%98_4k%E5%86%99%E5%85%A5%E6%B5%8B%E8%AF%95.png" alt="sm3833_ufs_U盘_4k写入测试"></p><h2 id="使用工具制作启动U盘"><a href="#使用工具制作启动U盘" class="headerlink" title="使用工具制作启动U盘"></a>使用工具制作启动U盘</h2><p>开机长按<code>option</code>键，然后选中<strong>EFI Boot</strong>这个磁盘，直接按<code>Enter</code>键</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法和题库练习笔记</title>
    <link href="/2022/03/13/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/13/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找（binary-search）"><a href="#二分查找（binary-search）" class="headerlink" title="二分查找（binary search）"></a>二分查找（binary search）</h2><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳</p></blockquote><blockquote><p>当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之90的学生在花费数小时后还是无法给出正确的解答，<strong>主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。</strong>1988年开展的一项研究显示，20本教科书里只有5本正确实现了二分搜索。不仅如此，本特利自己1986年出版的《编程珠玑》一书中的二分搜索算法<strong>存在整数溢出的问题</strong>，二十多年来无人发现。Java语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。 ——摘自维基百科</p></blockquote><p>视频讲解：<a href="https://youtu.be/CMweVF2iSyQ">二分查找法</a><br>时间复杂度：O(logn)<br>伪代码及方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/006DDiezgy1h08n6lcku4j325012y4a8.jpg" alt="006DDiezgy1h08n6lcku4j325012y4a8"><br>力扣相关题目：<a href="https://leetcode-cn.com/problems/binary-search/">力扣算法题目704</a></p><h2 id="回溯法（backtracking）"><a href="#回溯法（backtracking）" class="headerlink" title="回溯法（backtracking）"></a>回溯法（backtracking）</h2><p>待看做笔记： <a href="https://youtu.be/nrHTtjkYEyQ">使用C++讲解</a><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/01.39.29.png" alt="01.39.29"></p><h2 id="双指针（Two-pointer）"><a href="#双指针（Two-pointer）" class="headerlink" title="双指针（Two pointer）"></a>双指针（Two pointer）</h2><p>创建两个指针分别指向数组的首、末位置。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//test.c</span><br><span class="hljs-comment">//利用双指针判断字符的对称问题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//设置一个布尔值 symmetry默认为true</span><br><span class="hljs-type">bool</span> symmetry = <span class="hljs-literal">true</span>;<br><span class="hljs-type">char</span> str[]= <span class="hljs-string">&quot;BaeAB&quot;</span>; <span class="hljs-comment">//很明显,该字符串不是对称的</span><br><span class="hljs-comment">//遍历字符串数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str) / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-comment">//如果对称的两个位置上的数值不相等,则返回false</span><br><span class="hljs-keyword">if</span> (str[i] != str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c != %c\n&quot;</span>,str[i],str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]);<br>symmetry = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (symmetry) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串为对称的\n&quot;</span>,str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串不是对称的\n&quot;</span>,str);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>a != A<br>BaeAB:该字符串不是对称的<br></code></pre></td></tr></table></figure><p>在循环体for中, 当循环第一次时, <code>str[i]</code>和<code>str[strlen(str)-1-i]</code>分别指向<code>str</code>数组的首位和末位元素(这里是指结束符“\0”的前一位元素)。如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/J49VDc.png" alt="J49VDc"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac 下的常用终端（terminal）命令总结</title>
    <link href="/2022/03/06/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/06/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><strong>简介：</strong></p><p><code>ls</code> 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一。</p><p>在终端里输入<code>ls</code>就可以查看文件和文件夹，但隐藏的文件就无法查看，使用<code>ls -a</code>即可。</p><p>“.” 代表当前目录，“..” 代表上一级目录，以 “.” 开头的文件为隐藏文件，需要用 -a 参数才能显示。</p><p><strong>ls常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><p><strong>ls 匹配通配符：</strong></p><p>与 DOS 下的文件操作类似，在 Unix&#x2F;Linux 系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>文件代表文件名中所有字符</td></tr><tr><td>ls te*</td><td>查找以 <code>te</code> 开头的文件</td></tr><tr><td>ls *html</td><td>查找结尾为 <code>html</code> 的文件</td></tr><tr><td>？</td><td>代表文件名中任意一个字符</td></tr><tr><td>ls ?.c</td><td>只找第一个字符任意，后缀为 <code>.c</code> 的文件</td></tr><tr><td>ls a.?</td><td>只找只有 3 个字符，前 2 字符为 <code>a.</code> ，最后一个字符任意的文件</td></tr><tr><td>[]</td><td><code>&quot;[”</code> 和 <code>“]”</code> 将字符组括起来，表示可以匹配字符组中的任意一个。<code>“-”</code> 用于表示字符范围。</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr><tr><td>ls [a-f]*</td><td>找到从 a 到 f 范围内的的任意一个字符开头的文件</td></tr><tr><td>ls a-f</td><td>查找文件名为 a-f 的文件,当 <code>“-”</code> 处于方括号之外失去通配符的作用</td></tr><tr><td>\</td><td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。<code>“?”</code> 和 <code>“*”</code> 处于方括号内时不用使用转义字符就失去通配符的作用。</td></tr><tr><td>ls *a</td><td>查找文件名为 <code>*a</code> 的文件</td></tr></tbody></table><h2 id="创建文件夹-x2F-目录"><a href="#创建文件夹-x2F-目录" class="headerlink" title="创建文件夹&#x2F;目录"></a>创建文件夹&#x2F;目录</h2><p>命令：<code>mkdir</code><br>使用说明：输入命令随后空格再输入目录名即可。<br>案例：创建一个 test 文件夹&#x2F;目录则对应命令就是<code>mkdir test</code></p><h2 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h2><p><code>cd</code> 命令进入目录比如要进入 test 目录则就是<code>cd test</code></p><h2 id="返回上一级目录"><a href="#返回上一级目录" class="headerlink" title="返回上一级目录"></a>返回上一级目录</h2><p>命令：<code>cd..</code></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>命令: <code>touch</code><br>笔者感觉这个命令还是挺靠谱的。Mac如果不用第三方工具（sublime等）是无法可视化创建一个txt文件。而用这个命令即可创建。<br>示例（创建一个test为名的 txt 文件）：<code>touch test.txt</code></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>命令：<code>cp</code><br>案例（拷贝一个 test.txt 文件并重新命名为test2.txt）：<code>cp test.txt test2.txt</code></p><h2 id="重命名或者移动文件"><a href="#重命名或者移动文件" class="headerlink" title="重命名或者移动文件"></a>重命名或者移动文件</h2><p>命令:   <code>mv</code><br>比如  (将一个 mountain.c  的 C 语言程序文件名字改成 mt.c )： <code>mv mountain.c mt.c</code></p><p>或者将 mountain.c 文件剪切到 code 文件夹下：<code>mv mountain.c code/</code></p><h3 id="批量修改文件名"><a href="#批量修改文件名" class="headerlink" title="批量修改文件名"></a>批量修改文件名</h3><p>例子：目录下有多个后缀为<code> .cpp</code> 的文件，我想让它们全部保留文件名的情况下修改成<code> .c</code> 后缀，这时可以结合 mv 命令和 shell 编程写个 for 循环，遍历每个文件然后依次更改。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">for i in *.cpp;do mv &quot;$i&quot; &quot;$&#123;i%.cpp&#125;.c&quot;;done<br></code></pre></td></tr></table></figure><p>模版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 把 xxx 换成要修改的文件名的后缀，yyy 换成替换输出的后缀即可。<br>for i in *.xxx;do mv &quot;$i&quot; &quot;$&#123;i%.xxx&#125;.yyy&quot;;done<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令：<code>find</code><br>案例（查找当前目录下所有的 txt 文件）：<code>find *.txt</code></p><p><strong>常用用法：</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>find .&#x2F; -name test.sh</td><td>查找当前目录下所有名为test.sh的文件</td></tr><tr><td>find .&#x2F; -name ‘*.sh’</td><td>查找当前目录下所有后缀为.sh的文件</td></tr><tr><td>find .&#x2F; -name “[A-Z]*”</td><td>查找当前目录下所有以大写字母开头的文件</td></tr><tr><td>find &#x2F;tmp -size 2M</td><td>查找在&#x2F;tmp 目录下等于2M的文件</td></tr><tr><td>find &#x2F;tmp -size +2M</td><td>查找在&#x2F;tmp 目录下大于2M的文件</td></tr><tr><td>find &#x2F;tmp -size -2M</td><td>查找在&#x2F;tmp 目录下小于2M的文件</td></tr><tr><td>find .&#x2F; -size +4k -size -5M</td><td>查找当前目录下大于4k，小于5M的文件</td></tr><tr><td>find .&#x2F; -perm 0777</td><td>查找当前目录下权限为 777 的文件或目录</td></tr></tbody></table><h2 id="显示当前的目录"><a href="#显示当前的目录" class="headerlink" title="显示当前的目录"></a>显示当前的目录</h2><p>命令：<code>pwd</code></p><h2 id="打开成可视化的文件夹"><a href="#打开成可视化的文件夹" class="headerlink" title="打开成可视化的文件夹"></a>打开成可视化的文件夹</h2><p>命令：<code>open</code><br>说明：如果是 <code>open</code>,则是打开当前命令里的目录，如果要打开指定的文件夹或者文件则格式为open要打开的路径即可。</p><h2 id="删除目录（空目录）"><a href="#删除目录（空目录）" class="headerlink" title="删除目录（空目录）"></a>删除目录（空目录）</h2><p>命令：<code>rmdir</code><br>案例：<code>rmdir test</code>（rmdir命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除目录（非空或者空目录都可以删除）推荐使用"><a href="#删除目录（非空或者空目录都可以删除）推荐使用" class="headerlink" title="删除目录（非空或者空目录都可以删除）推荐使用"></a>删除目录（非空或者空目录都可以删除）推荐使用</h2><p>命令： <code>rm -rf</code><br>案例：rm -rf test（rm -rf 命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>命令：<code>rm</code><br>案例（删除一个 test.txt 文件）：<code>rm test.txt</code><br>或者（删除所有后缀为 <code>.ttf</code> 的文件）：<code>rm *.ttf</code><br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u>，为了防止文件误删，可以在 <code>rm</code> 后使用 <code>-i</code> 参数以逐个确认要删除的文件。</p><p><strong><code>rm</code> 常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>以进行交互式方式执行</td></tr><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><h2 id="Terminal-光标移动快捷键"><a href="#Terminal-光标移动快捷键" class="headerlink" title="Terminal 光标移动快捷键"></a>Terminal 光标移动快捷键</h2><ul><li>将光标移动到行首：<code>control + a</code></li><li>将光标移动到行尾：<code>control + e</code></li><li>清除屏幕：<code>control + l</code>, 相当于手动输入<code>clear</code>并回车</li><li>搜索以前使用命令：<code>control + r</code></li><li>清除当前行：<code>control + u</code></li><li>清除至当前行尾：<code>control + k</code></li><li>单词为单位移动：<code>option + 方向键</code></li><li>光标向前 (Forward) 移动一个字符位置：<code>Ctrl + f</code></li><li>光标往回(Backward)移动一个字符位置：<code>Ctrl + b</code></li><li>删除一个字符，相当于通常的 Delete 键（命令行若无所有字符，则相当于 exit；处理多行标准输入时也表示eof：<code>Ctrl + d</code></li><li>退格删除一个字符，相当于通常的 Backspace 键：<code>Ctrl + h</code></li></ul><h2 id="文件管理有关"><a href="#文件管理有关" class="headerlink" title="文件管理有关"></a>文件管理有关</h2><h4 id="1-归档管理：tar"><a href="#1-归档管理：tar" class="headerlink" title="1. 归档管理：tar"></a>1. 归档管理：<code>tar</code></h4><p><strong>简介：</strong></p><p>计算机中的数据经常需要备份，tar 是 Unix&#x2F;Linux 中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。其实说白了，就是打包。</p><p><strong><code>tar</code> 使用格式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[参数]</span> 打包文件名 文件<br></code></pre></td></tr></table></figure><p><strong><code>tar</code> 常用参数：</strong></p><p>tar 命令很特殊，其参数前面可以使用“-”，也可以不使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>-v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>-f</td><td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td></tr><tr><td>-t</td><td>列出档案中包含的文件</td></tr><tr><td>-x</td><td>解开档案文件</td></tr></tbody></table><p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p><h4 id="2-文件压缩解压：gzip"><a href="#2-文件压缩解压：gzip" class="headerlink" title="2. 文件压缩解压：gzip"></a>2. 文件压缩解压：<code>gzip</code></h4><p><strong>简介：</strong></p><p>tar 与 gzip 命令结合使用实现文件打包、压缩。 tar 只负责打包文件，但不压缩，用 gzip 压缩 tar 打包后的文件，其扩展名一般用xxxx.tar.gz。</p><p><strong><code>gzip</code> 使用格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gzip  <span class="hljs-selector-attr">[选项]</span>  被压缩文件<br></code></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>解压</td></tr><tr><td>-r</td><td>压缩所有子目录</td></tr></tbody></table><p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 …</p><p><code>-z ：指定压缩包的格式为：file.tar.gz</code></p><p>解压用法： tar zxvf 压缩包包名</p><p><code>-z:指定压缩包的格式为：file.tar.gz</code></p><p>解压到指定目录：-C （大写字母“C”）</p><h4 id="3-文件压缩解压：bzip2"><a href="#3-文件压缩解压：bzip2" class="headerlink" title="3. 文件压缩解压：bzip2"></a>3. 文件压缩解压：<code>bzip2</code></h4><p><strong>简介：</strong></p><p>tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。</p><p>tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。</p><p>在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar -jcvf 压缩包包名 文件…(tar jcvf bk.tar.bz2 *.c)</p><p>解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</p><h4 id="4-文件压缩解压：zip-、unzip"><a href="#4-文件压缩解压：zip-、unzip" class="headerlink" title="4. 文件压缩解压：zip 、unzip"></a>4. 文件压缩解压：<code>zip</code> 、<code>unzip</code></h4><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><p>压缩文件：zip [-r] 目标文件(没有扩展名) 源文件</p><p>解压文件：unzip -d 解压后目录文件 压缩文件</p><h4 id="5-输出重定向命令：-gt"><a href="#5-输出重定向命令：-gt" class="headerlink" title="5. 输出重定向命令：&gt;"></a>5. 输出重定向命令：<code>&gt;</code></h4><p><strong>简介：</strong></p><p>Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p><p>注意： <code>&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部。</code></p><h4 id="6-分屏显示：more"><a href="#6-分屏显示：more" class="headerlink" title="6. 分屏显示：more"></a>6. 分屏显示：<code>more</code></h4><p><strong>简介：</strong></p><p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用 <code>more</code> 命令，每次只显示一页，按下空格键可以显示下一页，按下 <code>q</code> 键退出显示，按下 <code>h</code> 键可以获取帮助。</p><h4 id="7-文本搜索：grep"><a href="#7-文本搜索：grep" class="headerlink" title="7. 文本搜索：grep"></a>7. 文本搜索：<code>grep</code></h4><p><strong>简介：</strong></p><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。如果找到匹配模式， grep 打印包含模式的所有行。</p><p>grep一般格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grep <span class="hljs-selector-attr">[-选项]</span> ‘搜索内容串’文件名<br></code></pre></td></tr></table></figure><p>在 grep 命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p><p><strong><code>grep</code> 常用参数：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>grep 搜索内容串可以是正则表达式。</p><p><strong>grep 常用正则表达式：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt</td></tr><tr><td>ke$</td><td>行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt</td></tr><tr><td>[Ss]igna[Ll]</td><td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt</td></tr><tr><td>.</td><td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt</td></tr></tbody></table><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p>👉 <a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac">Mac 上“终端”中的键盘快捷键 - Apple 支持 (中国)</a> </p>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇总常用Git指令及用法</title>
    <link href="/2022/03/01/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>/2022/03/01/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code> 它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--list</span><br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> -<span class="hljs-string">e</span> [<span class="hljs-built_in">--global]</span><br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;[name]&quot;</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、增加-x2F-删除文件"><a href="#三、增加-x2F-删除文件" class="headerlink" title="三、增加&#x2F;删除文件"></a>三、增加&#x2F;删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用场景：如果想要忽略已检入的文件，则必须在添加忽略该文件的规则之前取消跟踪它。以下操纵命令为从终端取消跟踪文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="六、撤销"><a href="#六、撤销" class="headerlink" title="六、撤销"></a>六、撤销</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>版本管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/22/hello-world/"/>
    <url>/2022/02/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
