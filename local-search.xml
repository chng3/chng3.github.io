<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>将本地项目上传到GitHub托管</title>
    <link href="/2022/10/11/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/"/>
    <url>/2022/10/11/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub%E6%89%98%E7%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Github基础使用"><a href="#Github基础使用" class="headerlink" title="Github基础使用"></a>Github基础使用</h1><h2 id="将本地仓库关联到GitHub"><a href="#将本地仓库关联到GitHub" class="headerlink" title="将本地仓库关联到GitHub"></a>将本地仓库关联到GitHub</h2><h3 id="初始化本地仓库并提交仓库文件"><a href="#初始化本地仓库并提交仓库文件" class="headerlink" title="初始化本地仓库并提交仓库文件"></a>初始化本地仓库并提交仓库文件</h3><p>要先确保操作系统已经安装了<strong>Git</strong>，之后进入本地仓库的根目录，鼠标右键选择<code>Git Bash Here</code>，接着输入以下命令：</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>出现以下回应且在根目录下生成了一个隐藏的文件夹<code>.git</code><br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9t5xfwhj20fq01it8l.jpg"><br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9w20hk0j20gq01umx3.jpg"><br>之后，此时仓库里的文件还没有被追踪，输入</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> . <span class="hljs-comment">//将仓库里的所有文件进行追踪</span><br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9wvos9rj20e4026gls.jpg"><br>执行提交，拍摄快照</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git commit -m <span class="hljs-string">&quot;Started Course&quot;</span><span class="hljs-regexp">//</span><span class="hljs-string">&quot; &quot;</span>里可以自定义快照的名字<br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9xsqb8wj20fi05jwf8.jpg"></p><h3 id="在GitHub上创建一个项目"><a href="#在GitHub上创建一个项目" class="headerlink" title="在GitHub上创建一个项目"></a>在GitHub上创建一个项目</h3><p>GitHub主页右上角点击new repository<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9y9tnkcj20al06bab3.jpg"><br>输入信息，<strong>记住勾选Initialize this repository with a REAdME</strong></p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9yw1qg5j20o10hhgn0.jpg"></p><p>创建后，复制项目的地址</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxw9z9g1caj20sf0eujsx.jpg"></p><p>回到本地仓库，使用命令，<strong>并在命令后加上你的GitHub项目的地址</strong>，也就是刚才复制的内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git remote <span class="hljs-built_in">add</span> origin<br></code></pre></td></tr></table></figure><p>这一步是本地和远程服务器建立联系的一步。执行成功后不会显示任何结果：<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa001gerj20fn021q37.jpg"></p><p>到这里，你已经成功了一半了。</p><h3 id="向远程仓库提交代码"><a href="#向远程仓库提交代码" class="headerlink" title="向远程仓库提交代码"></a>向远程仓库提交代码</h3><p>第一次向远程提交代码时得先将远程的README.md 文件同步过来，实行一下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git pull <span class="hljs-comment">--rebase origin master</span><br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa0n36itj20db02xq38.jpg"></p><p>查看本地仓库是否出现README.md文件，如有，则表示拉取则成功。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1awhwuj20gp032glw.jpg"></p><p>接着，将进行第一次向远程同步本地仓库的内容，输入：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa1pgcvpj20dj0400t6.jpg"><br><strong>注意</strong>：过程中可能会出现一个登陆GitHub帐户的窗口，输入你的账户及密码就可以了。</p><p>最后回到GitHub主页查看是否同步即可。</p><h2 id="文件变动操作"><a href="#文件变动操作" class="headerlink" title="文件变动操作"></a>文件变动操作</h2><h3 id="本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？"><a href="#本地仓库有大量变动-修改II增删-，之后想快速同步到Github远程仓库应该如何处理？" class="headerlink" title="本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？"></a>本地仓库有大量变动(修改II增删)，之后想快速同步到Github远程仓库应该如何处理？</h3><p>比如我在本地有一个名为CodingAtSchool的仓库，仓库里有C语言作业文件夹和一个README文件如下图：</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa29yeq8j20i705hdgm.jpg"><br>我今天用操作鼠标做了大量对C语言目录下的改动，之后进到仓库根目录下，右键Git Bash Here，输入git status，查看仓库状态。</p><p><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2m62lwj20ko0d0k3y.jpg"><br>oops，大量的红色数字什么鬼，这时千万别慌！如果本地仓库中含文件名为中文名称时，命令窗中提示的信息是无法显示中文的，它会把中文变成一串串数字。这时仔细观察一下，我所做的全部变动都是在C语言作业这个目录下完成的，具体变动是删除了大量文件和增加了一些文件。</p><p>第一步，分别执行以下两句命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> <span class="hljs-literal">-r</span> C语言作业/<br><span class="hljs-variable">$</span> git add C语言作业/<br></code></pre></td></tr></table></figure><p>再一次查看状态 git status，发现一切的修改都已经提交到暂存区了<br><img src="http://ww1.sinaimg.cn/large/bf4c214dgy1fxwa2vktcrj20kk0cwqfy.jpg"></p><p>第二步，提交修改</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;我的修改&#x27;</span><br></code></pre></td></tr></table></figure><p>第三步，推送到远程仓库</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Lab4 (Link Lab) 实验步骤 - 来自舍友的文章</title>
    <link href="/2022/07/30/CSAPP-Lab4-Link-Lab-%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/30/CSAPP-Lab4-Link-Lab-%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul><li>ASCII码对照表</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783994155-2049d1eb-c9ab-4c14-a800-736bdc16c089.png" alt="img"></p><ul><li>文件十六进制编辑器</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install hexedit<br></code></pre></td></tr></table></figure><ul><li>查看程序ELF</li></ul><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">readelf -a <span class="hljs-attribute">&lt;文件&gt;</span><br></code></pre></td></tr></table></figure><ul><li>查看程序汇编代码和重定向目标</li></ul><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">objdump -dx <span class="hljs-attribute">&lt;文件&gt;</span><br></code></pre></td></tr></table></figure><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>要求：修改二进制可重定位目标文件“phase1.o”的数据节内容，使其与main.o链接后能够运行输出（且仅输出）自己的学号</p><p>编译运行看看输出的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783551709-f8b90f59-10f3-4343-9ca8-e50e03545f56.png" alt="img"></p><p>看到这种一大串乱七八糟的字符串，第一反应是直接用十六进制编辑器看文件的ASCII码有没有这一串字符串</p><p>使用十六进制编辑器查看文件：<code>hexedit phase1.o</code></p><p>找到该字符串的位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640783948863-90d9bf97-9409-4429-a8d0-553ca3ff28a4.png" alt="img"></p><p>直接从字符串开头修改为自己的学号，并用ASCII码的 ‘&#x2F;0’ 结束，‘&#x2F;0’的十六进制是 <code>00</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640784529713-c5e57ae5-4e30-4d87-872e-3d7cff3c0186.png" alt="img"></p><p>在hexedit编辑器中，使用CTRL + X 快捷键保存修改的结果</p><p>再编译程序：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640784607901-f5fce52e-08a9-4e66-84b0-1902ea090bb7.png" alt="img"></p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>要求：根据强符号与弱符号的原则，判断符号表中的符号以及其所对应的数据区域。利用符号解析规则，创建生成一个名为“phase2_patch.o”的二进制可重定位目标文件</p><p>先编译phase2.o，看看输出的效果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> phase2<span class="hljs-selector-class">.o</span> -no-pie<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640869225822-89d5b194-e31e-45d2-b9c6-7b590795c650.png" alt="img"></p><p>是一串乱七八糟的文本，也推断不出它们的ASCII码，不能像第一题一样直接在文件中改字符串，</p><p>所以反汇编它的代码，尝试找到它输出的文本位置</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640869772837-d272a721-d990-47d0-b62b-c71f21592489.png" alt="img"></p><p>在do_phase2函数中，找到关键的汇编代码，其中call puts就是输出字符串的函数，输出的字符串地址为：0x60108a</p><p>往上看代码，看到把 0x601060 的地址放进myFunc函数计算，怀疑 0x60108a 的字符串内容 也经过 myFunc函数计算过。</p><p>于是再分析myFunc函数的汇编代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640870093347-62ebc97a-796e-4eef-bb59-1af6bb43b8d0.png" alt="img"></p><p>分析myFunc函数的汇编代码，原理是在一个 大小为256的char数组中经过如下运算生成字符串，</p><p>在这个例子中，这个char数组的起始地址就是：0x601060</p><p>为了找到这个char数组在原phase2.o中的重定向位置，方便我们接下来在phase2.o文件中修改这个数组</p><p>使用 <code>objdump -dx phase2.o</code> 查看重定向信息</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640877108454-4569048c-568b-4828-ac97-4e89848e59dc.png" alt="img"></p><p>（左边的终端是查看phase2.o的重定向信息，右边的终端是查看a.out的重定向结果）</p><p>为了更清晰描述phase2的汇编代码，将它的大概逻辑转换成c语言伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> g_myCharArray[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    g_myCharArray[i] = g_myCharArray[i] + (i &amp; <span class="hljs-number">0x1F</span>);<br>&#125;<br><br><span class="hljs-meta"># idx 在重定位表中找到</span><br><span class="hljs-built_in">puts</span>(g_myCharArray + idx);<br></code></pre></td></tr></table></figure><p>用<code>readelf -a phase2.o</code>查看文件，发现<code>g_myCharArray</code>数组变量是弱符号，</p><p>并且它的类型为COM，即未初始化或初始化为0的全局变量。</p><p>弱符号可以被强符号覆盖，意思是只要在链接的时候出现同名的强符号变量就可以覆盖它，强符号变量就是有初始化值的变量。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640785499062-f99537e2-1731-4b32-8543-2dea59cc894a.png" alt="img"></p><p>要想输出自己的学号，先在重定位表中找到从数组的哪个位置输出：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878154861-0de3812a-5985-4d51-b076-a3cd35eefce2.png" alt="img"></p><p>找到偏移量是2a，十进制为42，所以程序是从数组g_myCharArray[42]输出，数组下标是42，我们学号也要经过一系列计算后写到这个位置上。</p><p>下面开始计算学号的存放到数组中的值。简而言之：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">存放到数组中的值 = 学号ASCII码 - （下标 <span class="hljs-meta">&amp; 0x1F）</span><br></code></pre></td></tr></table></figure><p>学号第一个位置的偏移量是2a，那么：</p><p>2a &amp; 0x1F &#x3D; 0xA (十六进制) &#x3D; 10 （十进制）</p><p>往后位置的数值就是递增的：10  11  12  13 ….</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640879817903-298d3b1a-cf13-4bb8-bcdc-02cee07a9b68.png" alt="img"></p><p>另外还需要写入字符 ‘&#x2F;0’的ASCII码作为字符串的结束符</p><p>‘&#x2F;0’字符写入的数组下标 &amp; 0x1F 的结果是 21</p><p>只要将这个值与一个整数相加，溢出char类型的最大表示范围，就可以得到0</p><p>举例：21 + 235 &#x3D; 256  &gt; 255(char类型最大表示范围)</p><p>所以，‘&#x2F;0’字符写入到数组对应的数值是235。</p><p>新建一个phase2_patch.c，写入一个同名的char g_myCharArray[256]，</p><p>从数组g_myCharArray[42]写入经过计算后的学号值。还要再写入经过计算后的‘&#x2F;0’结束符的值。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878100749-30744963-39b1-4429-9f4a-52799dc5ebb7.png" alt="img"></p><p>编译这个文件，然后输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640878355553-03ec2022-1cdb-4f71-b58c-5688b2ae19a1.png" alt="img"></p><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>检查反汇编代码，定位模块中的各组成函数并推断其功能作用。 根据反汇编程序的执行逻辑，修改函数中的机器指令（用自己指令替换函数体中的nop指令）以实现期望的输出。</p><p>先编译程序：<code>gcc main.o phase3.o -no-pie</code></p><p>再分析编译后的程序的汇编代码：<code>objdump -d a.out</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786357367-4db926f4-5f79-4052-a710-7c63aa9425fb.png" alt="img"></p><p>除了do_phase3还有myFunc1、myFunc2函数，这题是让我们定位模块中的各组成函数并推断其功能作用。 根据反汇编程序的执行逻辑，修改函数中的机器指令。</p><p>分析程序得出结论：需要修改do_phase3的nop指令为如下结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0000000000400550</span> &lt;do_phase3&gt;:<br>  <span class="hljs-number">400550</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">400551</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br>  <span class="hljs-number">400554</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400555</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400556</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400557</span>:<span class="hljs-number">90</span>                   nop<br>  <span class="hljs-number">400558</span>:e8 e1 ff ff ff       callq  <span class="hljs-number">40053</span>e &lt;myFunc2&gt;<br>  <span class="hljs-number">40055</span>d:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br>  <span class="hljs-number">400560</span>:e8 be ff ff ff       callq  <span class="hljs-number">400523</span> &lt;myFunc1&gt;<br>  .....<br></code></pre></td></tr></table></figure><p>它们的汇编特征码如下：</p><p>55 48 89 e5   90 90 90 90   E8 E1 FF FF   FF 48 89 C7   E8 BE FF FF   FF</p><p>分析完a.out的行为，就要在phase3.o中修改对应的汇编代码，才可以生效。</p><p>使用<code>objdump -dx phase3.o</code>查看这个函数在phase3.o的.text位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881232940-6f23ea20-df4d-410f-87d1-dcae86c7aa30.png" alt="img"></p><p>使用<code>readelf -a phase3.o</code>找到.text在静态文件中的偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881400547-de5f7145-5884-41d4-a417-763c2c2b0710.png" alt="img"></p><p>所以计算do_phase3函数在phase3.o的静态文件偏移是：</p><p>0x40 + 0x2d &#x3D; 0x6D</p><p>使用<code>hexedit phase3.o</code>修改0x6D位置开始的数据：</p><p>55 48 89 e5   90 90 90 90   E8 E1 FF FF   FF 48 89 C7   E8 BE FF FF   FF</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640881783650-995a09b2-446a-4628-bebe-e7e0a7418c7f.png" alt="img"></p><p>在a.out的汇编代码中，myFunc2中这个地址就是字符串数组的起始地址，在这个地址中输入自己的学号就可以通过此关</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786737987-10961ffb-7c2b-4654-a45b-d8eb61384416.png" alt="img"></p><p>需要从phase3.o中找到它的位置。</p><p>使用<code>objdump -dx phase3.o</code>查看这个函数下的重定位信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640880914937-c77dd996-0557-4f7e-8cbb-60ac42c6d9ea.png" alt="img"></p><p>使用<code>readelf -a phase3.o</code>也同样可以看到</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786872855-3df015ae-319c-40c3-a2c5-488338459c7a.png" alt="img"></p><p>重定向的偏移是.data + c</p><p>找.data的静态文件偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640786934738-87c85d45-dd7c-47dc-b515-3087e1215ec3.png" alt="img"></p><p>所以在静态文件偏移 1a0 + c  &#x3D; 1AC 这个地址就是数组起始地址，在这个地址中修改为自己的学号</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640882364964-3316b538-8fff-4765-9bf1-2169f96c0712.png" alt="img"></p><p>输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640882441514-81cc76ee-a2ef-4b8d-b56c-8434511e5e9c.png" alt="img"></p><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><p>要求：修改二进制可重定位目标文件“phase4.o”中重定位节    和数据节中的内容，使其与main.o链接后能够运行输出（且仅输出）自己的学号，本阶段学生所拿到的.o文件中的“重定位位置”信息已经被抹除，学生需要根据实际情况确认冲重定位的发生位置，并根据重定位类型对位置信息进行恢复。</p><p>查看被抹除的重定位信息:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> phase4<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640787620308-10254a3c-f9c5-4227-9d9c-ab70e0a7fe41.png" alt="img"></p><p>发现3个位置被抹除。</p><p>反汇编查看.text段的重定向信息及汇编内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -dx phase4.o<br></code></pre></td></tr></table></figure><p>根据汇编指令特点，猜测代码思路，使得程序修复重定位地址后可以正常运行:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640787772002-8a8943f8-e6d7-41cd-86ea-5626cd03b98c.png" alt="img"></p><p>R_X86_64_PC32类型  为 相对地址偏移，重定位一个使用32位PC相对地址的引用</p><p>R_X86_64_32S类型  为 绝对地址偏移，重定位一个使用32位绝对地址的引用</p><p>应该改为如下的重定位位置：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641276697837-37caf36f-4d92-4f75-a753-5f78c904fc69.png" alt="img"></p><p>修复重定位信息：</p><p>使用<code>readelf -a phase4.o</code>查看”.rela.text”段</p><p><strong>“.rela.text”是重定位信息段，它在静态文件的偏移是 0x250</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641278110225-e67c7999-23ef-412c-a71e-75ece807cff7.png" alt="img"></p><p><strong>“.rela.text”每一条重定位数据都是一个结构体，</strong></p><p><strong>结构体定位文件可以在</strong><code>/usr/include/elf.h</code><strong>中看到</strong></p><p><strong>“.rela.text”结构体内容如下：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641278518628-a84ca7d4-e9eb-46d7-b302-5df2eeab6953.png" alt="img"></p><p>使用<code>hexedit phase3.o</code>修改<strong>静态文件的偏移 0x250</strong>位置的结构体数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641279135178-bc9edd39-65c2-47ed-9055-1fe2751b278a.png" alt="img"></p><p>分析.data段的学号写入位置：</p><p>首先分析do_phase函数的汇编代码，计算第一条重定向数据的相对偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641320345924-ac83bb96-aa5c-422d-a808-237f30b547b4.png" alt="img"></p><p>.text段在文件中的偏移是0x40，所以第一条重定向在文件中的偏移是0x46，</p><p>.data段在文件中的偏移是0x60</p><p>所以第一条重定向的相对偏移是：(.data + 0x10) - 0x46  &#x3D;  0x60 + 0x10 - 0x46 &#x3D;   0x2A</p><p>又因为下一条指令在静态文件的地址是0x4a</p><p>所以得到的绝对地址是：0x4a + 0x2A &#x3D; 0x74</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321035870-85df389e-0d47-4b89-a9a6-f5c0b9a8b3e4.png" alt="img"></p><p>静态文件 0x74 位置上的数值是<strong>0x3F</strong></p><p>根据do_phase的汇编代码流程，学号写入位置应该是：0x3F &amp; 0x7 + .data &#x3D; 0x3F &amp; 0x7 + 0x60 &#x3D; <strong>0x67</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321456359-d5cd2717-bde6-480d-a523-14cc089005bc.png" alt="img"></p><p>输出结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641321537765-f53cc6e6-9603-4b75-bfde-c5a2460c096a.png" alt="img"></p><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><p>要求：修改二进制可重定位目标文件“phase5.o”中重定位节和数据节的内容，使其与main.o链接后能够正确输出（且仅输出）自己学号</p><p>反汇编先分析完整的程序逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> phase5<span class="hljs-selector-class">.o</span> -no-pie<br>objdump -d <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>发现myFunc是关键函数</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788319784-fbe2008e-cd4b-4d68-88d6-502b3335736a.png" alt="img"></p><p>再查看该内存的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788388281-577f94c6-758d-48f0-96a9-0888e29de038.png" alt="img"></p><p>整理程序逻辑：</p><p>程序判断g_guard变量是否为0，如果不为零输出0x0x601030地址中的“hhhhh”字符串，如果变量为0输出0x0x601040地址中的“000000000000”字符串，程序里的g_guard变量始终为1，所以总是输出了“hhhhh”字符串。</p><p>我们的解题思路是不修改g_guard变量值的情况下，把这两者的重定向绝对地址互换，然后修改0x0x601040地址中的“000000000000”字符串为自己的学号。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640788962102-d507d615-9c1c-40d4-90dc-fa3ac205ec57.png" alt="img"></p><p>以上是分析可执行文件a.out的流程，实际上要修改phase5.o文件的重定位信息才可以生效。</p><p>两个变量的重定向顺序在phase5.o中找到，所以开始分析phase5.o</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -dx phase5.o<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640789268085-ae6430b3-f75d-438a-9061-f494af4d55ab.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> phase5<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1640789347851-e55ef930-92f2-48bc-b875-a2682c631158.png" alt="img"></p><p>修改<code>.rela.text</code>段中 20 与 2c 互换，再修改<code>.data + 10</code>的内存数据为学号即可</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322096307-a0449a69-1e81-4611-8ac4-320433823d40.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322162423-435af911-4ebd-4846-ab1d-fdc734d43357.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1352293/1641322191877-1b699192-dc6e-44ec-9f36-4bc60b5f245f.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP lab2 (Bomb Lab) 反汇编拆炸弹总结 - 来自舍友的文章</title>
    <link href="/2022/07/30/CSAPP-lab2-Bomb-Lab-%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8B%86%E7%82%B8%E5%BC%B9%E6%80%BB%E7%BB%93-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/30/CSAPP-lab2-Bomb-Lab-%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8B%86%E7%82%B8%E5%BC%B9%E6%80%BB%E7%BB%93-%E6%9D%A5%E8%87%AA%E8%88%8D%E5%8F%8B%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>实验程序下载地址（官网）：<a href="http://csapp.cs.cmu.edu/2e/labs.html">http://csapp.cs.cmu.edu/2e/labs.html</a></p><p>每一关要通过反汇编分析出正确的字符串才能过关，否则弹出bomb！！程序停止运行</p><p>一共有6个炸弹和一个隐藏炸弹。</p><p>我们学校为了防止同学们互相抄作业，每个人得到的炸弹都不一样，其实就是每一关都有3种不同的情况（除了第一关和隐藏炸弹那一关），于是我把每一关每一种情况都做了一遍。结合每一关的指令特征码写了一个自动拆炸弹的程序，能拆我们学校发下来的炸弹，其它学校的炸弹不一定能拆。</p><p>百度云盘下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/1j-FS0X6NlOwTqPv8j6a7sg">https://pan.baidu.com/s/1j-FS0X6NlOwTqPv8j6a7sg</a> </p><p>提取码：mrf2</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><strong>便于我们分析，首先要反汇编程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">objdump -d bomb &gt; bomb.<span class="hljs-keyword">asm</span><br></code></pre></td></tr></table></figure><p>得到一个bomb.asm文件就是我们的程序汇编代码</p><p><strong>使用Linux下的反汇编调试器分析代码：</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gdb bomb</span><br></code></pre></td></tr></table></figure><p>未接触过gdb还需要额外学习gdb的用法</p><p><strong>查看程序ELF结构：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">readelf -<span class="hljs-selector-tag">a</span> bomb<br></code></pre></td></tr></table></figure><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>输入一个字符串，比较输入的字符串和保存的字符串是否相等。</p><p>思路：</p><p><code>callq  16fc &lt;strings_not_equal&gt;</code> 就是比较两个字符串是否相等的函数，</p><p>两个字符串通过参数传递到函数中，</p><p>其中%rdi就是自己输入的字符串，%rsi就是正确的字符串</p><p>进入函数，单步执行完<code>lea    0x16a1(%rip),%rsi</code>  语句后，</p><p>输入%rsi的值就是答案（在gdb中使用<code>x/s %rsi</code>输出）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637993820059-04fa4b30-23ec-49cc-83f0-0b0b23d7b4f7.png" alt="img"></p><hr><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>输入6个数，判断6个数之间的规律</p><h3 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637995926316-2478a818-ca1b-4353-960b-373040627926.png" alt="img"></p><p>第一个参数必须为1，且下一个参数是上一个参数的两倍。</p><p>答案：1 2 4 8 16 32</p><h3 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1637999823800-76ef6a3c-8dbd-46ad-a1a2-d64b721c7e2f.png" alt="img"></p><p>第一个参数不能为负数，且 上一个参数的值 + 上一个参数的位置（从1开始） &#x3D; 下一个参数的值</p><p>答案：0 1 3 6 10 15  或 1 2 4 7 11 16 或 2 3 5 8 12 17 等等….</p><h3 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638000293402-9184a3d4-60b7-4566-965d-ad7f42089c07.png" alt="img"></p><p>第一个参数必须为0，第二个参数必须为1，接下来的参数规律为 </p><p>参数的值 &#x3D; 上一个参数的值 + 上上一个参数的值</p><p>即斐波那契数列: n &#x3D; (n-1) + (n-2)</p><p>答案：0 1 1 2 3 5</p><hr><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>输入两个整数，根据第一个整数的值跳转到指定的地址，执行一系列的算术计算得到第二个参数的值。</p><h3 id="情况一：-1"><a href="#情况一：-1" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638005343767-ed5287d8-42f9-4d01-91ab-d26a42b1a362.png" alt="img"></p><p>要求输入3个参数，sscanf函数要求的格式为%d %c %d，</p><p>这格式在汇编语句<code>lea    0x1657(%rip),%rsi</code>中说明了。执行到该语句时输出%rsi就能看到：</p><p>在gdb中输出rsi的语句：<code>x/s $rsi</code></p><p>经过参数1算出来的地址，跳转到该地址执行指令，再判断第二、第三参数的值</p><h3 id="情况二：-1"><a href="#情况二：-1" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638025795686-53b8b1f8-5768-4879-bb87-d53ca8d764d3.png" alt="img"></p><p>要求输入两个整数，经过参数1算出来一个地址，</p><p>跳转到该地址执行一系列加减指令，得到第二个参数的值</p><h3 id="情况三：-1"><a href="#情况三：-1" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638033265815-3284499c-d01a-4f95-8da6-fba2ee940251.png" alt="img"></p><p>要求输入两个整数，经过参数1算出来一个地址，</p><p>跳转到该地址执行mov 某个值, eax指令，eax就是第二个参数的值</p><hr><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>考察递归函数，要求输入两个整数，其中第一个参数进入一个递归函数进行计算，得到的结果作为第二个参数的值</p><h3 id="情况一：-2"><a href="#情况一：-2" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179323867-46a10cc3-763b-4a61-8cc0-99f87eaf2359.png" alt="img"></p><p>要求输入两个整数，第一个参数必须小于等于14，然后传第一个参数进入func4()进行计算，func4是一个递归函数，</p><p>计算出来的结果必须等于第二个参数的值。</p><p>比如这个举例中的计算出来的结果要求必须等于7，也就是要求第二个参数必须是7</p><p>phase_4还有可能是下面这种情况：第一个参数进入func4递归函数计算的结果等于第二个参数，要求第二个参数必须是0</p><p>汇编代码有一点点出入</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638203125462-f57a0205-6c3d-45c9-aa96-39a66d335992.png" alt="img"></p><p>下面分析一下func4的函数：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638179797742-63ca9457-94d6-40c5-ae12-cb407246f654.png" alt="img"></p><p>因为是跟踪递归函数，分析起来特别绕，就还原成c语言代码的样子来看这个递归函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4_1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-type">int</span> sub = c - b;<br>    <span class="hljs-type">int</span> tmp = (sub &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 取c-b后的最高位符号位的值  c-b&gt;=0时是0， c-b&lt;0时是1</span><br>    tmp += sub;     <span class="hljs-comment">// 加一次c-b的结果</span><br>    tmp &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// tmp / 2</span><br><br>    tmp += b;<br><br>    <span class="hljs-keyword">if</span> (tmp &lt;= a)&#123;<br>        <span class="hljs-keyword">if</span> (tmp == a) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// tmp &lt; a</span><br>        <span class="hljs-keyword">return</span> func4_1(a, tmp + <span class="hljs-number">1</span>, c) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> func4_1(a, b, tmp - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是还原成c语言代码后，仍然无法找到这个递归函数的规律，所以没头绪根据第二个参数的值来逆推第一个参数的值</p><p>于是就想到了暴力的方法：</p><p>因为第一个参数最多只能是 0 ~ 14，就尝试将这15个值依次传给func4函数，直到func4函数计算的返回值对上了第二个参数就行…那个就是答案</p><p>暴力破解代码：（res1、res2就是参数1和参数2）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">14</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (func4_1(i, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>) == res2)&#123;<br>        res1 = i;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="情况二：-2"><a href="#情况二：-2" class="headerlink" title="情况二："></a>情况二：</h3><p>与情况一十分类似，phase_4函数与情况一的一样，但是情况二func4的汇编与情况一func4有点出入：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638240086148-c97c58c4-fbfe-42a2-9ae7-889959406475.png" alt="img"></p><p>还原成c语言代码后是这样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4_2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-type">int</span> sub = c - b;<br>    <span class="hljs-type">int</span> tmp = (sub &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;      <span class="hljs-comment">// 取c-b后的最高位符号位的值  c-b&gt;=0时是0， c-b&lt;0时是1</span><br>    tmp += sub;     <span class="hljs-comment">// 加一次c-b的结果</span><br>    tmp &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// tmp / 2</span><br><br>    tmp += b;<br><br>    <span class="hljs-keyword">if</span> (tmp &lt;= a)&#123;<br>        <span class="hljs-keyword">if</span> (tmp == a) <span class="hljs-keyword">return</span> tmp;<br>        <span class="hljs-comment">// tmp &lt; a</span><br>        <span class="hljs-keyword">return</span> func4_2(a, tmp + <span class="hljs-number">1</span>, c) + tmp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> func4_2(a, b, tmp - <span class="hljs-number">1</span>) + tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解题思路跟情况一一样"><a href="#解题思路跟情况一一样" class="headerlink" title="解题思路跟情况一一样"></a>解题思路跟情况一一样</h6><h3 id="情况三：-2"><a href="#情况三：-2" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638530459022-d9bb7092-02f7-4757-a039-075515471207.png" alt="img"></p><p>要求输入两个整数，其中第一个参数的值存在到(%rsp + 4)，第二个参数的值存放到(%rsp)</p><p>第二个参数的值 必须大于2等于2 且 小于等于4</p><p>然后传 <strong>第二个参数</strong> 进入func4()递归函数进行计算，</p><p>计算出来的结果必须等于 <strong>第一个参数</strong> 的值。</p><p>func4函数汇编代码:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638201039649-3bb51edb-49bd-4461-8d02-fdc6bb07f037.png" alt="img"></p><p>由func4函数汇编代码尝试逆向还原为c语言代码的样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">return</span> b + func4(a - <span class="hljs-number">1</span>, b) + func4(a - <span class="hljs-number">2</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h1><p>考察数组操作。</p><h3 id="情况一：-3"><a href="#情况一：-3" class="headerlink" title="情况一："></a>情况一：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638260239080-33c957c1-67c3-4549-8ebf-48554ed6bcba.png" alt="img"></p><p>要求输入6个字符，取输入的6个字符的ascii码，每一个字符 &amp; 0xf，得到的值作为下标idx，在一个字符数组中获取该下标idx所在的字符，6个字符一共获取6次，拼凑成一个长度为6的字符串，该字符串要和答案字符串相等，即可通过。</p><p>字符数组其实就是上面汇编代码中指出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14d0</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">0</span>d <span class="hljs-number">69</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1469(%rip),%rcx        # <span class="hljs-number">2940</span> &lt;array.<span class="hljs-number">3416</span>&gt;<br></code></pre></td></tr></table></figure><p>执行到该行代码时，输出一下该字符数组的内容:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261126691-a164de85-22b6-4600-a8cd-1ebb22676b96.png" alt="img"></p><p>我们能取得长度一共16个字符，其中红色框中划起来的就是这个字符数组的内容，</p><p>为什么只能取16个字符？</p><p>因为 我们输入的字符 &amp; 0xf 的数组下标能表示范围是  0 - 15</p><p>最终拼接出来的字符串要和答案字符串比较，答案字符串存放在：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">14fa</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">35</span> <span class="hljs-number">16</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x1416(%rip),%rsi        # <span class="hljs-number">2917</span> &lt;_IO_stdin_used+<span class="hljs-number">0</span>x1b7&gt;<br></code></pre></td></tr></table></figure><p>输出该字符串的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638261852489-bba418f7-1eaa-466d-8fba-a6c4c9d58065.png" alt="img"></p><p>注意：例子中的 0x0000555555556917 地址为程序加载到内存后，上面指令计算出来的%rsi地址。每次运行时的地址都会不同。</p><p>整个phase_5的流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>[] in = <span class="hljs-string">&quot;abcdef&quot;</span>;    # 假设输入的是这<span class="hljs-number">6</span>个字符<br><span class="hljs-type">char</span>[] str = <span class="hljs-string">&quot;maduiersnfotvbyl&quot;</span>;# 假设字符数组是这样<br><span class="hljs-type">char</span>[<span class="hljs-number">7</span>] result;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>; idx &lt; <span class="hljs-number">6</span>; idx++)&#123;<br>result[i] = str[in[idx] % <span class="hljs-number">15</span>];<br>&#125;<br><br><span class="hljs-comment">// result字符串跟答案字符串相同就通过</span><br></code></pre></td></tr></table></figure><hr><h3 id="情况二：-3"><a href="#情况二：-3" class="headerlink" title="情况二："></a>情况二：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263253652-47fb215a-e86e-4d52-9175-edae596c7b62.png" alt="img"></p><p>要求输入6个字符，取输入的6个字符的ascii码，每一个字符 &amp; 0xf 得到的值作为<strong>下标idx</strong>，在一个整数数组中获取这个<strong>下标idx</strong>所在的值，将它们累加起来，一共累加6次，累加得到的整数结果与某个常数值判断相等，即可通过。</p><p>其中整数数组的部分内容长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638263031586-8d27b2e8-cb48-4540-b1cb-c9a42f24f95e.png" alt="img"></p><p>phase_5的主要流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>[] in = <span class="hljs-string">&quot;abcdef&quot;</span>;    # 假设输入的是这<span class="hljs-number">6</span>个字符<br><span class="hljs-type">int</span>[] <span class="hljs-built_in">array</span> = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">13</span>&#125;;# 整数数组<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>; idx &lt; <span class="hljs-number">6</span>; idx++)&#123;<br>result += <span class="hljs-built_in">array</span>[in[idx] &amp; <span class="hljs-number">0xF</span>];<br>&#125;<br><br><span class="hljs-comment">// result字符串跟某个常数值相同就通过</span><br></code></pre></td></tr></table></figure><hr><h3 id="情况三：-3"><a href="#情况三：-3" class="headerlink" title="情况三："></a>情况三：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638272059649-c2d07443-7d49-478f-b73c-e766d5bced82.png" alt="img"></p><p>要求输入两个整数值，参数1的值不能为15， 参数1 &amp; 0xf 得到的值作为一个下标idx，用这个下标idx从一个整数数组中获取值，</p><p>在条件循环中 获取 整数数组[idx] 的值，将这个值累加起来，</p><p>直到 整数数组[idx] &#x3D;&#x3D; 15时跳出循环。跳出循环后，要求循环的执行次数为15次、而且累加数等于第二个参数就可以通过。</p><p>其中整数数组的部分内容长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638320131960-388acabe-e4a1-43ad-8832-cbb84008ecda.png" alt="img"></p><p>phase_5的主要流程相当于下面的c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b;   <span class="hljs-comment">// 假如a,b为输入的两个整数值 参数1，参数2</span><br><span class="hljs-type">int</span> nums[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp = a &amp; <span class="hljs-number">0xf</span>;<br><br><span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">15</span>) bomb();<br><br><span class="hljs-keyword">do</span>&#123;<br>    cnt++;<br>    tmp = nums[tmp];<br>sum += tmp;<br>&#125;<span class="hljs-keyword">while</span>(tmp != <span class="hljs-number">15</span>);<br><br><span class="hljs-keyword">if</span>(cnt != <span class="hljs-number">15</span>) bomb();<br><span class="hljs-keyword">if</span>(sum != b) bomb();<br><br><span class="hljs-comment">// 到这里就通过</span><br></code></pre></td></tr></table></figure><hr><h1 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h1><p>这一题是链表元素排序题，输入6个整数，要求都必须小于等于6，根据输入的数进行链表元素排序。</p><p>分三种情况，</p><p>一种是要求链表元素从大到小排序</p><p>一种是要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。</p><p>一种是要求链表元素从小到大排序</p><p>这题汇编代码量有亿点点长，但实际上三种情况的大部分汇编代码都相符，只需要弄懂其中一种情况的代码，其它两种就迎刃而解了。所以这里只展开说情况一，情况二、三简单描述。</p><p>解答这种大量汇编代码的题需要自己画一遍指令跳转图，关键地方写注释，分清楚每个部分的作用。</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>输入6个整数，要求链表按照这6个整数排序后，链表元素从大到小排序</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638426652892-e8086171-d1ce-4aa3-af53-dd9ffe3ab29a.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638434110608-53d2e8d0-dcb0-48ba-8ef7-a98f7f20e024.png" alt="img"></p><p>在上面汇编代码中，核心的逻辑是将6个链表根据输入的值排序，然后判断排序的顺序是不是由大到小。</p><p>解题技巧是：只需要输出整个链表的各个值，依次写出排序顺序即可。</p><p>比如上面的例子，链表的地址在如下汇编代码中给出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">153e</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">15</span> cb <span class="hljs-number">2</span>c <span class="hljs-number">20</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x202ccb(%rip),%rdx     # <span class="hljs-number">204210</span> &lt;node1&gt;     ！！！第一个链表节点的位置<br></code></pre></td></tr></table></figure><p>在gdb下, 程序加载到内存中，所以看到的链表地址是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638428995222-02f14e0e-1670-40b0-b56d-8238de8006f2.png" alt="img"></p><p>在这个例子中，链表的地址是<code>0x555555758210</code></p><p>在gdb中输出这个链表，看看链表的结构如何，使用命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>/<span class="hljs-keyword">x</span> <span class="hljs-number">0x0000555555758210</span><br></code></pre></td></tr></table></figure><p>输入这个命令后继续按回车，就会查看这个链表的往下几个字节：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638429359817-d5cda132-6058-4cf1-b714-b59acff31273.png" alt="img"></p><p>根据上图的值，推断这个链表的c语言定义体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> value; <span class="hljs-comment">// 链表元素值</span><br>    <span class="hljs-type">uint32_t</span> num;  <span class="hljs-comment">// 链表编号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 链表下一个节点指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>先拿出每个元素的值</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432119589-02b2ecee-5f68-4309-b074-4161ec39ebaa.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432203079-27b42637-7aa3-4fa4-a81a-e3ca512810d0.png" alt="img"></p><p>注意上图没有node6节点，它的地址在node5的next指针中可以看到，输出该地址的值就可以看到。</p><p>在gdb中输入指令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>/<span class="hljs-keyword">x</span> <span class="hljs-number">0x0000555555758110</span><br></code></pre></td></tr></table></figure><p>注意，next指针地址占8个字节，且在小端模式的机器中运行，</p><p>所以next指针地址应该看做<code>0x0000555555758110</code>，而不是<code>0x5575811000005555</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638432412756-44bea54a-cc61-4e69-bc45-08ddc46f96e1.png" alt="img"></p><p>将6个节点的值汇总起来，并找出它们的大小关系</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从大到小排第几</td><td>5</td><td>1</td><td>4</td><td>3</td><td>6</td><td>2</td></tr></tbody></table><p>链表由大到小依次的顺序是:</p><p>node2-&gt; node6 -&gt; node4 -&gt; node3 -&gt; node1 -&gt; node5</p><p>所以这题的答案是：</p><p><strong>2 6 4 3 1 5</strong></p><hr><h3 id="情况二：-4"><a href="#情况二：-4" class="headerlink" title="情况二："></a>情况二：</h3><p>输入6个整数，要求链表元素从大到小排序，排序规则是：用7减每个参数值，得到相减后的值来进行每个链表排序的顺序。</p><p>情况二和情况一相比只有几点不同的地方，这两者的部分汇编代码比较如下图：（红色字体为两者不同的地方）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638437654331-c5d0102b-e8c2-4c23-82b0-982fb7d5b4bb.png" alt="img"></p><p>因为情况一和情况二思路差不多，以情况一的链表作为例子，首先得到每个元素的值：</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从大到小排第几</td><td>5</td><td>1</td><td>4</td><td>3</td><td>6</td><td>2</td></tr></tbody></table><p>链表由大到小依次的顺序是:</p><p>node2-&gt; node6 -&gt; node4 -&gt; node3 -&gt; node1 -&gt; node5</p><p>得到这6个排序的顺序值是：</p><p><strong>2 6 4 3 1 5</strong></p><p>排序规则是 7 - 某个数 &#x3D; 顺序值</p><p>2 &#x3D; 7 - <strong>5</strong></p><p>6 &#x3D; 7 - <strong>1</strong></p><p>4 &#x3D; 7 - <strong>3</strong></p><p>3 &#x3D; 7 - <strong>4</strong></p><p>1 &#x3D; 7 - <strong>6</strong></p><p>5 &#x3D; 7 - <strong>2</strong></p><p>所以得到这题答案是：</p><p><strong>5 1 3 4 6 2</strong></p><hr><h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><p>输入6个整数，要求链表按照这6个整数排序后，链表元素从小到大排序</p><p>情况三与情况一，两者只有比较大小的指令不同</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638442032597-7c9ad575-3093-4a0d-aa1f-f3c16faf21df.png" alt="img"></p><p>以情况一的链表作为例子，得到每个元素的值，列出从小到大的顺序：</p><table><thead><tr><th></th><th>node1</th><th>node2</th><th>node3</th><th>node4</th><th>node5</th><th>node6</th></tr></thead><tbody><tr><td>十六进制</td><td>0x102</td><td>0x3e1</td><td>0x1ad</td><td>0x2b0</td><td>0xb2</td><td>0x2de</td></tr><tr><td>十进制</td><td>258</td><td>993</td><td>429</td><td>688</td><td>178</td><td>734</td></tr><tr><td>从小到大排第几</td><td>2</td><td>6</td><td>3</td><td>4</td><td>1</td><td>5</td></tr></tbody></table><p>链表由小到大依次的顺序是:</p><p>node5-&gt; node1 -&gt; node3 -&gt; node4 -&gt; node6 -&gt; node2</p><p>所以这题答案是：</p><p><strong>5 1 3 4 6 2</strong></p><hr><h1 id="隐藏炸弹"><a href="#隐藏炸弹" class="headerlink" title="隐藏炸弹"></a>隐藏炸弹</h1><p>在做完第6关的炸弹后，发现phase_6的汇编代码后面还有一个函数叫<strong>secret_phase</strong></p><p>翻译一下就是隐藏的炸弹，这就是lab2中大名鼎鼎的隐藏炸弹函数了，</p><p>似乎要某种方式才能触发它，所以根据这个函数名找找哪个函数调用了它。</p><p>在反汇编代码中查找该函数名，发现整个程序中只有在<strong>phase_defused</strong>函数中调用了它，再查找一下谁调用了phase_defused函数</p><p>发现每通过一关都会调用一次phase_defused函数：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542390671-24d63361-2587-477b-8694-bc7bf1c0ae0a.png" alt="img"></p><p>于是分析一下phase_defused函数的作用：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638541193669-0c887ebf-c44c-4b3d-bb8e-551f00dbd6b8.png" alt="img"></p><p>每调用read_line函数，num_input_strings变量+1，num_input_strings变量可以理解为已经通过了第几关。</p><p>上图中说明这个函数大概意思是：在通过第6关后，会判断我们曾在第4关输入的内容，输入格式是 %d %d %s，</p><p>也就是说第四关除了输入两个整数以外，还要输入一个字符串，这个字符串就是进入隐藏函数的密钥。</p><p>使用gdb进入<strong>phase_defused函数</strong>输出一下这个密钥：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542129506-1760b0b3-9c5d-4d3e-bc54-f6049acbed0f.png" alt="img"></p><p>这个密钥是：<strong>DrEvil</strong></p><p><strong>（尽管每个人的前6关炸弹会有不同情况，但进入隐藏炸弹的密钥似乎大家都一样）</strong></p><p>所以如果想进入隐藏炸弹函数，就在原来的第四关通关答案中加入<strong>DrEvil</strong>字符串。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638542570949-9db49ab7-54ec-4c6c-9c55-958e1be8b312.png" alt="img"></p><p>分析完如何进入隐藏炸弹后，开始分析隐藏炸弹的汇编代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638543600054-fb855f45-6a4b-4656-a70c-8c9eaacac98a.png" alt="img"></p><p>隐藏炸弹的函数大概内容时：读入一行内容将它转换成10进制长整数，然后将这值传给fun7递归函数作为第二个实参，</p><p>判断返回结果，如果返回结果等于一个常数，隐藏炸弹就通关。上图的例子中，这个常数就是7.</p><p>注意到还有一个地址传给fun7作为第一个实参，输出一下这个地址，看一下里面的内容：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638550016555-aaa753c2-d5f6-4da1-8510-3164f5883a42.png" alt="img"></p><p>可以大胆猜测到传入的地址就是一个双链表的头部地址，而fun7是一个递归函数，将它们还原为c语言代码更容易分析些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>* <span class="hljs-title">prev</span>;</span><span class="hljs-comment">// 上一个链表指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>* <span class="hljs-title">next</span>;</span><span class="hljs-comment">// 下一个链表指针</span><br>&#125;DNode;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun7</span><span class="hljs-params">(DNode* p, <span class="hljs-type">long</span> <span class="hljs-type">long</span> num)</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        由于整个函数都是对eax操作，而不是rax，</span><br><span class="hljs-comment">        所以mov $0xffffffff,%eax  可以看作int型的-1</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> val = p-&gt;val;<br>    <span class="hljs-keyword">if</span> (val &gt; num)&#123;<br>        <span class="hljs-keyword">return</span> fun7(p-&gt;prev, num) * <span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; num)&#123;<br>        <span class="hljs-keyword">return</span> fun7(p-&gt;next, num) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// val == b</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>找出整个双链表的内容，还原一下它的样子</p><p>查看$rdi（即双链表头部地址）周围区域的内容：<code>x/128x $rdi</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638595763216-6505b22e-ea3a-43b5-95f8-ef2b557effca.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596904727-5afeacef-841e-4f1a-b934-67563e8199e1.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638596967846-29567282-cf20-4389-997a-9c644aeaa3b8.png" alt="img"></p><p>继续查看n31、n32、n33、n34的链表指针指向的地址：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599381317-c6f27893-a925-4a65-aa39-1dee57347fe4.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599654703-df912485-e876-4531-b257-b993bbda950b.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599692323-c8ca4231-7ed8-47c9-8127-a13aaa4b99f9.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638599790277-62fb556f-6726-4dfd-a5c4-e21edb831838.png" alt="img"></p><p>从这个双链表中画一个图找指针关联关系，发现是一颗二叉树，</p><p>并且结合fun7的递归函数规律，推导出一个结论：</p><p>当secret_phase函数传入fun7第二个实参等于二叉树第四层某颗树的值时，返回一个值。（如下图红色字体所示）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611077113-22bdf4f0-6284-4bdb-89ba-87956e4ff999.png" alt="img"></p><p>而我们这个例子中要求fun7返回值要等于7，那么传入fun7第二个实参应该为 <strong>0x3e9，即十进制的1001</strong></p><p><strong>所以这个例子中隐藏炸弹的通关字符串为：</strong> <strong>1001</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1352293/1638611173603-cc05f6ce-50b5-4c36-b306-76990ecad850.png" alt="img"></p><p>通关！！完美撒花~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My HTML &amp; CSS Notebook</title>
    <link href="/2022/07/08/My-CSS%20&amp;%20HTML-Notebook/"/>
    <url>/2022/07/08/My-CSS%20&amp;%20HTML-Notebook/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="行内元素与块级元素区别"><a href="#行内元素与块级元素区别" class="headerlink" title="行内元素与块级元素区别"></a>行内元素与块级元素区别</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%AF%B9%E6%AF%94">MDN</a></p><ul><li><p>内容</p><p>一般情况下，行内元素只能包含数据和其他行内元素。</p><p>而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li><li><p>格式</p><p>默认情况下，<strong>行内元素不会以新行开始，而块级元素会新起一行。</strong></p></li></ul><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p>特点：</p><ol><li>当块内元素转化为行内块元素时，如果没有给特点的宽度或者高度，则宽和高默认是元素内容的大小。</li></ol><p>应用：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是块元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上边三个div盒子默认按照标准流布局排放，即从上到下的方式，此时<strong>如果我想要让它们在一行显示，像行内元素一样，就可以在样式中设置display属性，如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123; <br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: gray;<br>  <span class="hljs-comment">/*将块元素转化成行内块元素实现一行排放盒子，使用display属性*/</span><br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，<strong>这三个div盒子就不是原来的块内元素，属性行内的块元素</strong></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="选择器优先级（specificity）"><a href="#选择器优先级（specificity）" class="headerlink" title="选择器优先级（specificity）"></a>选择器优先级（specificity）</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F">MDN 链接</a><br>CSS 选择器权重表：</p><p>![css选择器权重表](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725165840063.png)</p><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>页面布局要学习三大核心，<strong>盒子模型</strong>，<strong>浮动</strong>和<strong>定位</strong>。学习好盒子模型能非常好的帮助我们布局页面</p><p>看透网页布局的本质</p><p>网页布局过程：</p><p>1。先准备好相关的网页元素，网页元素基本都是盒子Box。</p><p>2。利用CSS设置好盒子样式，然后摆放到相应位置。</p><p>3。往盒子里面装内容。</p><p>网页布局的核心本质：就是利用CSS摆盒子。</p><ul><li>两条应用准则（重要）：</li></ul><ol><li><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</strong></li><li><strong>网页布局第二准则：先设置盒子大小，之后设置盒子的位置</strong></li></ol><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>![image-20220725182216656](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182216656.png)</p><p>![image-20220725182257247](&#x2F;Users&#x2F;zhuang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220725182257247.png)</p><h4 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border#syntax">三大属性 - border-width, border-color, border-sytle</a></p><p>边框复合（简写）写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/* 没有顺序 */</span><br></code></pre></td></tr></table></figure><p>边框分开写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red; <span class="hljs-comment">/*只设定上边框，其余同理 */</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse">额外属性 ：border-collapse - 处理表格边框是否合并属性</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-comment">/* 合并（collapsed ）模式下，表示相邻边框合并在一起(共享边框) */</span><br></code></pre></td></tr></table></figure><p><strong>边框会影响盒子的实际大小；</strong></p><h4 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h4><p>当盒子指定了宽度和高度时，<strong>内边距会影响盒子的实际大小；如：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为240px，高度为240px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时打开开发者面板工具，检查盒子大小会发现盒子的宽度为240px，高度为240px。</p><p>如果保证盒子为200px，跟效果图大小保特一致，<strong>则让width&#x2F;height减去多出来的内边距大小即可</strong>，将上面的写法改成下面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-comment">/* 盒子的宽度为200px，高度为200px（加上左右和上下两边的内边距20px） */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<strong>盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: aqua;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: pink;<br>      <span class="hljs-comment">/* 这里p元素继承div标签的宽和高，单独对p元素设置内边距不会撑大外面包裹的div盒子 */</span><br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>      <span class="hljs-attribute">background-color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><p>外边距合并问题？TODO</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="1-2-标准流（普通流-x2F-文档流）"><a href="#1-2-标准流（普通流-x2F-文档流）" class="headerlink" title="1.2 标准流（普通流&#x2F;文档流）"></a>1.2 标准流（普通流&#x2F;文档流）</h4><p><strong>所谓的标准流：就是标签按照规定好默认方式排列</strong></p><ol><li>块级元素会独占一行，从上到下顺序排序。</li></ol><ul><li>常用元素：div、hr、p、h1-h6、ul、ol、dl、form、table</li></ul><ol start="2"><li>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li></ol><ul><li>常用元素：span、a、i、em等</li></ul><p>以上都是标准流布局，我们前面学习的就是标准流，<strong>标准流就是最基本的布局方式。</strong></p><h4 id="1-3-为什么需要浮动"><a href="#1-3-为什么需要浮动" class="headerlink" title="1.3 为什么需要浮动"></a>1.3 为什么需要浮动</h4><ol><li><p>虽然块级元素能通过设置display转化成行内块级元素，达到多个块级元素（盒子div）水平排列成一行显示（排放）的目的，<strong>但是每个元素（盒子）之间的距离（缝隙）很难控制</strong></p></li><li><p><strong>在一个大盒子中存放着两个盒子，无法通过标准流的方式使得两个盒子左右对齐。</strong></p></li></ol><p>总结：有很多的布局效果，标准流没有办法完成，此时就河以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示。</p><p><strong>网页布局第一准则</strong>：<strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</strong></p><h4 id="1-4-什么是浮动"><a href="#1-4-什么是浮动" class="headerlink" title="1.4 什么是浮动"></a>1.4 什么是浮动</h4><p><strong>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">float</span>: 属性值; &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h4 id="1-5-浮动的特性（重难点）"><a href="#1-5-浮动的特性（重难点）" class="headerlink" title="1.5 浮动的特性（重难点）"></a>1.5 浮动的特性（重难点）</h4><ol><li>设置了浮动(f1oat)的元素最重要特性：</li></ol><ul><li><p>脱离标准普通流的控制（浮）移动到指定位置（动），（俗称<strong>脱标</strong>)</p></li><li><p>浮动的盒子不再保留原先的位置</p></li></ul><ol start="2"><li><p>如果多个盒子都设置了浮动，则它们会按照属性值<strong>一行内显示并且顶端对济排列</strong>。注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p></li><li><p>浮动元素会具有行内块级元素的特征。</p><p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有<strong>行内块元素</strong>相似的特性。</p></li></ol><ul><li><p>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添浮动后，它的大小根据内容来决定</p></li><li><p>浮动的盒子中间是没有缝隙的，是紧挨着一起的</p></li><li><p>行内元素同理</p></li></ul><h4 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置，我们网页布局一般采取的策略是：</p><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准侧</strong></p><h4 id="1-7-浮动布局注意点"><a href="#1-7-浮动布局注意点" class="headerlink" title="1.7 浮动布局注意点"></a>1.7 浮动布局注意点</h4><ol><li>浮动和标准流的父盒子搭配。</li></ol><p><strong>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</strong></p><ol start="2"><li>一个元素浮动了，理论上其余的兄弟元素也要浮动。</li></ol><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。</p><p><strong>浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流</strong></p><h4 id="1-8-为什么需要清除浮动"><a href="#1-8-为什么需要清除浮动" class="headerlink" title="1.8 为什么需要清除浮动"></a>1.8 为什么需要清除浮动</h4><p>我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点都是有高度的。</p><p>但是，所有的父盒子都必须要有高度吗？</p><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。</p><p><strong>我的理解是在实际的网页布局中，父盒子中被设置浮动的子盒子的数量和高度是不确定的，为了避免子盒子溢出父盒子，所以父盒子的高度不会写死（不会设置），但当父盒子没有设置高度时，里面浮动的子盒子会脱标，不会自动撑开父盒子的高度，会导致网页布局结构混乱，这时就需要清除浮动</strong></p><h4 id="1-9-清除浮动的本质"><a href="#1-9-清除浮动的本质" class="headerlink" title="1.9 清除浮动的本质"></a>1.9 清除浮动的本质</h4><ul><li><p>清除浮动的本质是清除浮动元素造成的影响</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</p></li></ul><h4 id="2-清除浮动方法"><a href="#2-清除浮动方法" class="headerlink" title="2 清除浮动方法"></a>2 清除浮动方法</h4><p><strong>清除浮动的策略是：闭合浮动</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">clear</span>: both; &#125;<br></code></pre></td></tr></table></figure><h5 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h5><p>颜外标签法也称为隔墙法，是W3C推荐的做法。</p><p>额外标签法会在浮动元素末尾添加一个空的标签。例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">clear</span>：both&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>或者其他标签 (如<br/>等)。</p><p>优点：通俗易懂，书写方便</p><p>·缺点：添加许多无意义的标签，结构化较差</p><p>注意：要求这个新的空标签必须是块级元素。</p><p><strong>实际工作可能会遇到，但是不常用</strong></p><h5 id="父级添加overflow属性"><a href="#父级添加overflow属性" class="headerlink" title="父级添加overflow属性"></a>父级添加overflow属性</h5><p>可以给父级添加overflow属性，将其属性值设置为<strong>hidden</strong>、auto或scroll。</p><p>子不教父之过，注意是给父元素添加代码</p><ul><li><p>优点：代码简洁</p></li><li><p>缺点：无法显示溢出的部分</p></li></ul><h5 id="父级添加after伪元素（推荐）"><a href="#父级添加after伪元素（推荐）" class="headerlink" title="父级添加after伪元素（推荐）"></a>父级添加after伪元素（推荐）</h5><p>:after 方式是额外标签法的升级版。</p><p>找到父级元素，然后添加一个类名为 clearFix，随后添加对应css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：没有增加标签，结构更简单</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：百度、淘宝网、网易等</p></li></ul><h5 id="父级添加双伪元素（推荐）"><a href="#父级添加双伪元素（推荐）" class="headerlink" title="父级添加双伪元素（推荐）"></a>父级添加双伪元素（推荐）</h5><p>也是给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 清除浮动 */</span><br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">::before</span>,<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.clearFix</span> &#123;<br>  <span class="hljs-comment">/* IE6、7 专有 */</span><br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优点：代码更简洁</p></li><li><p>缺点：照顾低版本浏览器</p></li><li><p>代表网站：小米、腾讯等</p></li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="为什么需要定位"><a href="#为什么需要定位" class="headerlink" title="为什么需要定位"></a>为什么需要定位</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/8R1L9q.png" alt="8R1L9q"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/K4p6U3.png" alt="K4p6U3"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/U9itev.png" alt="U9itev"></p><h4 id="定位组成"><a href="#定位组成" class="headerlink" title="定位组成"></a>定位组成</h4><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/cuPpYa.png" alt="cuPpYa"></p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/bL9n0j.png" alt="bL9n0j"></p><h5 id="静态定位（了解）"><a href="#静态定位（了解）" class="headerlink" title="静态定位（了解）"></a>静态定位（了解）</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/tcZSju.png" alt="tcZSju"></p><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/0hDzkj.png" alt="0hDzkj"></p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/nCNkSc.png" alt="nCNkSc"></p><p>绝对定位的特点：（务必记住）</p><ol><li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位(Document文档)。</li><li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li><li>绝对定位不再占有原先的位置。（脱标）</li></ol><h6 id="1-6-子绝父相的由来"><a href="#1-6-子绝父相的由来" class="headerlink" title="1.6 子绝父相的由来"></a>1.6 子绝父相的由来</h6><p>弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。</p><p>这个“子绝父相”太重要了，是我们学习定位的口决，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。</p><p>① 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p><p>② 父盒子需要加定位限制子盒子在父盒子内显示。</p><p>③ 父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p><p>这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。</p><p>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</p><p>当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。</p><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><h6 id="1-7-固定定位-fixed（重要）"><a href="#1-7-固定定位-fixed（重要）" class="headerlink" title="1.7 固定定位 fixed（重要）"></a>1.7 固定定位 fixed（重要）</h6><p>固定定位是元素<strong>固定于浏览器的可视化的位置</strong>。主要使用场景：可以在浏览器页面滚动时元素的位置不会变</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: fixed;<br></code></pre></td></tr></table></figure><p>固定定位的特点：（务必记住）</p><ol><li>以浏览器的可视窗口为参照点移动元素</li></ol><ul><li>跟父元素没有任何关系</li><li>不随滚动条移动</li></ul><ol start="2"><li>固定定位不在占有原先的位置</li></ol><p>固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。</p><p><strong>固定定位小技巧：固定在版心右侧位置</strong></p><p>小算法：</p><ol><li>让固定定位的盒子left：50px，走到浏览器可视区（也可以看做版心）的一半位置。</li><li>让固定定位的盒子margin-left：版心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。</li></ol><h5 id="粘性定位（了解）"><a href="#粘性定位（了解）" class="headerlink" title="粘性定位（了解）"></a>粘性定位（了解）</h5><p><strong>粘性定位</strong>可以被人们认为是相对定位和固定定位的混合体。Sticky 粘性的</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">position</span>: sticky; <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;&#125;<br></code></pre></td></tr></table></figure><p>粘性定位的特点：</p><ol><li>以浏览器的可视窗口为参照点移动元素（固定定位的特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li>必须添加 top、left、right、bottom 其中一个才有效</li></ol><p>跟页面滚动搭配使用。<strong>兼容性较差，IE不支持。所以大多数都是通过 JS 来控制实现粘性定位。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一定要记住<strong>相对定位、绝对定位、固定定位</strong>各两个大的特点：</p><ol><li>是否占有位置（脱标否）2.以谁为基准点移动位置。</li><li>学习定位重点学会子相父绝。</li></ol><h4 id="定位的叠放次序-z-index"><a href="#定位的叠放次序-z-index" class="headerlink" title="定位的叠放次序 z-index"></a>定位的叠放次序 z-index</h4><p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序（z轴）</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>数值可以是正整数、负整数或0，默认时auto，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来居上</li><li>数字后面不能加单位</li><li>只有定位的盒子才有z-index属性</li></ul><h4 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h4><h5 id="1-绝对定位的盒子居中"><a href="#1-绝对定位的盒子居中" class="headerlink" title="1. 绝对定位的盒子居中"></a>1. 绝对定位的盒子居中</h5><p>加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过以下计算方式实现水平和垂直居中。</p><p>水平居中方法：</p><p>1⃣️ left: 50%; 让盒子的左侧移动到父级元素的水平中心位置。</p><p>2⃣️ margin-left: -100px; 让盒子向左移动自身宽度的一半（注意负号代表往左）。</p><p>垂直居中方法：</p><p>1⃣️ top: 50%; 让盒子的顶部移动到父级元素的垂直位置。</p><p>2⃣️ margin-top: -100px; 让盒子向上移动自身高度的一半（注意负号代表往左）。</p><h5 id="2-定位的特殊性"><a href="#2-定位的特殊性" class="headerlink" title="2. 定位的特殊性"></a>2. 定位的特殊性</h5><p>绝对定位和固定定位也和浮动类似。</p><ol><li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度</li><li>块内元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li></ol><h5 id="3-脱标的盒子不会触发外边距塌陷"><a href="#3-脱标的盒子不会触发外边距塌陷" class="headerlink" title="3. 脱标的盒子不会触发外边距塌陷"></a>3. 脱标的盒子不会触发外边距塌陷</h5><p>浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并的问题。</p><h5 id="绝对定位（固定定位）会完全压住盒子"><a href="#绝对定位（固定定位）会完全压住盒子" class="headerlink" title="绝对定位（固定定位）会完全压住盒子"></a>绝对定位（固定定位）会完全压住盒子</h5><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p><p>但是绝对定位（固定定位）会压住下面标准流所有的内容。</p><p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。文字会围绕浮动元素</p><h3 id="网页布局总结"><a href="#网页布局总结" class="headerlink" title="网页布局总结"></a>网页布局总结</h3><p>通过盒子模型，清楚知道大部分html标签是一个盒子。</p><p>通过CSS浮动、定位可以让每个盒子排列成为网页。</p><p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。</p><ol><li>标准流</li></ol><p>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。</p><ol start="2"><li>浮动</li></ol><p>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。</p><ol start="3"><li>定位</li></ol><p>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学好JavaScript的好处</title>
    <link href="/2022/07/01/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/2022/07/01/%E5%AD%A6%E5%A5%BDJavaScript%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>todo</p><p>参考文章：<a href="https://blog.csdn.net/qq_38861711/article/details/95729429">https://blog.csdn.net/qq_38861711/article/details/95729429</a></p><p>对于前端工作者而言，JavaScript 作为三大前端套件中的一位成员不是没有原因的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>英语四级高频陌生词汇二</title>
    <link href="/2022/05/31/%E5%9B%9B%E7%BA%A7%E9%AB%98%E9%A2%91%E9%99%8C%E7%94%9F%E8%AF%8D%E6%B1%87%E4%BA%8C/"/>
    <url>/2022/05/31/%E5%9B%9B%E7%BA%A7%E9%AB%98%E9%A2%91%E9%99%8C%E7%94%9F%E8%AF%8D%E6%B1%87%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="lesson-4"><a href="#lesson-4" class="headerlink" title="lesson 4"></a>lesson 4</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>英语四级高频陌生词汇一</title>
    <link href="/2022/05/31/%E5%9B%9B%E7%BA%A7%E9%AB%98%E9%A2%91%E9%99%8C%E7%94%9F%E8%AF%8D%E6%B1%87%E4%B8%80/"/>
    <url>/2022/05/31/%E5%9B%9B%E7%BA%A7%E9%AB%98%E9%A2%91%E9%99%8C%E7%94%9F%E8%AF%8D%E6%B1%87%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h2><table><thead><tr><th align="left">单词</th><th align="left">词义</th><th align="left">例句</th></tr></thead><tbody><tr><td align="left">blur</td><td align="left">n. 模糊  v. （使）变模糊</td><td align="left">blur this image.</td></tr><tr><td align="left">substitute</td><td align="left">v. 用…代替，代以  n. 代替者，代替物</td><td align="left">If you do not eat meat, cashews are a good substitute.</td></tr><tr><td align="left">dean</td><td align="left">n. 教长；系主任</td><td align="left"></td></tr><tr><td align="left">council</td><td align="left">n.  委员会，理事会</td><td align="left"></td></tr><tr><td align="left">acknowledge</td><td align="left">vt. 承认；确认；报偿</td><td align="left">Belatedly, the government has acknowledged the problem. 政府迟迟才承认了该问题。</td></tr><tr><td align="left">proportion</td><td align="left">n. 比例</td><td align="left"></td></tr><tr><td align="left">exceptional</td><td align="left">a. 杰出的；</td><td align="left"></td></tr><tr><td align="left">revise</td><td align="left">vt. 修订；复习</td><td align="left"></td></tr><tr><td align="left">pursue</td><td align="left">vt. 继续</td><td align="left"></td></tr><tr><td align="left">terrific</td><td align="left">a. 极妙的</td><td align="left"></td></tr><tr><td align="left">yield</td><td align="left">vt. 屈服；倒塌 vt. 产生；n. 产量</td><td align="left"></td></tr><tr><td align="left">semester</td><td align="left">n. 学期</td><td align="left">When the new fresh guys coming, and the semester will starting.</td></tr><tr><td align="left">somewhat</td><td align="left">ad. 稍微，有点</td><td align="left"></td></tr><tr><td align="left">inevitable</td><td align="left">a. 不可避免的 n. 必然发生的事</td><td align="left">however, an inevitable question arises<br />然而，出现了一个不可避免的问题</td></tr><tr><td align="left">roar</td><td align="left">vi. 咆哮；轰鸣</td><td align="left"></td></tr><tr><td align="left">extinguish</td><td align="left">vt. 熄灭；使消亡</td><td align="left">It took about 50 minutes to extinguish the fire.</td></tr><tr><td align="left">sympathy</td><td align="left">n. 同情心</td><td align="left"></td></tr><tr><td align="left">fertile</td><td align="left">a. 肥沃的；多产的；丰富的</td><td align="left">fertilizer n 肥料 fertility n 肥沃</td></tr><tr><td align="left">vanish</td><td align="left">vi. 消失</td><td align="left"></td></tr><tr><td align="left">reconcile</td><td align="left">vt. 使协调；使和解；使顺从</td><td align="left">We suggest that it is possible to reconcile these apparently opposing perspectives.<br />我们认为有可能去调解这些明显对立的观点。</td></tr><tr><td align="left">clumsy</td><td align="left">a. 笨拙的；不得体的</td><td align="left"></td></tr><tr><td align="left">supreme</td><td align="left">a. 最高的</td><td align="left">His approval was of supreme importance. <br />他的认可是至关重要的。</td></tr><tr><td align="left">tuition</td><td align="left">n. 教学；学费</td><td align="left"></td></tr><tr><td align="left">vice</td><td align="left">n. 缺点；邪恶</td><td align="left"></td></tr><tr><td align="left">delicate</td><td align="left">a. 易碎的</td><td align="left"></td></tr><tr><td align="left">hollow</td><td align="left">a. 空的；沉闷的</td><td align="left">a hollow tree. 空心的树。</td></tr><tr><td align="left">likely</td><td align="left">a. 可能的；ad: 可能</td><td align="left"></td></tr><tr><td align="left">risk</td><td align="left">n. 危险 vt. 冒…的危险</td><td align="left">The mouse to risk it’s life  to look for foods.</td></tr><tr><td align="left">volcano</td><td align="left">n. 火山</td><td align="left"></td></tr><tr><td align="left">besides</td><td align="left">ad. 而且 prep. 除此之外</td><td align="left"></td></tr><tr><td align="left">harm</td><td align="left">n.&#x2F;vt. 伤害，损害</td><td align="left"></td></tr><tr><td align="left">vibrate</td><td align="left">v 颤抖</td><td align="left">The noise vibrated the table. <br />噪音使桌子颤抖起来。</td></tr><tr><td align="left">soar</td><td align="left">vi 猛增</td><td align="left">to soar from x to y. <br />从 x 骤增 到 y<br />Economic growth and job creation slow, while exports soar.<br />在出口激增的同时，经济增长和就业机会却在放缓。</td></tr><tr><td align="left">idle</td><td align="left">a 懒散的</td><td align="left">I never met such an idle bunch of workers in all my life!<br />我这辈子从没见过这么一群懒散的工人。</td></tr><tr><td align="left">dense</td><td align="left">a 密集的</td><td align="left">Things get shorter and more dense.<br />事情将会更短暂和密集。</td></tr><tr><td align="left">spill</td><td align="left">v. 溢出</td><td align="left">He spill wine down his suit.<br />他把葡萄酒洒在了他的西装上。</td></tr><tr><td align="left">indifferent</td><td align="left">a 冷漠的；一般的</td><td align="left">We’re both indifferent, and that’s fine.<br />我们都很冷漠，这样很好。</td></tr><tr><td align="left">distinguish</td><td align="left">v 区别于</td><td align="left">There is something about music that distinguishes it from all other art forms.<br />音乐的某种特质使得它区别于所有其他的艺术形式。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="lesson-2"><a href="#lesson-2" class="headerlink" title="lesson 2"></a>lesson 2</h2><table><thead><tr><th align="left">单词</th><th align="left">词义</th><th align="left">例句</th></tr></thead><tbody><tr><td align="left">candidate</td><td align="left">n. 申请求职者，候选人</td><td align="left"></td></tr><tr><td align="left">puzzle</td><td align="left">v 使迷惑；苦思 n. 智力测试，迷；难题</td><td align="left">my sister puzzles me and causes me anxiety. <br />我妹妹总让我捉摸不透，弄得我焦虑不安。</td></tr><tr><td align="left">resume</td><td align="left">v 恢复 n 摘要；简历</td><td align="left"></td></tr><tr><td align="left">worthy</td><td align="left">a 值得的；可尊敬的</td><td align="left"></td></tr><tr><td align="left">confess</td><td align="left">v 坦白；承认</td><td align="left"></td></tr><tr><td align="left">perceive</td><td align="left">vt 感知；认识到</td><td align="left">Stress is widely perceived as contributing to coronary heart disease. <br />压力被广泛认为是导致冠心病的一个因素。</td></tr><tr><td align="left">assumption</td><td align="left">n 假定；担任</td><td align="left"></td></tr><tr><td align="left">bias</td><td align="left">n 偏心 vt 使有偏见</td><td align="left">There is bias from different people has different attitude at social media.</td></tr><tr><td align="left">estate</td><td align="left">n 土地；财产</td><td align="left"></td></tr><tr><td align="left">recruit</td><td align="left">vt 招募，吸收 n 新兵</td><td align="left"></td></tr><tr><td align="left">illustrate</td><td align="left">vt 说明；给……做插图说明</td><td align="left"></td></tr><tr><td align="left">executive</td><td align="left">n 主管；</td><td align="left"></td></tr><tr><td align="left">supervise</td><td align="left">v 监督，管理</td><td align="left"></td></tr><tr><td align="left">impose</td><td align="left">vt 把……强加于；征税</td><td align="left"></td></tr><tr><td align="left">ignorance</td><td align="left">n. 无知</td><td align="left"></td></tr><tr><td align="left">lunar</td><td align="left">a 月的，月球的</td><td align="left"></td></tr><tr><td align="left">inclusive</td><td align="left">a 包括一切的</td><td align="left"></td></tr><tr><td align="left">discard</td><td align="left">vt 抛弃</td><td align="left"></td></tr><tr><td align="left">stereotype</td><td align="left">n 陈规，老套 vt 对……形成固定看法</td><td align="left"></td></tr><tr><td align="left">reinforce</td><td align="left">vt 增强</td><td align="left"></td></tr><tr><td align="left">peer</td><td align="left">n 同龄人</td><td align="left"></td></tr><tr><td align="left">scenery</td><td align="left">n 景色</td><td align="left"></td></tr><tr><td align="left">plague</td><td align="left">n 瘟疫；灾难 vt 使痛苦</td><td align="left"></td></tr><tr><td align="left">invade</td><td align="left">v 侵入，侵略</td><td align="left"></td></tr><tr><td align="left">contrary</td><td align="left">a 相反的</td><td align="left"></td></tr><tr><td align="left">participant</td><td align="left">n 参与者</td><td align="left"></td></tr><tr><td align="left">readily</td><td align="left">ad 乐意地</td><td align="left">When I was invited to the party, I readily accepted. <br />当我被邀请去派对时，我一口答应了。</td></tr><tr><td align="left">approve</td><td align="left">v 赞成</td><td align="left">approval n. 赞成</td></tr><tr><td align="left">contaminate</td><td align="left">vt 污染</td><td align="left">Have any fish been contaminated in the Arctic Ocean?<br />北冰洋的鱼受到过污染吗？</td></tr><tr><td align="left">counsel</td><td align="left">n 律师；劝告 vt 提议</td><td align="left"></td></tr><tr><td align="left">rational</td><td align="left">a 理性的；合理的</td><td align="left"></td></tr><tr><td align="left">slap</td><td align="left">vt 捆，掌击；啪的一声 n 掌击</td><td align="left"></td></tr><tr><td align="left">penetrate</td><td align="left">v 渗入；刺穿；洞察</td><td align="left">X-rays can penetrate many objects.<br />X 射线能穿透很多物体。</td></tr><tr><td align="left">prosperity</td><td align="left">n 兴旺，繁荣</td><td align="left"></td></tr><tr><td align="left">suspend</td><td align="left">vt 暂停；悬，吊</td><td align="left">Your network service has been suspended.</td></tr><tr><td align="left">intimidate</td><td align="left">vt 恐吓</td><td align="left">Attempts to intimidate people into voting for the governing party did not work.<br />胁迫人们为执政党投票的企图没有成功。</td></tr><tr><td align="left">stride</td><td align="left">vi 大步踏走 n 大步；步法</td><td align="left"></td></tr><tr><td align="left">grief</td><td align="left">n 悲伤；悲伤的事</td><td align="left">We all felt as if we were intruding on his private grief. <br />我们都觉得好像我们在触犯他的个人悲痛。</td></tr><tr><td align="left">superficial</td><td align="left">a 肤浅的；表面的</td><td align="left"></td></tr><tr><td align="left">tackle</td><td align="left">vt 对付；与……交涉；阻截；用具；</td><td align="left">The first reason to tackle these problems is to save children’s life.</td></tr><tr><td align="left">betray</td><td align="left">vt 背叛；失信于；泄露；暴露</td><td align="left">They offered me money if I would betray my associates. <br />如果我背叛我的同伙，他们就会给我钱。</td></tr><tr><td align="left">lean</td><td align="left">v 倾斜；靠 a 瘦的；贫乏的</td><td align="left"></td></tr><tr><td align="left">hazard</td><td align="left">n 危险 vt 冒……风险</td><td align="left"></td></tr><tr><td align="left">swift</td><td align="left">a 迅速的；敏捷的</td><td align="left">Our task is to challenge the UN to make a swift decision. 我们的任务时敦促联合国快速做出决策。</td></tr><tr><td align="left">assure</td><td align="left">vt 使确信；确保</td><td align="left"></td></tr><tr><td align="left">thrill</td><td align="left">n 兴奋 v （使）非常兴奋</td><td align="left">I can remember the thrill of not knowing what I would get on Christmas morning. <br />我还记得自己不知道圣诞节早晨会得到什么礼物时内心有多么激动。</td></tr><tr><td align="left">suggest</td><td align="left">v. 认为 提议 <strong>暗示、表明</strong></td><td align="left">Earlier reports suggested that a meeting would take place on Sunday.<br />早先的报道暗示周日可能会召开会议。</td></tr><tr><td align="left">satisfactory</td><td align="left">adj 令人满意的</td><td align="left">Finally, he gots a satisfactory results with exam.</td></tr><tr><td align="left">odd</td><td align="left">adj 古怪的；奇数的，单数的；</td><td align="left">At the beginning, I thought he is a odd people when I’m not know him.</td></tr><tr><td align="left">startle</td><td align="left">v 惊吓</td><td align="left">Sorry, I didn’t mean to startle you.<br />对不起，我不是故意想吓你一跳的。</td></tr><tr><td align="left">dose</td><td align="left">n. 剂量 vt 服药</td><td align="left">A good dose of willpower is often necessary to see any task through. <br />一剂良好的意志力对于完成任何一项任务都是必要的。</td></tr></tbody></table><h2 id="lesson-3"><a href="#lesson-3" class="headerlink" title="lesson 3"></a>lesson 3</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="取自默默背单词"><a href="#取自默默背单词" class="headerlink" title="取自默默背单词"></a>取自默默背单词</h2><table><thead><tr><th>单词</th><th>词义</th><th>例句</th></tr></thead><tbody><tr><td>lengthy</td><td>adj. 长的，冗长的</td><td></td></tr><tr><td>erosion</td><td>n. 腐蚀</td><td>an erosion of presidential power.<br />总统权力的削弱（腐蚀）</td></tr><tr><td>liberate</td><td>v. 解放；释放</td><td></td></tr><tr><td>remedy</td><td>n. 疗法；v. 纠正</td><td>The remedy lies in the hands of the government.<br />解决良策掌握在政府手中。</td></tr><tr><td>surf</td><td>v. 冲浪 n. 激浪</td><td></td></tr><tr><td>catastrophe</td><td>n. 灾难</td><td>From all points of view, war would be a catastrophe…<br />不管从哪方面说，战争都将是场灾难。</td></tr><tr><td>hold off</td><td>拖延</td><td>There is simply question, but he always hold off this thing.</td></tr><tr><td>monetary policy</td><td>货币政策</td><td>Some countries tighten monetary policy to avoid inflation.<br />一些国家实行紧缩的货币政策，以避免通货膨胀。</td></tr><tr><td>protectorate</td><td>n. 保护国 摄政</td><td>Hong Kong became a British protectorate.</td></tr><tr><td>devise</td><td>v. 想出；设计；发明</td><td>devise a solution and implement it.<br />想出一个解决方案并实现它</td></tr><tr><td>sensible</td><td>adj 理智的</td><td>The sensible thing is to leave them alone.<br />别去管他们才是明智的。</td></tr><tr><td>incentive</td><td>n 激励、刺激</td><td>There is little or no incentive to adopt such measures.<br />几乎没有什么激励政策来促使人们采取这些措施。</td></tr><tr><td>session</td><td>n. 会议；一段时间</td><td>a recording session<br />一段录音时间</td></tr><tr><td>chew</td><td>v 咀嚼</td><td>chew gum<br />嚼口香糖</td></tr><tr><td>retain</td><td>v 保留；保持</td><td>We shall retain our rights.<br />我们将保留我们的权利。</td></tr><tr><td>atop</td><td>prep 在……顶上</td><td>Under the newspaper, atop a sheet of paper, lay an envelope.<br />在报下面的一张纸上放着一封信封。</td></tr><tr><td>hostile</td><td>adj 敌对的</td><td>I don’t no why she is hostile to me.</td></tr><tr><td>provision</td><td>n 供应；预备；储粮；规定；条款</td><td>We set out with the provision.<br />我们带上供应品出发了</td></tr><tr><td>grave</td><td>n 坟墓</td><td></td></tr><tr><td>render</td><td>v. 给予；表达</td><td>I can’t render my thought.</td></tr><tr><td>nuisance</td><td>n 讨厌的人</td><td>Don’t make youself a nuisance to others.<br />不要做一个令人讨厌的人。</td></tr><tr><td>outer</td><td>adj. 外部的</td><td>The out</td></tr><tr><td>hint</td><td>n 暗示；提示</td><td>Don’t give me any hint. I’ll solve the puzzle myself.</td></tr><tr><td>arbitrary</td><td>adj 任意的</td><td>He made a arbitrary decision.<br />他做了一个颇为武断的决定</td></tr><tr><td>immigrate</td><td>v 移居入境</td><td></td></tr><tr><td>mild</td><td>adj 温和的；轻微的</td><td>The patient has a mild fever.</td></tr><tr><td>be obliged to</td><td>不得不</td><td>I hate to be obliged to clean the room.<br />我讨厌被逼着去打扫房间。</td></tr><tr><td>cast</td><td>n 全体演员；扮演者</td><td>Thanks to the wonderful performance of all the cast, the play suceed.</td></tr><tr><td>comrade</td><td>n. 同志；伙伴</td><td></td></tr><tr><td>gradual</td><td>a. 逐渐的</td><td>losing weight is a slow, gradual process<br />减肥是一个缓慢而逐渐的过程。</td></tr><tr><td>costly</td><td>a. 昂贵的</td><td>You want to avoid costly legal proceedings if you can.</td></tr><tr><td>precise</td><td>a. 准确的</td><td>She gave me clear and precise directions.<br />她给了我清晰而准确的提示。</td></tr><tr><td>tender</td><td>a. 温柔的；柔软的；</td><td>This meat is extremely tender.</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac 终端配置</title>
    <link href="/2022/05/24/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/24/Mac%20%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>准备工作：需要用到代理设置软件 clashX ，Vim编辑器基本操作命令，http传输协议原理</p><p>关于系统用户目录下的 .bash_profile 和 .zshrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd ~<br>//<br>vim .bash_profile<br><br>vim .zshrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发环境部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>终端</tag>
      
      <tag>Terminal</tag>
      
      <tag>oh-my-zsh</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 操纵速查表</title>
    <link href="/2022/05/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <url>/2022/05/24/Vim%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="普通模式下基本命令"><a href="#普通模式下基本命令" class="headerlink" title="普通模式下基本命令"></a>普通模式下基本命令</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除光标处字符</td></tr><tr><td><code>dd</code></td><td>删除一个词</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td><code>/search_text</code></td><td>检索文档，在文档后面的部分搜索 search_text</td></tr><tr><td><code>?search_text</code></td><td>检索文档，在文档前面的部分搜索 search_text</td></tr><tr><td><code>n</code></td><td>移动到后一个检索结果</td></tr><tr><td><code>N</code></td><td>移动到前一个检索结果</td></tr><tr><td></td><td></td></tr><tr><td><code>u</code></td><td>撤销最后的操作</td></tr><tr><td><code>Ctrl + r</code></td><td>重做最后撤销的操作</td></tr><tr><td></td><td></td></tr><tr><td><code>dd</code></td><td>删除当前行</td></tr><tr><td><code>d0</code></td><td>删除到行首</td></tr><tr><td><code>d$</code></td><td>删除到行末</td></tr><tr><td></td><td></td></tr><tr><td><code>h</code></td><td>光标向左移动一个字符</td></tr><tr><td><code>j</code> 或 <code>Ctrl + J</code></td><td>光标向下移动一行</td></tr><tr><td><code>k</code> 或 <code>Ctrl + P</code></td><td>光标向上移动一行</td></tr><tr><td><code>l</code></td><td>光标向右移动一个字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="进阶之复制和粘贴"><a href="#进阶之复制和粘贴" class="headerlink" title="进阶之复制和粘贴"></a>进阶之复制和粘贴</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制当前行至存储缓冲区</td></tr><tr><td><code>[&quot;x]yy</code></td><td>复制当前行至寄存器 x</td></tr><tr><td><code>p</code>（小写）</td><td>在当前行之后粘贴存储缓冲区中的内容</td></tr><tr><td><code>P</code>（大写）</td><td>在当前行之前粘贴存储缓冲区中的内容</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
      <tag>vi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树(Binary-Tree)</title>
    <link href="/2022/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/"/>
    <url>/2022/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2><p>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</p><h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><p>树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84">树结构</a>。通常分支被称作“左子树”或“右子树”。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>所有叶节点都在最底层的完全二叉树；</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>英语：(Binary Search Tree)：也称二叉搜索树、有序二叉树；</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端攻城师</title>
    <link href="/2022/04/10/Front-End%20developer%20tech%20interview/"/>
    <url>/2022/04/10/Front-End%20developer%20tech%20interview/</url>
    
    <content type="html"><![CDATA[<h1 id="Front-End-developer-tech-interview"><a href="#Front-End-developer-tech-interview" class="headerlink" title="Front-End developer tech interview"></a>Front-End developer tech interview</h1><h2 id="GET和POST两种基本请求方法的区别"><a href="#GET和POST两种基本请求方法的区别" class="headerlink" title="GET和POST两种基本请求方法的区别"></a>GET和POST两种基本请求方法的区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WinToGo - 可以随身携带的系统U盘</title>
    <link href="/2022/04/08/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/"/>
    <url>/2022/04/08/WinToGo%20-%20%E5%8F%AF%E4%BB%A5%E9%9A%8F%E8%BA%AB%E6%90%BA%E5%B8%A6%E7%9A%84%E7%B3%BB%E7%BB%9FU%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>我的mbp已经算是比较老的14年中装载4代i5的设备，对照以下这个图是支持制作USB系统盘启动Windows的。<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/1649086686847.jpg" alt="1649086686847"></p><h2 id="挑选适合做系统的U盘"><a href="#挑选适合做系统的U盘" class="headerlink" title="挑选适合做系统的U盘"></a>挑选适合做系统的U盘</h2><p>从<a href="https://bbs.luobotou.org/">萝卜头网</a>上了解到WTG对U盘性能有着一定的要求，这个网站有推荐购买的U盘（对于我来说太贵），这里特别得亏有大佬在上面分享了一些可供选择的比较特殊的U盘。这里对比一下我现有的普通闪迪U盘和以手机硬盘为颗粒的UFS盘之间的4k读写速度，特别是4k写入小文件的速度，可以明显的看到差距。<br>普通U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/%E9%97%AA%E8%BF%AA%E6%99%AE%E9%80%9AU'%E7%9B%98.png" alt="闪迪普通U&#39;盘"></p><p>适合做WTG的U盘：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/sm3833_ufs_U%E7%9B%98_4k%E5%86%99%E5%85%A5%E6%B5%8B%E8%AF%95.png" alt="sm3833_ufs_U盘_4k写入测试"></p><h2 id="使用工具制作启动U盘"><a href="#使用工具制作启动U盘" class="headerlink" title="使用工具制作启动U盘"></a>使用工具制作启动U盘</h2><p>开机长按<code>option</code>键，然后选中<strong>EFI Boot</strong>这个磁盘，直接按<code>Enter</code>键</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法和题库练习笔记</title>
    <link href="/2022/03/13/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/13/%E7%AE%97%E6%B3%95%E5%92%8C%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找（binary-search）"><a href="#二分查找（binary-search）" class="headerlink" title="二分查找（binary search）"></a>二分查找（binary search）</h2><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳</p></blockquote><blockquote><p>当乔恩·本特利将二分搜索问题布置给专业编程课的学生时，百分之90的学生在花费数小时后还是无法给出正确的解答，<strong>主要因为这些错误程序在面对边界值的时候无法运行，或返回错误结果。</strong>1988年开展的一项研究显示，20本教科书里只有5本正确实现了二分搜索。不仅如此，本特利自己1986年出版的《编程珠玑》一书中的二分搜索算法<strong>存在整数溢出的问题</strong>，二十多年来无人发现。Java语言的库所实现的二分搜索算法中同样的溢出问题存在了九年多才被修复。 ——摘自维基百科</p></blockquote><p>视频讲解：<a href="https://youtu.be/CMweVF2iSyQ">二分查找法</a><br>时间复杂度：O(logn)<br>伪代码及方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/006DDiezgy1h08n6lcku4j325012y4a8.jpg" alt="006DDiezgy1h08n6lcku4j325012y4a8"><br>力扣相关题目：<a href="https://leetcode-cn.com/problems/binary-search/">力扣算法题目704</a></p><h2 id="回溯法（backtracking）"><a href="#回溯法（backtracking）" class="headerlink" title="回溯法（backtracking）"></a>回溯法（backtracking）</h2><p>待看做笔记： <a href="https://youtu.be/nrHTtjkYEyQ">使用C++讲解</a><br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/01.39.29.png" alt="01.39.29"></p><h2 id="双指针（Two-pointer）"><a href="#双指针（Two-pointer）" class="headerlink" title="双指针（Two pointer）"></a>双指针（Two pointer）</h2><p>创建两个指针分别指向数组的首、末位置。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//test.c</span><br><span class="hljs-comment">//利用双指针判断字符的对称问题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//设置一个布尔值 symmetry默认为true</span><br><span class="hljs-type">bool</span> symmetry = <span class="hljs-literal">true</span>;<br><span class="hljs-type">char</span> str[]= <span class="hljs-string">&quot;BaeAB&quot;</span>; <span class="hljs-comment">//很明显,该字符串不是对称的</span><br><span class="hljs-comment">//遍历字符串数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str) / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-comment">//如果对称的两个位置上的数值不相等,则返回false</span><br><span class="hljs-keyword">if</span> (str[i] != str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c != %c\n&quot;</span>,str[i],str[<span class="hljs-built_in">strlen</span>(str)<span class="hljs-number">-1</span>-i]);<br>symmetry = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (symmetry) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串为对称的\n&quot;</span>,str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:该字符串不是对称的\n&quot;</span>,str);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>a != A<br>BaeAB:该字符串不是对称的<br></code></pre></td></tr></table></figure><p>在循环体for中, 当循环第一次时, <code>str[i]</code>和<code>str[strlen(str)-1-i]</code>分别指向<code>str</code>数组的首位和末位元素(这里是指结束符“\0”的前一位元素)。如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/dolphinchng/MyPic@master/uPic/J49VDc.png" alt="J49VDc"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac 下的常用终端（terminal）命令总结</title>
    <link href="/2022/03/06/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/06/Mac%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%AB%AF%EF%BC%88terminal%EF%BC%89%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><strong>简介：</strong></p><p><code>ls</code> 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一。</p><p>在终端里输入<code>ls</code>就可以查看文件和文件夹，但隐藏的文件就无法查看，使用<code>ls -a</code>即可。</p><p>“.” 代表当前目录，“..” 代表上一级目录，以 “.” 开头的文件为隐藏文件，需要用 -a 参数才能显示。</p><p><strong>ls常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><p><strong>ls 匹配通配符：</strong></p><p>与 DOS 下的文件操作类似，在 Unix&#x2F;Linux 系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>文件代表文件名中所有字符</td></tr><tr><td>ls te*</td><td>查找以 <code>te</code> 开头的文件</td></tr><tr><td>ls *html</td><td>查找结尾为 <code>html</code> 的文件</td></tr><tr><td>？</td><td>代表文件名中任意一个字符</td></tr><tr><td>ls ?.c</td><td>只找第一个字符任意，后缀为 <code>.c</code> 的文件</td></tr><tr><td>ls a.?</td><td>只找只有 3 个字符，前 2 字符为 <code>a.</code> ，最后一个字符任意的文件</td></tr><tr><td>[]</td><td><code>&quot;[”</code> 和 <code>“]”</code> 将字符组括起来，表示可以匹配字符组中的任意一个。<code>“-”</code> 用于表示字符范围。</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr><tr><td>ls [a-f]*</td><td>找到从 a 到 f 范围内的的任意一个字符开头的文件</td></tr><tr><td>ls a-f</td><td>查找文件名为 a-f 的文件,当 <code>“-”</code> 处于方括号之外失去通配符的作用</td></tr><tr><td>\</td><td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。<code>“?”</code> 和 <code>“*”</code> 处于方括号内时不用使用转义字符就失去通配符的作用。</td></tr><tr><td>ls *a</td><td>查找文件名为 <code>*a</code> 的文件</td></tr></tbody></table><h2 id="创建文件夹-x2F-目录"><a href="#创建文件夹-x2F-目录" class="headerlink" title="创建文件夹&#x2F;目录"></a>创建文件夹&#x2F;目录</h2><p>命令：<code>mkdir</code><br>使用说明：输入命令随后空格再输入目录名即可。<br>案例：创建一个 test 文件夹&#x2F;目录则对应命令就是<code>mkdir test</code></p><h2 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h2><p><code>cd</code> 命令进入目录比如要进入 test 目录则就是<code>cd test</code></p><h2 id="返回上一级目录"><a href="#返回上一级目录" class="headerlink" title="返回上一级目录"></a>返回上一级目录</h2><p>命令：<code>cd..</code></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>命令: <code>touch</code><br>笔者感觉这个命令还是挺靠谱的。Mac如果不用第三方工具（sublime等）是无法可视化创建一个txt文件。而用这个命令即可创建。<br>示例（创建一个test为名的 txt 文件）：<code>touch test.txt</code></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>命令：<code>cp</code><br>案例（拷贝一个 test.txt 文件并重新命名为test2.txt）：<code>cp test.txt test2.txt</code></p><h2 id="重命名或者移动文件"><a href="#重命名或者移动文件" class="headerlink" title="重命名或者移动文件"></a>重命名或者移动文件</h2><p>命令:   <code>mv</code><br>比如  (将一个 mountain.c  的 C 语言程序文件名字改成 mt.c )： <code>mv mountain.c mt.c</code></p><p>或者将 mountain.c 文件剪切到 code 文件夹下：<code>mv mountain.c code/</code></p><h3 id="批量修改文件名"><a href="#批量修改文件名" class="headerlink" title="批量修改文件名"></a>批量修改文件名</h3><p>例子：目录下有多个后缀为<code> .cpp</code> 的文件，我想让它们全部保留文件名的情况下修改成<code> .c</code> 后缀，这时可以结合 mv 命令和 shell 编程写个 for 循环，遍历每个文件然后依次更改。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">for i in *.cpp;do mv &quot;$i&quot; &quot;$&#123;i%.cpp&#125;.c&quot;;done<br></code></pre></td></tr></table></figure><p>模版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 把 xxx 换成要修改的文件名的后缀，yyy 换成替换输出的后缀即可。<br>for i in *.xxx;do mv &quot;$i&quot; &quot;$&#123;i%.xxx&#125;.yyy&quot;;done<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>命令：<code>find</code><br>案例（查找当前目录下所有的 txt 文件）：<code>find *.txt</code></p><p><strong>常用用法：</strong></p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>find .&#x2F; -name test.sh</td><td>查找当前目录下所有名为test.sh的文件</td></tr><tr><td>find .&#x2F; -name ‘*.sh’</td><td>查找当前目录下所有后缀为.sh的文件</td></tr><tr><td>find .&#x2F; -name “[A-Z]*”</td><td>查找当前目录下所有以大写字母开头的文件</td></tr><tr><td>find &#x2F;tmp -size 2M</td><td>查找在&#x2F;tmp 目录下等于2M的文件</td></tr><tr><td>find &#x2F;tmp -size +2M</td><td>查找在&#x2F;tmp 目录下大于2M的文件</td></tr><tr><td>find &#x2F;tmp -size -2M</td><td>查找在&#x2F;tmp 目录下小于2M的文件</td></tr><tr><td>find .&#x2F; -size +4k -size -5M</td><td>查找当前目录下大于4k，小于5M的文件</td></tr><tr><td>find .&#x2F; -perm 0777</td><td>查找当前目录下权限为 777 的文件或目录</td></tr></tbody></table><h2 id="显示当前的目录"><a href="#显示当前的目录" class="headerlink" title="显示当前的目录"></a>显示当前的目录</h2><p>命令：<code>pwd</code></p><h2 id="打开成可视化的文件夹"><a href="#打开成可视化的文件夹" class="headerlink" title="打开成可视化的文件夹"></a>打开成可视化的文件夹</h2><p>命令：<code>open</code><br>说明：如果是 <code>open</code>,则是打开当前命令里的目录，如果要打开指定的文件夹或者文件则格式为open要打开的路径即可。</p><h2 id="删除目录（空目录）"><a href="#删除目录（空目录）" class="headerlink" title="删除目录（空目录）"></a>删除目录（空目录）</h2><p>命令：<code>rmdir</code><br>案例：<code>rmdir test</code>（rmdir命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除目录（非空或者空目录都可以删除）推荐使用"><a href="#删除目录（非空或者空目录都可以删除）推荐使用" class="headerlink" title="删除目录（非空或者空目录都可以删除）推荐使用"></a>删除目录（非空或者空目录都可以删除）推荐使用</h2><p>命令： <code>rm -rf</code><br>案例：rm -rf test（rm -rf 命令后面空格在加上目录名）<br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>命令：<code>rm</code><br>案例（删除一个 test.txt 文件）：<code>rm test.txt</code><br>或者（删除所有后缀为 <code>.ttf</code> 的文件）：<code>rm *.ttf</code><br><strong>注意（慎用）</strong>：此删除不会出现在废纸篓里，<u><strong>不可恢复</strong>！</u>，为了防止文件误删，可以在 <code>rm</code> 后使用 <code>-i</code> 参数以逐个确认要删除的文件。</p><p><strong><code>rm</code> 常用参数：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>以进行交互式方式执行</td></tr><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><h2 id="Terminal-光标移动快捷键"><a href="#Terminal-光标移动快捷键" class="headerlink" title="Terminal 光标移动快捷键"></a>Terminal 光标移动快捷键</h2><ul><li>将光标移动到行首：<code>control + a</code></li><li>将光标移动到行尾：<code>control + e</code></li><li>清除屏幕：<code>control + l</code>, 相当于手动输入<code>clear</code>并回车</li><li>搜索以前使用命令：<code>control + r</code></li><li>清除当前行：<code>control + u</code></li><li>清除至当前行尾：<code>control + k</code></li><li>单词为单位移动：<code>option + 方向键</code></li><li>光标向前 (Forward) 移动一个字符位置：<code>Ctrl + f</code></li><li>光标往回(Backward)移动一个字符位置：<code>Ctrl + b</code></li><li>删除一个字符，相当于通常的 Delete 键（命令行若无所有字符，则相当于 exit；处理多行标准输入时也表示eof：<code>Ctrl + d</code></li><li>退格删除一个字符，相当于通常的 Backspace 键：<code>Ctrl + h</code></li></ul><h2 id="文件管理有关"><a href="#文件管理有关" class="headerlink" title="文件管理有关"></a>文件管理有关</h2><h4 id="1-归档管理：tar"><a href="#1-归档管理：tar" class="headerlink" title="1. 归档管理：tar"></a>1. 归档管理：<code>tar</code></h4><p><strong>简介：</strong></p><p>计算机中的数据经常需要备份，tar 是 Unix&#x2F;Linux 中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。其实说白了，就是打包。</p><p><strong><code>tar</code> 使用格式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar <span class="hljs-selector-attr">[参数]</span> 打包文件名 文件<br></code></pre></td></tr></table></figure><p><strong><code>tar</code> 常用参数：</strong></p><p>tar 命令很特殊，其参数前面可以使用“-”，也可以不使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>-v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>-f</td><td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td></tr><tr><td>-t</td><td>列出档案中包含的文件</td></tr><tr><td>-x</td><td>解开档案文件</td></tr></tbody></table><p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p><h4 id="2-文件压缩解压：gzip"><a href="#2-文件压缩解压：gzip" class="headerlink" title="2. 文件压缩解压：gzip"></a>2. 文件压缩解压：<code>gzip</code></h4><p><strong>简介：</strong></p><p>tar 与 gzip 命令结合使用实现文件打包、压缩。 tar 只负责打包文件，但不压缩，用 gzip 压缩 tar 打包后的文件，其扩展名一般用xxxx.tar.gz。</p><p><strong><code>gzip</code> 使用格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gzip  <span class="hljs-selector-attr">[选项]</span>  被压缩文件<br></code></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>解压</td></tr><tr><td>-r</td><td>压缩所有子目录</td></tr></tbody></table><p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 …</p><p><code>-z ：指定压缩包的格式为：file.tar.gz</code></p><p>解压用法： tar zxvf 压缩包包名</p><p><code>-z:指定压缩包的格式为：file.tar.gz</code></p><p>解压到指定目录：-C （大写字母“C”）</p><h4 id="3-文件压缩解压：bzip2"><a href="#3-文件压缩解压：bzip2" class="headerlink" title="3. 文件压缩解压：bzip2"></a>3. 文件压缩解压：<code>bzip2</code></h4><p><strong>简介：</strong></p><p>tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。</p><p>tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。</p><p>在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。</p><p>压缩用法：tar -jcvf 压缩包包名 文件…(tar jcvf bk.tar.bz2 *.c)</p><p>解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</p><h4 id="4-文件压缩解压：zip-、unzip"><a href="#4-文件压缩解压：zip-、unzip" class="headerlink" title="4. 文件压缩解压：zip 、unzip"></a>4. 文件压缩解压：<code>zip</code> 、<code>unzip</code></h4><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><p>压缩文件：zip [-r] 目标文件(没有扩展名) 源文件</p><p>解压文件：unzip -d 解压后目录文件 压缩文件</p><h4 id="5-输出重定向命令：-gt"><a href="#5-输出重定向命令：-gt" class="headerlink" title="5. 输出重定向命令：&gt;"></a>5. 输出重定向命令：<code>&gt;</code></h4><p><strong>简介：</strong></p><p>Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p><p>注意： <code>&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部。</code></p><h4 id="6-分屏显示：more"><a href="#6-分屏显示：more" class="headerlink" title="6. 分屏显示：more"></a>6. 分屏显示：<code>more</code></h4><p><strong>简介：</strong></p><p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用 <code>more</code> 命令，每次只显示一页，按下空格键可以显示下一页，按下 <code>q</code> 键退出显示，按下 <code>h</code> 键可以获取帮助。</p><h4 id="7-文本搜索：grep"><a href="#7-文本搜索：grep" class="headerlink" title="7. 文本搜索：grep"></a>7. 文本搜索：<code>grep</code></h4><p><strong>简介：</strong></p><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。如果找到匹配模式， grep 打印包含模式的所有行。</p><p>grep一般格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grep <span class="hljs-selector-attr">[-选项]</span> ‘搜索内容串’文件名<br></code></pre></td></tr></table></figure><p>在 grep 命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p><p><strong><code>grep</code> 常用参数：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>grep 搜索内容串可以是正则表达式。</p><p><strong>grep 常用正则表达式：</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt</td></tr><tr><td>ke$</td><td>行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt</td></tr><tr><td>[Ss]igna[Ll]</td><td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt</td></tr><tr><td>.</td><td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt</td></tr></tbody></table><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p>👉 <a href="https://support.apple.com/zh-cn/guide/terminal/trmlshtcts/mac">Mac 上“终端”中的键盘快捷键 - Apple 支持 (中国)</a> </p>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇总常用Git指令及用法</title>
    <link href="/2022/03/01/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>/2022/03/01/%E6%B1%87%E6%80%BB%E5%B8%B8%E7%94%A8Git%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为 <code>.gitconfig</code> 它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--list</span><br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> -<span class="hljs-string">e</span> [<span class="hljs-built_in">--global]</span><br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;[name]&quot;</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、增加-x2F-删除文件"><a href="#三、增加-x2F-删除文件" class="headerlink" title="三、增加&#x2F;删除文件"></a>三、增加&#x2F;删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用场景：如果想要忽略已检入的文件，则必须在添加忽略该文件的规则之前取消跟踪它。以下操纵命令为从终端取消跟踪文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="六、撤销"><a href="#六、撤销" class="headerlink" title="六、撤销"></a>六、撤销</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>版本管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/22/hello-world/"/>
    <url>/2022/02/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
